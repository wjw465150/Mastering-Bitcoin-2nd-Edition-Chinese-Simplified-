{"./":{"url":"./","title":"前言","keywords":"","body":"精通比特币（第二版） 本书主要面向开发人员，前两章对比特币的介绍也适用于非开发人员。任何对技术有基本了解的人都可以阅读前两章，以深入了解比特币。 翻译,整理: 白石 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 16:09:17 "},"01前言.html":{"url":"01前言.html","title":"写在开始","keywords":"","body":"前言 写作比特币的书 我第一次接触比特币是在2011年年中，我的第一反应或多或少是“哈哈，愚蠢的货币”，然后我又忽视了它六个月，没有意识到它的重要性。 这是我在许多最聪明的人身上看到的一种反应，这给了我一些安慰。第二次遇到比特币时，是在一次邮件列表讨论中，我决定阅读中本聪(Satoshi Nakamoto)撰写的白皮书，研究权威来源，看看到底是怎么回事。 我仍然记得读完那九页的那一刻，我意识到比特币不仅仅是一种数字货币，而是一种信任网络，它不仅可以为货币提供基础，还可以为更多的东西提供基础。意识到“这不是钱，这是一个分散的信任网络”，我开始了为期四个月的旅程，吞噬我所能找到的关于比特币的所有信息。 我变得痴迷和着迷，每天花12个或更多的时间盯着屏幕，尽可能多地阅读、写作、编程和学习。当我从神游的状态走出来，由于饮食不稳定，我的体重减轻了20多磅，我决心致力于比特币的研究。 两年后，我创建了一些小型初创公司，探索各种比特币相关的服务和产品，我决定是时候写我的第一本书了。比特币这个话题让我陷入了疯狂的创造中，吞噬了我的思想； 这是自互联网以来我遇到的最令人兴奋的技术。现在是时候向更广泛的观众分享我对这项神奇技术的激情了。 目标读者 这本书主要是写给程序员的。如果你能使用一种编程语言，这本书将教你密码货币如何工作，如何使用它们，以及如何开发与它们一起工作的软件。前几章也适合于非程序员，那些试图了解比特币和加密货币内部工作原理的人，用于对比特币的深入介绍。 为什么封面上有只虫子 切叶蚁是一种在群体超有机体中表现出高度复杂行为的物种，但每一只蚂蚁都是在一套简单的规则上运作的，这些规则是由社交互动和化学气味(信息素)的交换驱动的。 根据维基百科：“除人类外，切叶蚁是地球上最大、最复杂的动物群落”。切叶蚁实际上并不吃树叶，而是用它们来种植真菌，这是蚁群的主要食物来源。由此我们能得出什么？这些蚂蚁是在耕作！ 虽然蚂蚁形成了一个基于群落的社会，并有一个繁殖后代的蚁后，但在蚁群中没有中央权威或领导。一个由数百万人组成的群体所表现出的高度智能和复杂的行为，是社交网络中个体相互作用的一种新兴属性。 自然表明，分散的系统可以是有弹性的，并且可以产生突发性的复杂性和难以置信的复杂性，而不需要一个中央权威、层次或复杂的部分。 比特币是一个高度复杂的分散的信托网络，可以支持各种金融流程。 然而，比特币网络中的每个节点都遵循一些简单的数学规则。许多节点之间的交互是导致复杂行为出现的原因，而不是任何单个节点的固有复杂性或信任。 就像蚂蚁群落一样，比特币网络是一个由简单的节点组成的弹性网络，遵循简单的规则，这些节点在没有任何集中协调的情况下可以一起完成令人惊叹的事情。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 12:35:37 "},"02术语.html":{"url":"02术语.html","title":"快速术语表","keywords":"","body":"快速术语表 这个术语表包含了许多与比特币相关的术语。这些术语在整本书中都有使用，所以把它作为一个快速参考。 地址（address） 比特币的地址看起来是这样的： 1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV。它由一串字母和数字组成。它实际上是一个公共密钥160位哈希的base58check编码版本。就像你让别人给你发电子邮件一样，你也会让别人把比特币发给你的一个比特币地址。 比特币改进建议（bip） 比特币改进建议，比特币社区的成员们提交了一套改进比特币的提议。例如，BIP-21提议改进比特币统一资源标识(URI)方案。 比特币（bitcoin） 货币单位(coin)的名称、网络和软件。 区块（block） 以时间戳为标记的一组交易，以及上一个区块的指纹。区块的头被进行哈希运算以产生工作证明，从而验证交易。有效的区块在网络上达成共识后被到主区块链中。 区块链（blockchain） 一系列经过验证的区块组成的列表，每个区块都链接到它的前一个区块，一直到创世区块。 拜占庭将军问题（Byzantine Generals Problem） 一个可靠的计算机系统必须能够处理它的一个或多个组件的故障情况。失败的组件可能表现出一种经常被忽略的行为，即向系统的不同部分发送冲突信息。 处理这类失败的问题抽象地表述为拜占庭将军问题。 币基（coinbase） 一种特殊的字段，用作币基交易的的唯一输入。coinbase允许声明区块奖励，并可提供最多100字节的任意数据。 不要与币基交易（coinbase transaction）混淆。 币基交易（coinbase transaction） 区块中的第一笔交易。通常由矿工创建，包含一个币基。 不要与币基交易（coinbase）混淆。 冷存储（cold storage） 指的是保持比特币的离线储备。当比特币私钥被创建并存储在安全的脱机环境中时，就可以实现冷存储。对持有比特币的人来说，冷存储很重要。网络计算机容易受到黑客攻击，不应该用来储存大量比特币。 彩色币（colored coins） 一个开源的比特币2.0协议，允许开发者利用比特币区块链的功能创建数字资产。 确认（confirmations） 一旦交易包含在一个区块中，它就有一个确认。只要有另一个区块在同一个区块链上开采，交易就会有两个确认信息，依此类推。六个或更多的确认被认为足以证明交易无法撤销。 共识（consensus） 当几个节点（通常是网络上的大多数节点）在其本地验证的最佳块链中都具有相同的块时，即达成共识。 不要与共识规则（consensus rules）混淆。 共识规则（consensus rules） 完整节点遵循的块验证规则，为了与其他节点达成共识。 不要与共识（consensus）混淆。 挖矿难度（difficulty） 一个全网范围的配置，控制需要多少计算来产生工作证明。 难度重新计算（difficulty retargeting） 每产生2,016个块，全网重新计算一次挖矿难度，并考虑先前的2016个块的哈希计算能力。 难度目标（difficulty target） 使网络中平均10分钟生产一个区块的难度。 双重支付（double-spending） 双重支付是将某笔前成功花费一次以上的结果。通过验证每个添加到区块链的交易来确保交易的输入先前没有花费，比特币可以防止双重支出。 椭圆曲线数字签名算法（ECDSA） ECDSA (Elliptic Curve Digital Signature Algorithm）是比特币使用的一种加密算法，以确保资金只能由其合法所有者使用。 额外的随机数（extra nonce） 随着困难的增加，矿工经常循环遍历所有40亿个临时值，仍没有产生区块。因为币基（coinbase）脚本可以存储2到100个字节的数据，所以矿工开始使用这个空间作为额外的随机数空间，允许他们探索更大范围的区块头数据以找到有效的区块。 交易费（fees） 交易的发起人通常会向网络提供交易处理的费用。大多数交易需要0.5mBTC的最低费用。 分叉（fork） 分叉，或意外分叉，当两个或两个以上的块具有相同的块高度时发生，导致区块链分叉。通常发生在两个或更多矿工几乎同时发现矿块时，也可能作为一种攻击方式发生。 创世区块（genesis block） 区块链中的第一个区块，用来初始化加密货币。 硬分叉（hard fork） 硬分叉（Hard fork)，也叫做硬分叉更改（Hard-Forking Change)，是区块链中的一种永久分歧，通常发生于未升级的节点无法验证升级节点创建的区块时。 不要与分叉（fork），软分叉（soft fork），软件分叉（software fork）或Git分叉（git fork）混淆。 硬件钱包（hardware wallet） 硬件钱包是一种特殊类型的比特币钱包，它将用户的私钥存储在安全的硬件设备中。 哈希（hash） 一些二进制输入的数字指纹。 哈希锁（hashlocks） 哈希锁是一种限制一笔输出在指定的数据公开前不能被消费的财产留置权。哈希锁非常有用，一旦一把哈希锁被打开，任何其他使用相同密钥保护的哈希锁也会被打开。这使得我们可以创建多个输出，这些输出都被同一个哈希锁留置，并且可以在同一时间变成可消费的。 分层确定性协议（HD protocol） 分层确定性（HD）密钥创建和传输协议（BIP32），允许从层次结构中的父密钥创建子密钥。 分层确定性钱包（HD wallet） 使用分层确定性（HD Protocol）密钥创建和传输协议（BIP32）的钱包。 分层确定性钱包种子（HD wallet seed） HD钱包种子或根种子是一种可能很短的值，用于生成HD钱包的主私钥和主链代码的种子。 哈希时间锁定合约（HTLC） 哈希时间合约（Hashed TimeLock Contract）或HTLC是一种支付类型，它使用哈希锁和时间锁来要求一笔支付的收款方要么在指定日期之前通过生成加密收款证明，要么放弃接受支付的权力，将其返还给支付方。 了解你的客户（KYC） 了解你的客户（Know your customer，KYC）是一项企业活动，表示识别并验证它的客户。该术语也用于指代管理这些活动的银行法规。 LevelDB LevelDB是一个开源的基于磁盘的键值存储引擎。LevelDB是一个用于持久化存储的，轻量级的，单用途库，与许多平台绑定。 闪电网络（Lightning Networks） 闪电网络是带有双向支付渠道的哈希时间锁合约（HTLC）的建议实现，其允许多笔支付在多个点对点支付渠道上安全路由。这样就可以形成一个网络，网络中的任何一点都可以向任何其他点发起支付，即使他们之间没有直接通道。 锁定时间（Locktime） Locktime, 或者更专业地叫做nLockTime, 是交易的一部分，它表明该交易可能被添加到区块链时最早的时间或最早的区块。 内存池（mempool） 比特币内存池（memory poll）是经过比特币节点验证但尚未确认的所有交易数据的集合。 默克尔根（merkle root） Merkle树的根节点，区块头必须包含一个有效的merkle根，根据该块中的所有交易生成。 默克尔树（merkle tree） 通过计算每对儿数据（树叶）的哈希值构建的树，然后再对结果进行配对和哈希，直到只剩一个哈希值，即merkle根。在比特币中，叶子几乎总是来自单个块的交易。 矿工（miner） 是指一个网络节点，通过重复哈希计算，来寻找新区块的有效工作证明。 多重签名（multisignature） 多重签名（multisigature）是指要求多个密钥授权比特币交易。 网络（network） 一个点对点网络，用于将交易和数据块传播到网络上的每个比特币节点。 随机数（nonce） 比特币区块中的“nonce”是一个32位（4字节）的字段，通过设置它的值可以使得区块的哈希值包含若干个前导零。其余的字段可能不会改变，因为它们具有定义的含义。 脱链交易（off-chain transactions） 脱链交易是区块链之外的价值转移，链上交易（通常简称为交易）修改区块链并依靠区块链来确定其有效性，脱链交易依赖于其他方法来记录和验证交易。 opcode 比特币脚本语言的操作代码，用于在公钥脚本或签名脚本中推送数据或执行功能。 开放资产协议（Open Assets protocol） 开放资产协议（Open Assets Protocol）是一个建立在比特币区块链之上的简单而强大的协议。它允许发布和传输用户创建的资产。开放资产协议是彩色币概念的演变。 OP_RETURN OP_RETURN交易中的一个输出中使用的操作码。不要与OP_RETURN交易混淆。 OP_RETURN 交易 一种交易类型，它将任意数据添加到可证明不可消费的pubkey脚本中，完整节点不需要存储在其UTXO数据库中。不要与OP_RETURN操作码混淆。 孤块（orphan block） 其父区块还未被本地节点验证的块，所以它们也不能被完全验证。不要和陈腐区块（stale block）混淆 孤儿交易（orphan transactions） 由于缺少一个或多个输入交易，而无法进入交易池的交易。 输出（output） 输出，交易输出，或者TxOut，是交易中的输出，其包含两个字段：一个用于传递零个或多个聪（satoshis，比特币最小单位）的值域和一个用于指示为了进一步花费这些聪必须满足什么条件的pubkey脚本。 P2PKH 向比特币地址支付的交易包含P2PKH（Pay To PubKey Hash）脚本，由P2PKH锁定的输出可以通过公钥和由对应的私钥创建的数字签名来解锁（消费）。 P2SH P2SH（Pay-to-Script-Hash）是一种功能强大的新型交易，大大简化了复杂交易脚本的使用。通过P2SH，详细说明消费输出（赎回脚本）的复杂脚本不会显示在锁定脚本中，只有它的哈希值在锁定脚本中。 P2SH地址 P2SH地址是一个脚本的20比特哈希值的Base58Check编码, P2SH地址使用版本前缀“5”，导致Base58Check编码后的地址以“3”开头。P2SH地址隐藏了所有的复杂性，因此付款人看不到脚本。 P2WPKH P2WPKH（Pay-to-Witness-Public-Key-Hash）的签名包含与P2PKH支出相同的信息，但位于witness字段而不是scriptSig字段。scriptPubKey也被修改了。 P2WSH P2SH和P2WSH（Pay-to-Witness-Script-Hash）之间的差异是加密证明信息的位置从scriptSig字段变为witness字段，scriptPubKey字段也被修改了。 纸钱包（paper wallet） 具体来讲，纸质钱包是一个文件，其中包含生成任意数量的比特币私钥所需的所有数据，形成了密钥的钱包。但是，人们经常使用这个术语来表示任何将比特币作为物理文档离线存储的方式。第二个定义还包括纸密钥和可兑换代码。 支付通道（payment channels） 小额支付通道或支付通道是一类技术，旨在允许用户进行多个比特币交易，而无需将所有交易交给比特币区块链。在典型的支付通道中，只有两笔交易被添加到区块链中，但参与者之间可以进行无限次或几乎无限次数的付款。 矿池挖矿（pooled mining） 矿池采矿是一种采矿方式，其中多个客户端合力产生一个区块，然后根据它们提供的处理能力分割区块奖励。 权益证明（Proof-of-Stake） 权益证明（Proof-of-Stake，PoS）是一种加密货币区块链网络实现分布式共识的方法。权益证明要求用户证明一定数量的货币（它们在货币中的“股份”）的所有权。 工作量证明（Proof-of-Work） 需要大量计算才能找到特定数据。在比特币中，矿工必须找到SHA256算法的数字解决方案，以满足整个网络的目标，即难度目标。 奖励（reward） 包含在每个新区块中的一定数量的比特币，作为对网络中发现工作证明解决方案的矿工的奖励。目前它是每个区块12.5比特币。 RIPEMD-160 RIPEMD-160是一个160位的加密哈希方法。RIPEMD-160是RIPEMD的一个加强版本，具有160位散列结果，预计在未来十年或更长时间内可以保证安全。 中本聪（satoshi） 聪（satoshi）是可以记录在区块链上的最小比特币单位。它相当于0.00000001比特币，以比特币的创造者中本聪（Satoshi Nakamoto）命名 中本聪（Satoshi Nakamoto） 中本聪（Satoshi Nakamoto）是设计比特币并开发原始参考实现代码的一个人或几个人的用名，作为实施的一部分，他们还设计了第一个区块链数据库。在这个过程中，他们率先解决了数字货币的双重支付问题，但他们的真实身份仍然未知。 脚本（Script） 比特币使用脚本系统进行交易。脚本很简单，基于堆栈，并且从左到右进行处理。它故意设计成不是图灵完备的，不支持循环。 公钥脚本（ScriptPubKey，pubkey script） ScriptPubKey或pubkey script, 是一个包含在输出中的脚本，它为消费那些satoshis设定了必须满足的条件。满足条件的数据可以在签名脚本中提供。 签名脚本（ScriptSig，signature script） ScriptSig或signature script, 是由付款人生成的，作为满足公钥脚本（PubKey Script）的变量 私钥（secret key，private key） 解锁特定地址上的比特币的私密数字，看起来如下：5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh 隔离见证（Segregated Witness） 隔离见证是对比特币协议的升级建议，技术上创新地将签名数据与比特币交易分开。隔离见证是一种建议的软分叉，技术上的变化使得比特币的协议规则更具限制性。 SHA 安全散列算法或SHA是美国国家标准与技术研究院（NIST）发布的一系列加密散列函数。 简单支付验证（Simplified Payment Verification，SPV） 简单支付验证（SPV）或是一种验证特定交易是否包含在一个区块中的方法，不需要下载整个块。该方法被一些轻量级比特币客户使用。 软分叉（soft fork） 软分叉是区块链中的临时分叉，通常当矿工使用不遵从新共识方法的未升级的节点时发生。不要和分叉、硬分叉、软件分叉或Git分叉混淆。 陈腐区块（stale block） 已成功开采但未包括在当前最佳区块链中的区块，可能是因为同一高度的其他区块首先扩展了其链条。不要与孤儿块混淆。 时间锁（timelocks） 时间锁是一种限制某些比特币直到指定的未来时间或区块高度才能支出的留置权。时间锁在许多比特币合约中有重要作用，包括支付通道，和哈希时间锁定合约。 交易（transaction） 简单来说，是指从一个地址向另一个地址传输比特币。具体而言，交易是表示价值转移的签名数据结构。交易通过比特币网络进行传输，由矿工收集并包含在区块链中，永久保存在区块链中。 交易池（transaction pool） 一个无序的交易集合，它不在主链中的区块中，但是我们可以拿到输入交易。 图灵完备（Turing completeness） 如果程序语言能够运行图灵机可以运行的任何程序，并给予足够的时间和内存，那么它就称为“图灵完备”的。 未花费交易输出（unspent transaction output，UTXO） UTXO是一项未花费的交易输出，可以作为新交易的输入使用。 钱包（wallet） 拥有你的所有比特币的地址和密钥的软件，用它来发送，接收和存储你的比特币。 钱包导入格式（Wallet Import Format，WIF） WIF或电子钱包导入格式是一种数据交换格式，允许导出和导入带有标志的单个私钥，该标志表示它是否使用压缩的公钥。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 12:34:51 "},"03第一章.html":{"url":"03第一章.html","title":"概述","keywords":"","body":"概述 什么是比特币 比特币是组成数字货币生态的一系列概念和技术的集合。 比特币也用作在比特币网络的参与者之间存储和传递价值的货币单位。 比特币用户主要通过互联网使用比特币协议进行通信，当然，也可以使用其他传输网络。 比特币协议栈是开源的，易于使用，可运行在各种计算设备上，包括笔记本电脑和智能手机。 用户可以通过比特币完成传统货币可以完成的任何事情，包括购买和出售商品，向人们或组织汇款，或延长信贷。 用户可以在专门的交易所购买、出售比特币，与其他货币进行兑换。 某种意义上，比特币是互联网金钱的完美形式，因为它是快速，安全和无边界的。 与传统货币不同，比特币是完全虚拟的。它没有实体硬币甚至数字硬币。 比特币是隐含在发起者向接收者传递价值的交易中的。 通过拥有密钥，用户可以证明比特币的所有权，可以签署交易来解锁价值，并将其转移给新的所有者。 密钥通常存储在每个用户电脑或手机中的数字钱包里。 拥有密钥是消费比特币的唯一先决条件，比特币的控制权完全掌握在每个用户的手中。 比特币是一个点对点的分布式系统，系统中不存在中央服务器或控制点。 比特币是通过一个叫做挖矿的过程创造的，矿工在处理比特币交易时通过大量计算竞猜一个数学题的答案。 比特币网络的任何参与者（使用一个设备运营比特币完整协议栈的用户）都可以成为矿工，利用他们电脑的处理能力来验证和记录交易。 平均每隔10分钟，会有一个矿工计算出数学题的答案，可以验证过去10分钟的交易，并且获得新发行的比特币奖励。 实质上，比特币将中央银行的货币发行和清算功能进行了去中心化，不再需要任何中央银行了。 比特币协议包含了内置的用于调节网络中挖矿方法的算法。 挖矿过程的难度是动态调整的，所以，无论网络中有多少矿工，平均每10分钟都会有一个人成功。 比特币的总量限制在2100万个，每隔4年，比特币的发行速率都会减半，到2140年，所有比特币发行完毕。 由于比特币的发行速度递减，长期来看，比特币是货币通缩的。 比特币是协议的名称，是一个点对点网络，也是分布式计算的创新。 比特币货币本身只是这项创新的第一个应用。 比特币代表了数十年密码学和分布式系统研究的一个高峰，以独特而强大的方式将四项关键创新融合在一起： 去中心化的点对点网络（比特币协议） 公开的账本（区块链） 一套独立交易验证和货币发行的规则（共识协议） 在有效的区块链上达成全球分散共识的机制（PoW工作证明机制） 作为一名开发人员，我认为比特币就像货币互联网一样，是一个通过分布式计算传播价值和保护数字资产所有权的网络。比特币包含的内容比第一眼见到的还要多。 本章，我们将从解释一些主要概念和名词开始，安装必要的软件，并使用比特币进行简单的交易。 在后面的章节，我们将展开底层技术，研究比特币网络和协议的内部机制。 比特币之前的数字货币 可行数字货币的出现与加密技术的发展密切相关。 使用数据位代表交换物品和服务的价值的想法并不奇怪，但想让人接受数字货币，要面对3个基本问题： 可以相信这笔钱是真实的，而不是伪造的吗？ 可以确定数字货币只能使用一次吗？（俗称“双重支付”，“双花”问题） 可以确保除了我以外，没有人可以声称我的一笔钱属于他们吗？ 纸币发行者使用日益复杂的纸张和印刷技术来对抗伪造问题。物理货币可以轻易解决双重支付问题，因为同一张纸币不可能在两个地方出现。当然，传统货币也经常以数字方式存储和传输。 在这种情况下，伪造和双重支付问题的方法是通过中央当局来清算所有电子交易，他们对流通中的货币具有全局视野。 对于不能利用深奥的墨水或全息条带技术的数字货币，密码学为其提供了可信的所有权的基础。具体而言，加密数字签名使用户能够签署证明该资产所有权的数字资产或交易。 采用适当的架构，数字签名也可以解决双重支付问题。 随着密码学在20世纪80年代后期开始广泛应用，许多研究人员开始尝试使用密码学构建数字货币。这些早期发行的数字货币，通常由国家法币或稀有金属（黄金）做背书。 尽管这些早期数字货币可以运行，但它们是中心化的，结果是，很容易受到政府或黑客的攻击。它们使用中央票据交换所来定期处理所有交易，就像传统的银行系统一样。 不幸的是，多数情况下，这些早期数字货币成为了过度担心的政府的目标，不复存在。为了防止被干预（无论政府还是犯罪分子），需要可以避免单点攻击的去中心化数字货币。 比特币就是这样一个系统，去中心化设计，不需要可能崩溃或者被攻击的任何中心机构。 比特币的历史 比特币是在2008年随着一篇署名中本聪的论文 \"Bitcoin: A Peer-to-Peer Electronic Cash System,\"[1] 的发表诞生的 (see [satoshi_whitepaper]). 中本聪结合了b-money和HashCash等之前几个发明，创造了一个完全去中心化的的电子现金系统，它不依赖于中央机构进行货币发行、交易结算和确认。 关键性的创新是使用分布式计算系统（ Proof-of-Work（工作证明）算法）每10分钟进行一次全局“选举”，从而使去中心化网络就交易状态达成共识。 这个方法优雅地解决了双重支付（一笔现金可以支付两次）问题。在之前，双重支付问题是数字货币的弱点，通常通过中央机构清算所有交易解决。 比特币网络于2009年上线，基于中本聪发布的一个参考实现并由许多其他程序员修订。 为比特币提供安全性和可靠性的Proof-of-Work算法（挖矿算法）的算力呈指数型增长，现在已经超过了世界上顶尖的超级计算机的算力。 比特币的市值曾超过1350亿美元。目前最大的一笔交易是4亿美元，即时到账，手续费1美元。 中本聪于2011年4月淡出了公众视野，将维护比特币代码和网络的任务交给了一组志愿者。这个比特币背后的人或组织的身份仍然是未知的。 然而，中本聪和其他人都没有对比特币系统进行控制，该系统基于完全透明的数学原理，开源代码以及参与者之间的共识。 这项发明本身就具有开创性，已经在分布式计算，经济学和计量经济学领域产生了新的科学。 分布式计算问题的解决方案 中本聪的发明也是一个分布式计算问题的实践和创新：“拜占庭将军问题”。简单来说，这个问题涉及试图在不可靠且可能受损的网络上交换信息来达成行动方案或系统状态的统一。 中本聪的Proof-of-Work的方案，不需要中心化的可信机构，即可达成共识，代表了分布式计算领域的突破，有着超越数字货币的广泛适用性。 它可以用于在去中心化网络中达成共识，证明选举，抽奖，资产登记，数字公证等的公平性。 比特币的用法，用户和故事 比特币是古老的金钱技术的创新。金钱的核心是简单地促进人们之间交换价值。 所以，为了全面理解比特币和它的用法，我们将从人们使用它的视角进行研究。 下面列出的每个故事，都涉及了一种或多种用法： 北美的低价零售 Alice住在北美加利福尼亚湾区。她从技术人员朋友那里听说了比特币之后想尝试一下。我们将跟随她的故事，了解比特币，获取比特币，花费一些买一杯咖啡。 这个故事将从零售消费者的角度介绍软件，交易所，和基本交易。 北美高价零售 Carol是旧金山的艺术画廊老板。她使用比特币出售昂贵的作品。这个故事将向高价值商品的零售商介绍“51％”共识攻击的风险。 离岸合同服务 帕洛阿尔托的咖啡馆老板Bob正在建设一个新网站。他与居住在印度班加罗尔的一位网络开发人员Gopesh签约。 Gopesh已同意接受比特币支付。这个故事将研究比特币在外包，合同服务和国际电汇方面的用途。 网络商店 Gabriel是里约热内卢的一名进取的年轻少年，他经营一家小型网上商店，销售比特币品牌的T恤，咖啡杯和贴纸。加百列太年轻了，没有银行账户，但他的父母鼓励他的企业家精神。 慈善捐款 Eugenia是菲律宾儿童慈善组织的负责人。最近，她发现了比特币，并希望利用它来接触一群全新的外国和国内捐助者，为她的慈善事业筹款。 她还在研究如何使用比特币将资金快速分配到需要的地方。这个故事将展示比特币在跨越货币和边界的全球筹款活动中的应用，以及透明的公开账本在慈善组织中的使用。 进出口 穆罕默德是迪拜的一家电子产品进口商。他试图用比特币从美国和中国购买电子产品进口到阿联酋，以加快进口支付流程。 这个故事将展示如何将比特币用于与实体商品相关的大型企业对企业国际支付。 比特币挖矿 Jing是上海的计算机工程专业的学生。他已经建立了一个矿机，利用他的工程技能来挖掘比特币，以获取额外收入。 这个故事将研究比特币的“工业”基础：用于保护比特币网络和发行新货币的专用设备。 每一个故事都基于真实的人和真正的行业，目前正在使用比特币来创建新的市场，新的行业以及针对全球经济问题的创新解决方案。 开始 比特币是一种协议，可以通过使用遵守协议的客户端访问。“比特币钱包”是比特币系统最常用的用户界面，就像网络浏览器是HTTP协议最常用的用户界面一样。 比特币钱包有很多实现和品牌，就像许多品牌的网络浏览器（例如，Chrome，Safari，Firefox和Internet Explorer）一样。 就像我们都有我们最喜欢的浏览器（Mozilla Firefox）和最讨厌的浏览器（Internet Explorer）一样，比特币钱包在质量，性能，安全性，隐私和可靠性方面各不相同。 比特币协议还有一个源自中本聪编写的包含钱包的参考实现，名为“Satoshi Client”或“Bitcoin Core”。 选择比特币钱包 比特币钱包是比特币生态系统中最积极开发的应用之一。竞争很激烈，可能现在有人正在开发一个新的钱包，但去年的一些钱包已不再被维护。 许多钱包专注于特定平台或特定用途，有些更适合初学者，而其他则提供更多高级功能。 如何选择钱包依赖于用途和用户体验，所以无法推荐一个特定的品牌或钱包。 但是，我们可以根据它们的平台和功能进行分类，并对这些不同的钱包进行介绍。 有一点好处是，在比特币钱包之间移动钥匙或种子相对容易，所以可以多尝试几个钱包直到找到符合你需求的。 比特币钱包根据平台分类如下： 桌面钱包 桌面钱包是作为参考实现创建的第一种比特币钱包，许多用户因为它们提供的功能、自治和控制而使用桌面钱包。运行在Windows或MacOS操作系统上有安全缺陷，因为这些系统通常是不安全和配置不善的。 移动钱包 移动钱包是最常用的。这类钱包运行在iOS或Android操作系统上，是新用户的不错选择。多数设计简单易用，但也有提供给高级用户使用的功能全面的移动钱包。 网络钱包 网络钱包是通过浏览器访问的，并且将用户的钱包存储在第三方的服务器上。一些这样的服务通过在用户的浏览器中使用客户端代码进行操作，该代码将比特币密钥控制在用户手中。然而，多数情况下，第三方会控制用户的比特币密钥以便用户方便使用。将大量比特币存储在第三方系统上市不可取的。 硬件钱包 硬件钱包是在专用硬件上运行安全的自包含比特币钱包的设备。它们通过USB链接桌面Web浏览器，或通过移动设备上的近场通信（NFC）功能进行操作。在专用硬件上处理所有与比特币相关的操作被认为非常安全，适合存储大量的比特币。 纸钱包 控制比特币的密钥也可以打印到纸上，也可以使用其他材料（木材，金属等），这些被称为纸钱包。纸钱包提供了一种低技术含量但高度安全的长期存储比特币的手段。脱机存储通常也被称为冷存储。 另一种给比特币钱包分类的方法是根据他们的自治程度以及与如何比特币网络交互： 完整节点客户端 (Full-node client) 一个完整的客户端或“完整节点”存储比特币交易历史（每个用户的每次交易），管理用户的钱包，并且可以直接在比特币网络上启动交易。完整节点处理协议的所有方面，并可独立验证整个区块链和任何事务。完整节点需要消耗大量计算机资源（例如，超过125 GB的磁盘，2GB的RAM），但可提供完整的自主权和独立的事务验证。 轻量级客户端 轻量级客户端也称为简单支付验证（SPV，Simple-payment-verification）客户端，连接到比特币完整节点以访问比特币交易信息，但将用户钱包本地存储并独立创建，验证和传输交易。轻量级客户端与比特币网络直接交互，无需中间人。 第三方API客户端 第三方API客户端是通过第三方系统的API与比特币交互的客户端，而不是直接连接到比特币网络。钱包可以由用户或第三方服务器存储，但所有交易都通过第三方。 结合这些分类，许多比特币钱包会被分入多个组内，其中最常见的三种是桌面完整客户端，移动轻量级钱包和第三方网络钱包。不同类别之间的界限通常很模糊，因为许多钱包在多个平台上运行，并且可能以不同的方式与网络进行交互。 为了本书的目的，我们将演示使用各种可下载的比特币客户端，从参考实现（比特币核心）到移动钱包和网络钱包。一些例子将需要使用比特币核心，除了作为一个完整的客户端之外，它还将API暴露给钱包，网络和交易服务。如果你计划探索比特币系统的编程接口，则需要运行比特币核心或其他客户端之一。 快速开始 我们之前介绍的Alice不是技术人员，而且最近才从朋友Joe那听说比特币。 在一次派对上，Joe又一次热情地向周围的人讲解和演示比特币。出于好奇，Alice想知道她如何开始使用比特币。Joe说移动钱包最适合新用户，并推荐了一些他最喜爱的钱包。Alice便将“Mycelium”安装到了她的Android手机上。 当爱丽丝第一次运行Mycelium时，程序会自动为她创建一个新钱包。Alice看到的钱包界面，如The Mycelium Mobile Wallet所示（注意：不要将比特币发送到此示例地址，它将永远丢失）。 Figure 1. The Mycelium Mobile Wallet 界面上最重要的部分是Alice的比特币地址（bitcoin adreess），是数字和字母的组合: 1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK. 比特币地址旁边是存有相同信息的二维码，条形码，可以通过手机扫描。Alice可以通过点击二维码或Receive按钮保存比特币地址，或将二维码保存到手机中。在大多数钱包中，二维码可以点击放大，更方便扫描。 > Tip: 比特币地址以\"1\"或者\"3\"开头。就像email地址一样，它们可以分享给其他比特币用户以允许它们向你的钱包发送比特币。从安全角度来说，比特币地址不存在任何敏感信息，他可以被发送到任何地方。与email地址不同，你可以经常创建新的比特币地址，所有的地址都关联到你的钱包。许多现代钱包会自动为每笔交易创建一个新地址，以最大限度地保护隐私。钱包只是地址和解锁资金的密钥集合。 Alice现在已经准备好接收资金了。她的钱包应用会随机生成一个私钥（在[private_keys]中更详细地描述）以及相应的比特币地址。这时，她的比特币地址不为比特币网络所知，或者在比特币系统的任何部分“注册”。她的比特币地址只是一个数字，对应于一个可以用来控制资金访问权限的密钥。它是由她的钱包独立生成的，没有参考或注册任何服务。事实上，在大多数钱包中，比特币地址与包括用户身份在内的任何外部可识别信息之间不存在关联。在比特币地址被比特币账本上发布的交易引用，作为接收地址之前，它仅仅是比特币中有效的大量可能的地址的一部分。只有与交易关联后，它才会成为网络中已知地址的一部分。 Alice现在准备开始使用她的新比特币钱包了。 获得你的第一个比特币 新用户的第一个也是最困难的任务是购买一些比特币。与其他外币不同，你还不能在银行或外汇交易市场购买比特币。 比特币交易是不可逆转的。大多数电子支付网络如信用卡，借记卡，PayPal和银行账户转账都是可逆的。对于销售比特币的人来说，这种差异带来了非常高的风险，即买家在收到比特币后会逆转电子支付，实际上欺骗了卖家。为了缓解这种风险，接受传统电子支付以换取比特币的公司通常要求买家进行身份验证和信用评估检查，这可能需要几天或几周的时间。作为新用户，这意味着你无法使用信用卡立即购买比特币。然而，用一点耐心和创造性思维，你就不需要这样。 以下是新用户获取比特币的一些方法: 找一个有比特币的朋友，直接向他买一些。许多比特币用户以这种方式开始。这种方法最简单。与拥有比特币的人见面的一种方式是参加在 Meetup.com列出的本地比特币聚会。 使用分类服务，例如 localbitcoins.com 找到你所在地区的卖家以现金购买比特币。 通过销售产品或服务赚取比特币。如果你是程序员，就卖你的编程技能。如果你是理发师，就剪头发收比特币。 使用比特币ATM。比特币ATM是一种接受现金并将比特币发送到智能手机比特币钱包的机器。使用 Coin ATM Radar 的在线地图查找附近的比特币ATM。 使用比特币交易所。许多国家现在有交易所，为买卖双方提供以当地货币交换比特币的市场。 Exchange-rate服务（例如 BitcoinAverage）可以显示每种货币的比特币交易所列表。 > Tip: 比特币优于其他支付系统的一个优点是，如果使用得当，它可以为用户提供更多的隐私。获取，持有和支出比特币并不要求你向第三方泄露敏感和个人身份信息。但是，比特币涉及诸如货币兑换等传统系统时，国家和国际法规通常适用。为了以你的国家货币兑换比特币，你通常需要提供身份证明和银行信息。用户应该知道，一旦比特币地址附加到身份，所有相关的比特币交易也很容易识别和跟踪。这是许多用户选择维护与他们的钱包不相关的专用交换账户的原因之一。 Alice是被通过朋友介绍知道比特币的，因此她可以轻松获得她的第一个比特币。接下来，我们将看看她如何从她的朋友Joe那购买比特币，以及Joe如何将比特币发送到她的钱包。 查看比特币的当前价格 在Alice可以从Joe那购买比特币之前，他们必须同意比特币和美元之间的汇率。这给那些比特币新手带来了一个共同的问题：“谁设定的比特币价格？” 简而言之，价格是由市场决定的。 像大多数其他货币一样，比特币具有浮动汇率，这意味着比特币相对于任何其他货币的价值根据其交易市场的供求情况而变化。例如，比特币的美元价格是根据最近比特币和美元的交易计算出来的。因此，价格每秒钟会出现几次波动。定价服务将汇总来自多个市场的价格并计算代表货币对的广泛市场汇率（例如BTC / USD）的成交量加权平均值。 有数百个应用程序和网站可以提供当前的市场价格。这里是一些最流行的: Bitcoin Average 一个提供每种货币的成交量加权平均值简单视图的网站。 CoinCap 这项服务列出了数百种加密货币（包括比特币）的市值和汇率 Chicago Mercantile Exchange Bitcoin Reference Rate 可用于机构和合同参考的参考利率，作为CME的一部分投资数据源。 除了这些网站和应用程序之外，大多数比特币钱包会自动将比特币和其他货币进行转换。在将比特币发送给Alice之前，Joe会使用他的钱包自动转换价格。 发送和接收比特币 爱丽丝决定兑换10美元的比特币，以免在这项新技术上冒太多风险。她给了Joe 10美元现金，打开她的Mycelium钱包应用程序，并选择Receive。这显示了Alice的第一个比特币地址的QR码。 Joe在他的智能手机钱包上选择“Send”，然后看到包含两个输入的界面： 目标比特币地址 要发送的数量，以BTC或者他的本地货币（USD）为单位。 在比特币地址的输入字段中，有一个看起来像二维码的小图标。这使得Joe可以用他的手机摄像头扫描条码，这样他就不必输入Alice的比特币地址，这个地址很长很难敲。Joe点击二维码图标激活智能手机摄像头，扫描Alice手机上显示的二维码。 Joe现在已经将Alice的比特币地址设置为收件人了。Joe输入金额为10美元，他的钱包通过访问在线服务的最新汇率来转换它。当时的汇率是每比特币100美元，所以10美元价值0.10比特币（BTC）或100毫比特币（mBTC），如Joe的钱包截图所示 (see Airbitz mobile bitcoin wallet send screen). Figure 2. Airbitz mobile bitcoin wallet send screen 然后Joe仔细检查以确保他输入了正确的金额，因为他即将转账，错误不可逆转。在仔细检查地址和金额后，他按下Send来传输交易。Joe的比特币钱包构建了一笔交易，将0.10BTC发送到Alice的地址，从Joe的钱包中获取资金并使用Joe的私钥签署交易。这告诉比特币网络，乔已经授权将价值转移给Alice的新地址。由于交易是通过点对点协议传输的，因此它可以快速传播到比特币网络。在不到一秒的时间内，网络中大多数连接良好的节点都会收到交易并首次查看Alice的地址。 与此同时，Alice的钱包不断“监听”比特币网络上的已发布交易，寻找与她的钱包中的地址相匹配的任何交易。在Joe的钱包传输交易后几秒钟，Alice的钱包就会显示它正在接收0.10BTC。 确认 起初，Alice的地址将显示Joe的交易为“未确认”。这意味着交易已经传播到网络，但尚未记录在比特币交易账本（即区块链）中。要确认，交易必须包含在一个区块中，并添加到区块链中，平均每10分钟发生一次。在传统的财务术语中，这被称为清算。有关比特币交易的传播，验证和清算（确认）的更多详细信息，请参阅“采矿”。 Alice现在是那0.10BTC的所有者了。在下一章中，我们将看到她第一次使用比特币购买东西，并更详细地研究背后的交易和传播技术。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 12:43:39 "},"04第二章.html":{"url":"04第二章.html","title":"比特币如何运转","keywords":"","body":"比特币如何运转 交易，区块，挖矿和区块链 与传统的银行和支付系统不同，比特币系统基于去中心化的信任。在比特币中，信任是比特币系统中不同参与者的交互的涌现特性达成的。 在本章中，我们将站在比较高的视角研究比特币，通过在比特币系统中跟踪一笔交易，看到它被比特币分布式共识机制所信任和接受，并最终记录在区块链中（所有交易的分布式账本）。后续章节将深入探讨交易，网络和挖矿背后的技术。 比特币概览 在Bitcoin overview的概览图中, 我们看到比特币系统由包含密钥的钱包，通过网络传播的交易，以及产生（通过竞争性计算）共识区块链的矿工组成，区块链是所有交易的权威帐本。 本章中的每个示例均基于在比特币网络上进行的实际交易，通过从一个钱包向另一个钱包发送资金来模拟用户（Joe，Alice，Bob和Gopesh）之间的交互。在通过比特币网络跟踪交易到区块链的同时，我们将使用blockchain explorer网站可视化每个步骤。区块链浏览器（blockchain explorer）是一个作为比特币搜索引擎运行的Web应用，它允许你搜索地址，交易和区块，并查看它们之间的关系和流程。 Figure 1. Bitcoin overview 流行的区块链浏览器包括： BlockCypher Explorer blockchain.info BitPay Insight 其中每一个都有搜索功能，可以采用比特币地址，交易哈希值，区块号或区块哈希值，从比特币网络中检索相应的信息。对于每个交易或区块示例，我们将提供一个URL，以便你可以自己查看并详细研究它。 购买一杯咖啡 上一章介绍的Alice是刚刚获得了第一个比特币的新用户。在[getting_first_bitcoin]中，Alice会见了她的朋友Joe，用现金交换了一些比特币。Joe创造的交易把0.10BTC发送到了Alice的钱包。现在，Alice将进行她的第一笔零售交易，在加利福尼亚州帕洛阿尔托的Bob咖啡店购买一杯咖啡。 Bob咖啡最近开始接受比特币支付，在其销售系统中增加了一个比特币选项。Bob咖啡的价格以当地货币（美元）列出，但在支付时，顾客可以选择美元或比特币。Alice下了一杯咖啡的订单，Bob将它输入到系统中，就像处理所有交易一样。销售系统自动将总价从美元转换为比特币，并以当前市场汇率以两种货币进行显示： Total: $1.50 USD 0.015 BTC Bob说，\"1.5美元, 或者15毫比特币\" Bob的销售系统也会自动创建一个包含支付请求（payment request)的特殊二维码（参见Payment request QR code）。 与仅包含目标比特币地址的二维码不同，支付请求是URL的二维码，其包含目标地址，付款金额以及诸如“Bob’s Cafe”的描述。这允许比特币钱包应用预先填充用于发送付款的信息，同时向用户显示可读的信息。你可以使用比特币钱包应用扫描二维码，以查看Alice会看到的内容。 Figure 2. Payment request QR code > 尝试用钱包扫描以查看地址和金额，但不要发送金钱。 支付请求对BIP-21中定义的如下的URL进行编码: bitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA? amount=0.015& label=Bob%27s%20Cafe& message=Purchase%20at%20Bob%27s%20Cafe URL的组成部分 接收比特币的地址: \"1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA\" 支付金额: \"0.015\" 收件人地址的标签: \"Bob's Cafe\" 支付详情: \"Purchase at Bob's Cafe\" Alice用她的手机扫描屏幕上的二维码。她的手机显示支付 0.0150 BTC 至 Bob's Cafe，她选择“发送”以授权付款。在几秒钟内（大约与信用卡授权相同的时间），Bob在他的系统中看到交易，交易就完成了。 > 比特币网络可以以小数值进行交易，例如从millibitcoin（比特币的1/1000）到聪（比特币的1 / 100,000,000）。在本书中，我们将使用术语“比特币”来表示从最小单位（1 satoshi）到将要开采的所有比特币总数（21,000,000）的任何数量的比特币。 你可以使用区块链浏览器网站（查看Alice的交易 blockchain.info）在区块链中检查Alice对Bob’s Cafe的交易： Example 1. 查看Alice的交易 blockchain.info https://blockchain.info/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2 比特币交易 简而言之，一笔交易告诉网络，一些比特币价值的所有者已经授权将该价值转移给另一个所有者。新的所有者现在可以通过创建另一个授权转让给另一个所有者的交易来支付比特币，等等。 交易的输入和输出 交易就像复式簿记账中的行一样。每笔交易包含一个或多个“输入”，就像比特币账户的\"借方\"，在交易的另一端，有一个或多个“输出”，就像比特币账户中的\"贷方\"一样。 输入和输出（借方和贷方）加起来不一定数额相同。相反，输出加起来略少于输入，差额代表隐含的交易费用，这是由矿工收取的一笔小额付款，该矿工将交易加入到账本中。比特币交易在Transaction as double-entry bookkeeping中显示为账本中的记录条目。 该交易还包含每个正在被花费的比特币（输入）的所有权证明，以所有者的数字签名的形式出现，任何人都可以独立验证。用比特币的术语来说，“花费”正在签署一项交易，它将来自前一笔交易的价值转移给由比特币地址标识的新的所有者。 Figure 3. Transaction as double-entry bookkeeping 交易链 Alice向Bob’s Cafe的付款使用先前交易的输出作为其输入。在上一章中，Alice从她的朋友Joe那里用现金换取了比特币。该交易创建了一个由Alice的密钥锁定的比特币值。她向Bob’s Cafe的新交易引用之前的交易作为输入，并创造新的输出来支付咖啡钱并接收找零。交易形成一个链，最近一次交易的输入与之前交易的输出相对应。Alice的密钥提供了解锁先前那些交易输出的签名，从而向比特币网络证明她拥有资金。她将咖啡的钱支付给Bob的地址，从而“留置”输出，要求Bob必须签名才能花费这笔金额。这代表了Alice和Bob之间的价值转移。这个从Joe到Alice到Bob的交易链在A chain of transactions, where the output of one transaction is the input of the next transaction中进行了说明。 Figure 4. A chain of transactions, where the output of one transaction is the input of the next transaction 找零 许多比特币交易的输出既引用新所有者的地址，又引用当前所有者的地址（这称为找零地址）。这是因为交易输入（像钞票一样）不能分开。如果你在商店购买价值5美元的物品，但使用20美元的美元账单来支付该物品，你将获得15美元的找零。相同的概念适用于比特币交易的输入。如果你购买的产品需要5比特币，但只有20比特币的输入能使用，你可以将一个5比特币的输出发送给店主，并将一个15比特币输出作为找零（减去涉及的交易费用）。重要的是，找零地址不必与输入地址相同，并且出于隐私方面考虑，通常是来自所有者钱包的新地址。 在汇集输入以执行用户的支付请求时，不同的钱包可以使用不同的策略。他们可能会汇集很多小的输入，或者使用等于或大于期望付款的输入。除非钱包能够按照付款和交易费用的总额精确汇集输入，否则钱包将需要产生一些零钱。这与人们处理现金非常相似。如果你总是使用口袋里最大的钞票，那么最终你会得到一个充满零钱的口袋。如果你只使用零钱，你将永远只有大额账单。人们潜意识地在这两个极端之间寻找平衡点，比特币钱包开发者努力编程实现这种平衡。 总之，交易将交易的输入的值移至交易的输出。输入是对前一个事务输出的引用，表示值来自哪里。交易输出将特定值指向新所有者的比特币地址，并且可以将零钱输出给原始所有者。来自一个交易的输出可以用作新交易的输入，因此当价值从一个所有者转移到另一个所有者时会产生一个所有权链（参见 A chain of transactions, where the output of one transaction is the input of the next transaction）。 常见交易形式 最常见的交易形式是从一个地址到另一个地址的简单支付，通常包括一些“零钱”返回到原始所有者。这类交易有一个输入和两个输出，参见Most common transaction： Figure 5. Most common transaction 另一种常见形式是汇集多个输入到一个输出的交易 (参见 Transaction aggregating funds). 这类似于现实世界中将一堆硬币和纸币换成单一较大面值的纸币的情况。此类交易有时由钱包应用生成，以清理收到的大量小额零钱。 Figure 6. Transaction aggregating funds 最后，比特币账本中经常出现的另一种交易形式是将一个输入分配给代表多个收款人的多个输出的交易（参见 Transaction distributing funds）。这类交易有时被企业用来分配资金，例如在向多个雇员支付工资时。 Figure 7. Transaction distributing funds 创建一笔交易 Alice的钱包应用包含了选择合适的输入和输出的所有逻辑，根据Alice的具体设定创建交易。Alice只需要指定目的地和金额，剩下的事情交给钱包应用，Alice不用关心细节。重要的是，即使钱包应用完全脱机，钱包应用也可以创建交易。就像在家里写一张支票，然后通过信封发送给银行一样，交易不要求在连接到比特币网络时进行创建和签署。 获得正确的输入 Alice的钱包应用首先必须找到可以支付她想要发送给Bob的金额的输入。大多数钱包跟踪属于钱包中地址的所有可用输出。因此，Alice的钱包将包含Joe的交易输出的副本，该交易是由现金交换创建的（参见[getting_first_bitcoin]）。作为完整节点客户端运行的比特币钱包应用实际上包含区块链中每笔交易的未使用输出的副本。这允许钱包创建交易输入，以及快速验证传入的交易具有正确的输入。但是，由于全节点客户端占用大量磁盘空间，所以大多数用户钱包运行“轻量级”客户端，仅跟踪用户自己未使用的输出。 如果钱包应用未保存未花费的交易的输出的副本，它可以使用不同提供商提供的各种API，查询比特币网络，询问完整节点来检索该信息。 Look up all the unspent outputs for Alice’s bitcoin address展示了一个API请求，向特定的URL发起HTTP GET请求。该URL将返回这个地址上所有未使用的交易的输出，为应用提供构建交易输入的信息。我们使用简单的命令行HTTP客户端cURL来请求。 Example 2. Look up all the unspent outputs for Alice’s bitcoin address $ curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK { \"unspent_outputs\":[ { \"tx_hash\":\"186f9f998a5...2836dd734d2804fe65fa35779\", \"tx_index\":104810202, \"tx_output_n\": 0, \"script\":\"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac\", \"value\": 10000000, \"value_hex\": \"00989680\", \"confirmations\":0 } ] } Look up all the unspent outputs for Alice’s bitcoin address中的响应展示了在Alice的地址 1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK 下有一笔未花费的输出。响应内容包括包含这笔输出的交易的引用，以及它的价值，1000万（单位是聪），相当于0.10比特币，利用这些信息，Alice的钱包应用可以构建一个交易，将该值转移到新的所有者地址。 > 查看 transaction from Joe to Alice. 如你所见，爱丽丝的钱包包含支付一杯咖啡的足够的比特币。否则，Alice的钱包应用可能需要\"翻遍\"一堆较小的未使用的输出，就像从钱包中找硬币一样，直到它能够找到足够的钱来支付咖啡。在这两种情况下，可能都需要进行一些找零，我们将在下一部分中看到，钱包应用创建交易输出（付款）。 创建输出 交易的输出是以脚本形式创建的，该脚本在比特币价值上创建了一个“留置”，只能通过提供脚本解决方案来进行提取。简而言之，Alice的交易输出将包含一个脚本，其内容如下：“这笔支出属于能使用Bob的公共地址对应的私钥进行签名的人。” 因为只有Bob拥有与该地址对应的私钥，所以只有Bob的钱包可以提供这样的签名来提取该输出。因此，Alice可以通过要求Bob的签名，来“限制”这笔输出的使用。 这笔交易还包括第二笔输出，因为爱丽丝的资金为0.10BTC，对于0.015BTC的咖啡来说太多了，需要找零0.085BTC。Alice的找零付款由Alice的钱包创建，作为Bob的付款的同一笔交易中的输出。爱丽丝的钱包将其资金分成两笔付款：一笔给Bob，一份给自己。然后，她可以在后续交易中使用（花费）这次找零的输出。 最后，为了让网络及时处理这笔交易，Alice的钱包应用将增加一笔小额费用。这在交易中并不明确；这是由输入和输出的差值隐形包含的。如果Alice不创建0.085的找零，而是0.0845，就会剩下0.0005BTC（半毫比特币）。输入的0.10BTC没有完全用于两个输出，因为它们的总和小于0.10。由此产生的差值就是矿工收取的交易费用，用于验证交易并将交易包括到区块链中。 生成的交易可以使用区块链浏览器查看，如Alice’s transaction to Bob’s Cafe所示. Figure 8. Alice’s transaction to Bob’s Cafe > 查看 transaction from Alice to Bob’s Cafe. 将交易加入账本 Alice的钱包应用创建的交易长度为258个字节，包含确认资金所有权和分配新的所有者所需的所有内容。现在，交易必须传输到比特币网络，并成为区块链的一部分。在下一节中，我们将看到交易如何成为新区块的一部分，以及区块如何被“挖掘”。最后，我们将看到当区块加入区块链后，会随着区块的增加越来越被网络信任。 传输交易 交易包含了处理所需的所有信息，因此传送到比特币网络的方式或位置无关紧要。比特币网络是一个点对点网络，每个比特币客户端通过连接到其他几个比特币客户端来参与。比特币网络的目的是向所有参与者传播交易和区块。 如何传播 任何遵守比特币协议，加入到比特币网络的系统，如服务器，桌面应用程序或钱包，都称为比特币节点（bitcoin node）。 Alice的钱包应用可以通过任何类型的连接（有线，WiFi，移动等）将相关交易发送到任何比特币节点。她的比特币钱包不必直接连接到Bob的比特币钱包，她不必使用咖啡馆提供的互联网连接，但这两种选择都是可能的。任何比特币节点接收到一个它没见过的有效交易之后，会立即转发到它连接到的所有其他节点，这被称为泛洪（flooding）传播技术。因此，事务在点对点网络中迅速传播，可在几秒钟内达到大部分节点。 Bob的视角 如果Bob的比特币钱包应用直接连接到Alice的钱包应用，则Bob的钱包应用可能是第一个接收到该交易的节点。即使Alice的钱包通过其他节点发送交易，它也会在几秒钟内到达Bob的钱包。Bob的钱包会立即将Alice的交易识别为收款，因为它包含可由Bob的私钥提取的输出。Bob的钱包应用还可以独立验证交易数据是格式正确的，使用的是之前未花费的输入，并且包含足够的交易费用以包含在下一个区块中。此时，鲍勃可以认为风险很小，即交易将很快包含在一个区块中并得到确认。 > 关于比特币交易的一个常见误解是，它们必须等待10分钟新区块的产生才能被“确认”，或者最多60分钟才能完成6个确认。虽然确认确保交易已被整个网络所接受，但对于诸如一杯咖啡等小值物品，这种延迟是不必要的。商家可以接受没有确认的有效小额交易。没有比没有身份或签名的信用卡支付风险更大的了，商家现在也经常接受。 比特币挖矿 Alice的交易现在已经传播到比特币网络上了。但在它被验证并经历一个名为挖矿（mining）的过程包含在区块中之前，不会成为区块链的一部分。有关详细说明，请参阅[mining]。 比特币的信任系统基于计算。交易被捆绑到区块中，这需要大量的计算来提供工作证明，但只需少量的计算进行验证。挖矿过程在比特币中有两个作用： 挖矿节点通过遵从比特币的共识规则来验证所有交易。因此，挖矿通过拒绝无效或格式错误的交易来为比特币交易提供安全保障。 每个区块被挖出时会创造新的比特币，就像中央银行印钱一样。按照固定的发行时间表，每个区块创建的比特币数量是有限的，随着时间的推移会逐渐减少。 挖矿在成本和回报之间达到了良好的平衡。挖矿用电解决数学问题。一位成功的矿工将通过新的比特币和交易费的形式获得一份奖励。只有矿工正确地验证了所有交易，并且符合共识的规则，才会获得奖励。这种微妙的平衡为没有中央管理机构的比特币提供了安全性。 描述挖矿的一种好的类比是数独游戏，这种大量竞争的游戏，每次有人找到解决方案时都会重置，其难度会自动调整，因此需要大约10分钟才能找到解决方案。想象一下，数以千计的行和列的巨大数独谜题。如果我告诉你一个完整的谜题，你可以很快验证它。但是，如果拼图有几个方格填充，其余的都是空的，则需要花费大量工作来解决！数独的难度可以通过改变它的大小（更多或更少的行和列）来调整，但即使它非常大，它仍然可以很容易地被验证。比特币中使用的“谜题”基于密码散列，具有相似的特征：它不对称，难以解决，但易于验证，并且可以调整难度。 在 [user-stories]中, 我们介绍了Jing，一个上海的企业家. Jing经营着一个矿池，包含数千台专业采矿计算机，争夺奖励。每10分钟左右，Jing的采矿计算机就会在全球竞赛中与成千上万的类似的系统竞争，寻找解决方案。 为了找到解决方案，所谓的_工作量证明（Proof-of-Work，PoW），比特币网络需要每秒进行数千万亿（quadrillions) 次哈希运算。工作量证明的算法涉及使用SHA256密码算法重复地对区块的头部数据和随机数进行散列，直到出现与预定模式匹配的结果为止。找到这种解决方案的第一位矿工赢得一轮竞争，并将该区块发布到区块链中。 Jing于2010年开始使用一台速度非常快的台式电脑进行挖矿，以找到适用于新块的工作量证明Proof-of Work。随着越来越多的矿工加入比特币网络，解题的难度迅速增加。很快，Jing和其他矿工升级到更专用的硬件，如高端显卡（GPU）。在撰写本书时，难度已经大到需要采用专用集成电路（ASIC），将数百种挖矿算法印刷到硬件上，在单个硅片上并行运行。Jing的公司也参与了一个矿池，这就像一个彩票池，允许参与者共享他们的算力和奖励。 Jing的公司现在运营着一个仓库，其中包含数千名ASIC矿工，每天24小时进行比特币挖矿。该公司通过出售开采出来的比特币来支付其电力成本，从利润中获取收入。 挖掘区块中的交易 新的交易不断从用户钱包和其他应用流入网络。当被比特币网络节点看到时，会被添加到由每个节点维护的未经验证的临时交易池中。随着矿工构建一个新的区块，他们将未验证的交易从该池中取出添加到新的区块，然后尝试用挖矿算法（Pow）来证明新区块的有效性。挖矿的详细过程请参见[mining]。 交易添加到新的区块后，根据交易费高低和其他一些条件按优先级排列。每个矿工通过网络收到前一个区块时，便知道它已经输掉了上一轮竞争，会开始挖掘新的区块。他立即创建一个新块，填入交易数据和前一个区块的指纹，并开始计算新区块的PoW。每个矿工在他的区块中都包含一笔特殊交易，一笔支付给它自己的比特币地址的奖励（目前为12.5个新比特币）加上该区块中包含的所有交易的交易费用总和。如果他发现一个可以使这个区块有效的解决方案，就会“获得”这些奖励，因为他成功挖掘的区块被添加到全局区块链中。他创建的这笔奖励交易也变得可花费。 加入采矿池的Jing建立了自己的软件来创建新的区块，将奖励分配到矿池的地址，一部分奖励将按照上一轮贡献的工作量比例分配给Jing和其他矿工。 Alice的交易首先被网络接收，并被包括在未经验证的交易中。一旦被挖矿软件验证，它就被包含在一个叫做候选区块的新块中（由Jing的矿池生成的）。参与该采矿池的所有矿工立即开始计算候选区块的PoW。在Alice的钱包传输交易后约五分钟，Jing的一位ASIC矿工找到了候选区块的解决方案并将其发布给网络。一旦其他矿工验证了这个获胜的区块，他们将开始竞争挖掘下一个块。 Jing挖到的区块作为#277316区块成为了区块链的一部分，包含419笔交易，其中包括Alice的交易。Alice的交易被包含到一个区块中，视为该交易的一个“确认”。 > 查看包含 Alice’s transaction 的区块。 大约19分钟后，另一个矿工开采出#277317区块。由于这个新块建立在包含Alice交易的#277316区块的顶部，因此它为区块链增加了更多计算量，从而加强了对这些交易的信任。在包含交易的块的顶部开采的每个块都为Alice交易增加确认数。随着区块堆叠在一起，修改历史交易变得极其困难，从而使其越来越受到网络的信任。 在图 Alice’s transaction included in block #277316 中, 我们可以看到包含Alice的交易的#277316区块。在它下面有277,316个区块（包括区块#0），在区块链（blockchain）中彼此链接，一直到区块#0，称为创世区块（genesis block）。随着时间的推移，随着块的“高度”增加，每个块和整个链的计算难度也会增加。在包含Alice的交易的块之后开采的块作为进一步的保证，因为它们在更长的链中堆积更多的计算。按照惯例，任何具有多于六个确认的块都被认为是不可撤销的，因为需要巨大的计算量来重新计算六个块。我们将在 [minig] 中更详细地探讨采矿过程及其建立信任的方式。 Figure 9. Alice’s transaction included in block #277316 花费比特币 既然爱丽丝的交易作为一个区块的一部分嵌入在区块链中，它就是比特币分布式账本的一部分，并且对于所有的比特币应用程序都是可见的。每个比特币客户端都可以独立验证该交易的有效性和可用性。完整节点客户可以从比特币首次在一个块中生成的那一刻开始追踪资金来源，从一笔交易到另一笔交易，直到到达Bob的地址。轻量级客户可以通过确认交易在区块链中，计算其后又开采了多少个区块，来做所谓的简单支付验证（参见[spv_nodes]），从而保证矿工接受它为有效的。 Bob现在可以花费这笔交易和其他交易的输出了。例如，Bob可以通过将价值从Alice的咖啡支付转移给新的所有者，支付费用给承包商或供应商。最有可能的是，Bob的比特币软件将许多小额付款合并为一笔更大的款项，例如将全天的比特币汇集到一笔交易中。有关汇集交易，请参阅Transaction aggregating funds。 当Bob花费从Alice和其他客户收到的款项时，他扩展了交易链。假设Bob向在班加罗尔的网页设计师Gopesh支付了一个新页面的设计费用。现在，交易链看起来像Alice’s transaction as part of a transaction chain from Joe to Gopesh。 Figure 10. Alice’s transaction as part of a transaction chain from Joe to Gopesh 在本章中，我们看到交易如何建立一个链条，将价值从一个所有者转移到另一个所有者。我们还追踪了Alice的交易，在她的钱包中创建，传输到比特币网络，矿工将其记录在区块链上。在本书的其余部分，我们将研究钱包，地址，签名，交易，网络以及挖矿背后的具体技术。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 13:49:42 "},"05第三章.html":{"url":"05第三章.html","title":"Bitcoin Core：参考实现","keywords":"","body":"Bitcoin Core：参考实现 比特币是开源的项目，源代码使用MIT授权方式，可以免费下载和使用。开源不仅意味着免费使用，也意味着比特币是由开源志愿者社区开发的。起初，这个社区只包括中本聪（Satoshi Nakamoto）。到2016年，比特币的源代码拥有超过400个贡献者，大约有十几位开发人员几乎全职工作，另外几十人兼职工作。任何人都可以贡献代码，包括你！ 当中本聪创造比特币时，该软件实际上已经在白皮书出现之前完成。在写这篇文章之前，中本聪想确保它可以工作。第一版实现已经进行了大量修改和改进，已经发展成为所谓的Bitcoin Core（Bitcoin Core），以区别于其他兼容的实现。Bitcoin Core是比特币系统的参考实现，这意味着它是关于如何实施每一部分技术的权威参考。Bitcoin Core实现了比特币的各个方面，包括钱包，交易和区块验证引擎，以及点对点比特币网络中的完整网络节点。 > 尽管Bitcoin Core包含钱包的参考实现，但并不建议将其用作用户或应用程序生产环境中的钱包。建议应用程序开发人员使用现代标准（如BIP-39和BIP-32）开发钱包（请参阅[mnemonic_code_words]和[hd_wallets]）。 BIP代表Bitcoin改进建议。 Bitcoin Core architecture (Source: Eric Lombrozo) 展示了Bitcoin Core的架构。 Figure 1. Bitcoin Core architecture (Source: Eric Lombrozo) 比特币开发环境 如果你是一名开发者，你需要建立一个开发环境，其中包含用于编写比特币应用程序的所有工具，库和支持软件。在这个高度技术性的章节中，我们将一步一步地介绍该过程。如果觉得过于复杂（并且你实际上没有设置开发环境），请随意跳到下一章，技术性较弱的章节。 通过源代码编译Bitcoin Core 可以从Github下载Bitcoin Core的源代码压缩包或克隆项目。例如，在 Bitcoin Core download page上, 选择最新版本的源码压缩包，bitcoin-0.15.0.2.tar.gz。 或者, 使用git clone命令在本地创建一个备份。 GitHub bitcoin page. > 在本章的许多示例中，我们将使用操作系统的命令行界面（也称为“shell”），通过“终端”应用程序访问它，shell将显示一个提示符；你输入一个命令；shell会为你的下一个命令返回一些文本和一个新的提示符。提示可能在你的系统上看起来不同，但在以下示例中，它由 $ 号表示。在示例中，当你在$ 符号后面看到文本时，请勿键入$ 符号，而是在其后面紧接着输入命令，然后按Enter执行该命令。在示例中，每条命令下面的行是操作系统对该命令的响应。当你看到下一个 $ 前缀时，你应该知道这是一个新的命令行，你可以重复这个过程。 在这个例子中，我们使用 git 命令创建源代码的本地副本。 $ git clone https://github.com/bitcoin/bitcoin.git Cloning into 'bitcoin'... remote: Counting objects: 102071, done. remote: Compressing objects: 100% (10/10), done. Receiving objects: 100% (102071/102071), 86.38 MiB | 730.00 KiB/s, done. remote: Total 102071 (delta 4), reused 5 (delta 1), pack-reused 102060 Resolving deltas: 100% (76168/76168), done. Checking connectivity... done. $ > Git是使用最广泛的分布式版本控制系统，它是软件开发人员工具箱的重要组成部分。如果你尚未安装，请在操作系统上安装 git 命令或git的图形用户界面。 当git克隆操作完成后，你将在bitcoin目录中拥有完整的源代码库本地副本。在提示符处输入 cd bitcoin 切换到此目录： $ cd bitcoin 选择Bitcoin Core的发行版 默认情况下，本地副本将同步最新的代码，这可能是比特币的不稳定版或beta版。编译代码之前，通过检查tag来选择特定版本。这将使本地副本与由关键字标记标识的代码存储库的特定快照同步。开发人员使用标签通过版本号标记代码的特定版本。首先，为了找到可用的标签，我们使用 git tag 命令： $ git tag v0.1.5 v0.1.6test1 v0.10.0 ... v0.11.2 v0.11.2rc1 v0.12.0rc1 v0.12.0rc2 ... 标签列表显示比特币的所有发行版本。按照惯例，用于测试的发行预览版（release candidates）具有后缀“rc”。可以在生产系统上运行的稳定版本没有后缀。从上面的列表中选择最高版本的发行版本，在撰写本文时是v0.15.0。要使本地代码与此版本同步，请使用 git checkout 命令： $ git checkout v0.15.0 HEAD is now at 3751912... Merge #11295: doc: Old fee_estimates.dat are discarded by 0.15.0 你可以通过命令 git status 来确认你已经“检出”了所需的版本： $ git status HEAD detached at v0.15.0 nothing to commit, working directory clean Bitcoin Core的构建配置 源代码包括文档，可以在许多文件中找到。输入 more README.md，查看bitcoin目录中的README.md主文档，可使用空格键进行翻页。在本章中，我们将构建命令行比特币客户端（command-line bitcoin client），在Linux上也称为 bitcoind。输入 more doc/build-unix.md 来查看在你的平台上编译 bitcoind 的说明。macOS和Windows的说明可以在doc目录中找到，分别为build-osx.md或build-windows.md。 仔细查看构建文档第一部分中的依赖库，如boost-devel, libevent-devel, openssl-devel, gcc-c++，libdb4-cxx-devel，autoconf, automake，libtool等。在你开始编译比特币之前，这些库必须存在于你的系统中，否则构建过程将失败。如果因为漏掉了某些依赖库而导致失败，可以安装它，然后从之前停止的地方恢复构建过程。你可以通过使用autogen.sh脚本生成一组构建脚本来启动构建过程。 $ ./autogen.sh ... glibtoolize: copying file 'build-aux/m4/libtool.m4' glibtoolize: copying file 'build-aux/m4/ltoptions.m4' glibtoolize: copying file 'build-aux/m4/ltsugar.m4' glibtoolize: copying file 'build-aux/m4/ltversion.m4' ... configure.ac:10: installing 'build-aux/compile' configure.ac:5: installing 'build-aux/config.guess' configure.ac:5: installing 'build-aux/config.sub' configure.ac:9: installing 'build-aux/install-sh' configure.ac:9: installing 'build-aux/missing' Makefile.am: installing 'build-aux/depcomp' ... autogen.sh脚本创建一组自动配置脚本，它们将询问你的系统以发现正确的设置，并确保你拥有编译代码所需的全部库。其中最重要的是 configure 脚本，它提供了许多不同的选项来定制构建过程。键入 ./configure --help 查看各种选项。 $ ./configure --help `configure' configures Bitcoin Core 0.15.0 to adapt to many kinds of systems. Usage: ./configure [OPTION]... [VAR=VALUE]... ... Optional Features: --disable-option-checking ignore unrecognized --enable/--with options --disable-FEATURE do not include FEATURE (same as --enable-FEATURE=no) --enable-FEATURE[=ARG] include FEATURE [ARG=yes] --enable-wallet enable wallet (default is yes) --with-gui[=no|qt4|qt5|auto] ... configure 脚本允许你通过使用 -enable-FEATURE 和 -disable-FEATURE 标志启用或禁用 bitcoind 的某些功能，其中 FEATURE 被替换为帮助输出中列出的特征名称。在本章中，我们将构建带有所有默认功能的 bitcoind 客户端。我们不会使用配置标志，但你应该查看它们以了解哪些可选功能是客户端的一部分。如果你处于学术环境中，实验室可能会要求你将应用程序安装到你的主目录中（例如，使用+-prefix=$HOME+）。 以下是覆盖配置脚本默认行为的一些有用选项： --prefix=$HOME 覆盖生成的可执行文件的默认安装位置 (/usr/local/)。使用$HOME以将所有内容放在你的主目录，也可以使用其他路径。 --disable-wallet 禁用钱包的参考实现。 --with-incompatible-bdb 如果你正在构建钱包，可以允许使用不兼容Berkeley DB库的版本。 --with-gui=no 不构建需要Qt库的图形用户界面。这只会构建服务器和命令行。 接下来，运行 configure 脚本，它会自动发现所有必要的库，并为你的系统创建一个特定的构建脚本： $ ./configure checking build system type... x86_64-unknown-linux-gnu checking host system type... x86_64-unknown-linux-gnu checking for a BSD-compatible install... /usr/bin/install -c checking whether build environment is sane... yes checking for a thread-safe mkdir -p... /bin/mkdir -p checking for gawk... gawk checking whether make sets $(MAKE)... yes ... [many pages of configuration tests follow] ... $ 如果一切顺利，configure 命令将创建允许我们编译 bitcoind 的定制构建脚本并结束。如果有任何缺失的库或错误，configure 命令将终止并显示错误。如果发生错误，很可能是因为缺少或不兼容的库。再次查看构建文档，并确保安装缺少的先决条件。然后再次运行 configure 并查看是否修复了错误。 构建Bitcoin Core可执行文件 接下来，你将编译源代码，这个过程可能需要一个小时才能完成，具体取决于CPU的速度和可用内存。在编译过程中，你应该每隔几秒或几分钟看一次输出。如果发生错误，或者编译过程中断，可以通过再次输入 make 恢复。键入 make 开始编译可执行应用程序： $ make Making all in src CXX crypto/libbitcoinconsensus_la-hmac_sha512.lo CXX crypto/libbitcoinconsensus_la-ripemd160.lo CXX crypto/libbitcoinconsensus_la-sha1.lo CXX crypto/libbitcoinconsensus_la-sha256.lo CXX crypto/libbitcoinconsensus_la-sha512.lo CXX libbitcoinconsensus_la-hash.lo CXX primitives/libbitcoinconsensus_la-transaction.lo CXX libbitcoinconsensus_la-pubkey.lo CXX script/libbitcoinconsensus_la-bitcoinconsensus.lo CXX script/libbitcoinconsensus_la-interpreter.lo [... many more compilation messages follow ...] $ 在具有多个CPU的系统上，你可以设置并行编译作业的核数。例如，make -j 2 将使用两个CPU核。如果一切顺利，Bitcoin Core已经编译完成，你应该使用 make check 运行单元测试套件，以确保链接库不会中断。最后一步是使用 make install 命令在你的系统上安装可执行文件。系统可能会提示你输入用户密码，因为此步骤需要管理权限： $ make check && sudo make install Password: Making install in src ../build-aux/install-sh -c -d '/usr/local/lib' libtool: install: /usr/bin/install -c bitcoind /usr/local/bin/bitcoind libtool: install: /usr/bin/install -c bitcoin-cli /usr/local/bin/bitcoin-cli libtool: install: /usr/bin/install -c bitcoin-tx /usr/local/bin/bitcoin-tx ... $ +bitcoind+默认安装在 /usr/local/bin 中，你可以查看: $ which bitcoind /usr/local/bin/bitcoind $ which bitcoin-cli /usr/local/bin/bitcoin-cli 运行Bitcoin Core节点 比特币的点对点网络由网络“节点”组成，主要由志愿者和一些构建比特币应用的企业运行。那些运行比特币节点的人对比特币区块链拥有直接和权威的视野，并拥有所有交易的本地副本，由他们自己的系统进行独立验证。通过运行节点，你可以不依靠任何第三方来验证交易。此外，你还可以通过增强比特币网络的能力，为比特币网络做出贡献。 然而，运行一个节点，需要有足够资源来处理所有比特币交易的永久的可连接的系统。取决于你是否选择索引所有交易并保存区块链的完整副本，你可能还需要大量的磁盘空间和内存。 在2018年初，一个全部索引的节点需要至少2GB内存和160GB硬盘空间（参见 https://blockchain.info/charts/blocks-size）。比特币节点也需要网络带宽来传输和接收比特币交易和区块。如果你的网络带宽有限，则你可能不应该在其上运行比特币节点，或者以限制其带宽的方式运行它（参见 Sample configuration of a resource-constrained system）。 > Bitcoin Core默认保存完整的区块链副本，包括2009年以来所有比特币网络上发生的交易。该数据集的大小为几十GB，可以在几天或几周内递增下载，具体取决于你的CPU和网络速度。在完整的区块链数据集下载完之前，Bitcoin Core将无法处理交易或更新账户余额。确保你有足够的磁盘空间，带宽和时间来完成初始同步。你可以配置Bitcoin Core，通过丢弃旧块来减少区块链的大小。(参见 Sample configuration of a resource-constrained system), 但在丢弃数据之前它仍会下载整个数据集。 尽管存在资源限制，仍有数千志愿者运行比特币节点。有些系统像Raspberry Pi一样简单（35美元的纸盒大小的电脑）。许多志愿者还在租用服务器上运行比特币节点，通常是Linux的一些变体。 Virtual Private Server（VPS）或Cloud Computing Server实例可用于运行比特币节点。这些服务器可以每月25美元或50美元的价格从各种提供商处获得。 为什么要运行比特币节点呢？以下是一些理由: 你正在开发比特币软件，需要依靠比特币节点进行网络和区块链的API访问。 你正在构建必须根据比特币的共识规则验证交易的应用程序。例如，比特币软件公司通常运行多个节点。 你想支持比特币。运行一个节点可以使网络更强大，能够服务更多的钱包，更多的用户和更多的交易。 你不想依赖任何第三方来处理或验证你的交易。 如果你正在阅读本书并且对开发比特币软件感兴趣，那么你应该运行自己的节点。 配置Bitcoin Core节点 Bitcoin Core在每次启动时会在其数据目录中查找配置文件。在本节中，我们将研究各种配置选项并进行配置。要找到配置文件，请在终端中运行 bitcoind -printtoconsole 并查看前几行。 $ bitcoind -printtoconsole Bitcoin version v0.15.0 Using the 'standard' SHA256 implementation Using data directory /home/ubuntu/.bitcoin/ Using config file /home/ubuntu/.bitcoin/bitcoin.conf ... [a lot more debug output] ... 确定了配置文件的位置之后，你可以按Ctrl-C关闭该节点。通常配置文件位于用户主目录下的.bitcoin数据目录中。接下来在编辑器中打开配置文件。 Bitcoin Core提供了超过100种配置选项，可以修改网络节点的行为，区块链的存储以及许多其他方面。要查看这些选项的列表，请运行 bitcoind --help： $ bitcoind --help Bitcoin Core Daemon version v0.15.0 Usage: bitcoind [options] Start Bitcoin Core Daemon Options: -? Print this help message and exit -version Print version and exit -alertnotify= Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message) ... [many more options] ... -rpcthreads= Set the number of threads to service RPC calls (default: 4) 以下是你可以在配置文件中设置的一些最重要的选项，也可以作为 bitcoind 的命令行参数： alertnotify 运行指定的命令或脚本，向该节点的所有者发送紧急警报，通常通过电子邮件的形式。 conf 配置文件的替代位置。这仅适用于 bitcoind 的命令行参数。 datadir 放置所有区块链数据的目录。默认情况下，这是你的主目录的 .bitcoin 目录的子目录。确保这个目录所在的文件系统有数GB的可用空间。 prune 通过删除旧的块，将磁盘空间需求减少到多少MB。在不适合存放完整区块链的资源受限节点上使用它。 txindex 维护所有交易的索引。这意味着，允许你以编程方式通过ID检索一个完整的区块链副本的任何交易。 dbcache UTXO缓存的大小。默认值是300MB。在高端硬件上增加该值，在低端硬件上减少该值的大小以节省内存，但会导致更多磁盘开销。 maxconnections 设置可以从最多多少个节点接受连接。将默认值减小将减少你的带宽消耗。如果你有带宽限制或按带宽支付，请使用此选项。 maxmempool 将交易内存池的大小设置为多少MB。在内存受限的节点上使用。 maxreceivebuffer/maxsendbuffer 将每个连接的内存缓冲区限制为多少KB。在内存受限的节点上使用。 minrelaytxfee 设置你愿意传播的交易的最低费率。在此值以下，交易处理为非标准交易，从交易池中拒绝并且不转发。 交易数据库索引和txindex选项 默认情况下，Bitcoin Core只创建包含用户的钱包相关交易的数据库。如果你想使用 getrawtransaction 之类的命令访问任何交易，(参见 检查并解码交易), 你需要在配置文件中设置 txindex=1 以使 Bitcoin Core 创建完整的交易索引。如果你一开始未设置此选项，在之后设置完成后需要使用 bitcoind -reindex 重启并等待其重新构建索引。 Sample configuration of a full-index node 展示了如何将前面的选项与完全索引的节点相结合，作为比特币应用程序的API后端运行。 Example 1. Sample configuration of a full-index node alertnotify=myemailscript.sh \"Alert: %s\" datadir=/lotsofspace/bitcoin txindex=1 Sample configuration of a resource-constrained system 展示了资源受限节点的配置。 Example 2. Sample configuration of a resource-constrained system alertnotify=myemailscript.sh \"Alert: %s\" maxconnections=15 prune=5000 dbcache=150 maxmempool=150 maxreceivebuffer=2500 maxsendbuffer=500 在按照你需求编辑了配置文件之后，可以运行 bitcoind -printtoconsole 来测试 $ bitcoind -printtoconsole Bitcoin version v0.15.0 InitParameterInteraction: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1 Assuming ancestors of block 0000000000000000003b9ce759c2a087d52abc4266f8f4ebd6d768b89defa50a have valid signatures. Using the 'standard' SHA256 implementation Default data directory /home/ubuntu/.bitcoin Using data directory /lotsofspace/.bitcoin Using config file /home/ubuntu/.bitcoin/bitcoin.conf Using at most 125 automatic connections (1048576 file descriptors available) Using 16 MiB out of 32/2 requested for signature cache, able to store 524288 elements Using 16 MiB out of 32/2 requested for script execution cache, able to store 524288 elements Using 2 threads for script verification HTTP: creating work queue of depth 16 No rpcpassword set - using random cookie authentication Generated RPC authentication cookie /lotsofspace/.bitcoin/.cookie HTTP: starting 4 worker threads init message: Verifying wallet(s)... Using BerkeleyDB version Berkeley DB 4.8.30: (April 9, 2010) Using wallet wallet.dat CDBEnv::Open: LogDir=/lotsofspace/.bitcoin/database ErrorFile=/lotsofspace/.bitcoin/db.log scheduler thread start Cache configuration: * Using 250.0MiB for block index database * Using 8.0MiB for chain state database * Using 1742.0MiB for in-memory UTXO set (plus up to 286.1MiB of unused mempool space) init message: Loading block index... Opening LevelDB in /lotsofspace/.bitcoin/blocks/index Opened LevelDB successfully [... more startup messages ...] 确认配置正确被加载后可以按Ctrl-C结束进程。 要将Bitcoin Core作为后台进程运行，可以使用 bitcoind -daemon. 要观察节点的进程和运行时状态，可使用 bitcoin-cli getblockchaininfo: $ bitcoin-cli getblockchaininfo { \"chain\": \"main\", \"blocks\": 0, \"headers\": 83999, \"bestblockhash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\", \"difficulty\": 1, \"mediantime\": 1231006505, \"verificationprogress\": 3.783041623201835e-09, \"chainwork\": \"0000000000000000000000000000000000000000000000000000000100010001\", \"pruned\": false, [...] } 这展示了区块链高度为0个块，有83999个区块头的节点。节点先获取最佳链的区块头，然后继续下载完整块。 在你完成选项配置之后，应该将比特币添加到操作系统中的启动脚本中，以便它可以持续运行并在操作系统重新启动时重启。你可以在 contrib/init 下找到比特币源目录中各种操作系统的启动脚本示例以及显示哪个系统使用哪个脚本的 README.md 文件。 Bitcoin Core API Bitcoin Core 客户端实现了JSON-RPC接口，也可以使用命令行工具 bitcoin-cli 来访问。命令行允许我们以交互的方式试验通过API方式提供的功能。 首先，调用 help 命令查看可用比特币RPC命令的列表： $ bitcoin-cli help addmultisigaddress nrequired [\"key\",...] ( \"account\" ) addnode \"node\" \"add|remove|onetry\" backupwallet \"destination\" createmultisig nrequired [\"key\",...] createrawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...} decoderawtransaction \"hexstring\" ... ... verifymessage \"bitcoinaddress\" \"signature\" \"message\" walletlock walletpassphrase \"passphrase\" timeout walletpassphrasechange \"oldpassphrase\" \"newpassphrase\" 每个命令都可能需要许多参数。要获得更详细的参数信息，请在 help 后添加命令名。例如，要查看 getblockhash RPC命令的帮助： $ bitcoin-cli help getblockhash getblockhash height Returns hash of block in best-block-chain at height provided. Arguments: 1. height (numeric, required) The height index Result: \"hash\" (string) The block hash Examples: > bitcoin-cli getblockhash 1000 > curl --user myusername --data-binary '{\"jsonrpc\": \"1.0\", \"id\":\"curltest\", \"method\": \"getblockhash\", \"params\": [1000] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/ 在帮助信息的末尾，你将看到两个RPC命令的例子，分别使用 bitcoin-cli 和HTTP客户端 curl。这些示例演示了如何调用该命令。复制第一个示例并查看结果： $ bitcoin-cli getblockhash 1000 00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09 结果是一个区块的哈希值，在下面的章节中有更详细的描述。该命令应该在你的系统上返回相同的结果，表明你的Bitcoin Core节点正在运行，接受命令，并且将有关块1000的信息返回给你。 在接下来的部分中，我们将演示一些非常有用的RPC命令及其预期的输出。 获得Bitcoin Core客户端的状态信息 Bitcoin Core 通过 JSON-RPC 接口提供不同模块的状态报告。最重要的命令包括 getblockchaininfo, getmempoolinfo, getnetworkinfo 和 getwalletinfo。 比特币的 getblockchaininfo RPC 命令之前已经介绍了。getnetworkinfo 命令用于展示比特币网络节点的基本状态信息。使用 bitcoin-cli 调用: $ bitcoin-cli getnetworkinfo \"version\": 150000, \"subversion\": \"/Satoshi:0.15.0/\", \"protocolversion\": 70015, \"localservices\": \"000000000000000d\", \"localrelay\": true, \"timeoffset\": 0, \"networkactive\": true, \"connections\": 8, \"networks\": [ ... detailed information about all networks (ipv4, ipv6 or onion) ... ], \"relayfee\": 0.00001000, \"incrementalfee\": 0.00001000, \"localaddresses\": [ ], \"warnings\": \"\" } 数据通过JSON格式返回,可以被所有编程语言处理，而且是可读的。在这些数据中，我们可以看到比特币软件客户端版本号（150000）和比特币协议版本号（70015），当前的连接数（8），以及有关比特币网络的各种信息与此客户端相关的设置。 > bitcoind+客户端来说，它需要一段时间（或许超过一天的时间）“赶上”当前区块链高度，因为它从其他比特币客户端下载区块。你可以使用 +getblockchaininfo 来查看其进度，以查看已知区块的数量。 检查并解码交易 命令: getrawtransaction, decoderawtransaction 在 [cup_of_coffee] 的案例中, Alice从Bob’s Cafe购买了一杯咖啡。她的交易ID (txid)为+0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2+。让我们使用API，通过交易ID来检索和查看这笔交易： $ bitcoin-cli getrawtransaction 0627052b6f28912f2703066a912ea577f2ce4da4caa5a↵ 5fbd8a57286c345c2f2 0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd734d2804fe65fa35779000↵ 000008b483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4↵ ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813014↵ 10484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc54123363767↵ 89d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adfffffffff0260e3160000000↵ 0001976a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef8000000000001976a9↵ 147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000000 > 在交易确认之前，交易ID不是可信的。区块链中没有交易的哈希值并不意味着交易未处理。这被称为“交易可锻性（transaction malleability）”，因为在区块中确认之前，交易的哈希可以被修改。确认后，txid 是不可变的和可信的。 getrawtransaction 命令以十六进制返回一个序列化的交易。将它作为 decoderawtransaction 命令的参数可以解码： $ bitcoin-cli decoderawtransaction 0100000001186f9f998a5aa6f048e51dd8419a14d8↵ a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba474↵ 6ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298↵ cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fd↵ e0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa↵ 336a8d752adfffffffff0260e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5↵ d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8↵ 88ac00000000 { \"txid\": \"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2\", \"size\": 258, \"version\": 1, \"locktime\": 0, \"vin\": [ { \"txid\": \"7957a35fe64f80d234d76d83a2...8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\": { \"asm\":\"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1decc...\", \"hex\":\"483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1de...\" }, \"sequence\": 4294967295 } ], \"vout\": [ { \"value\": 0.01500000, \"n\": 0, \"scriptPubKey\": { \"asm\": \"OP_DUP OP_HASH160 ab68...5f654e7 OP_EQUALVERIFY OP_CHECKSIG\", \"hex\": \"76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac\", \"reqSigs\": 1, \"type\": \"pubkeyhash\", \"addresses\": [ \"1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA\" ] } }, { \"value\": 0.08450000, \"n\": 1, \"scriptPubKey\": { \"asm\": \"OP_DUP OP_HASH160 7f9b1a...025a8 OP_EQUALVERIFY OP_CHECKSIG\", \"hex\": \"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac\", \"reqSigs\": 1, \"type\": \"pubkeyhash\", \"addresses\": [ \"1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK\" ] } } ] } 解码后的交易展示了此交易的所有组成部分，包括交易的输入和输出。我们看到将15mBitcoin转到新地址的交易使用了一个输入并产生了两个输出。此交易的输入是以前确认的交易的输出（vin中的 txid ，以 7957a35fe 开头 ）。两个输出对应于15mBitcoin的款项，和返回给发送者的零钱。 我们可以通过使用 getrawtransaction 检查此交易中引用的前一个交易的 txid 来进一步探索区块链。我们可以追踪一笔比特币在不同所有者地址之间传递的交易链。 检查区块 命令: getblock, getblockhash 检查区块与检查交易类似。区块可以通过块高度（height）或块哈希（hash）来引用。首先，我们根据高度找到一个块。在 [cup_of_coffee] 中，我们看到Alice的交易包含在区块#277316中。 将块高度作为 getblockhash 命令的参数, ，将返回区块的哈希值: $ bitcoin-cli getblockhash 277316 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 现在我们知道Alice的交易被包含在哪个块中了，我们可以使用 getblock 命令，传递区块哈希值来查询该块。 $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b3↵ 1b2cc7bdc4 { \"hash\": \"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4\", \"confirmations\": 37371, \"size\": 218629, \"height\": 277316, \"version\": 2, \"merkleroot\": \"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e\", \"tx\": [ \"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f\", \"b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe\", \"04905ff987ddd4cfe603b03cfb7ca50ee81d89d1f8f5f265c38f763eea4a21fd\", \"32467aab5d04f51940075055c2f20bbd1195727c961431bf0aff8443f9710f81\", \"561c5216944e21fa29dd12aaa1a45e3397f9c0d888359cb05e1f79fe73da37bd\", [... hundreds of transactions ...] \"78b300b2a1d2d9449b58db7bc71c3884d6e0579617e0da4991b9734cef7ab23a\", \"6c87130ec283ab4c2c493b190c20de4b28ff3caf72d16ffa1ce3e96f2069aca9\", \"6f423dbc3636ef193fd8898dfdf7621dcade1bbe509e963ffbff91f696d81a62\", \"802ba8b2adabc5796a9471f25b02ae6aeee2439c679a5c33c4bbcee97e081196\", \"eaaf6a048588d9ad4d1c092539bd571dd8af30635c152a3b0e8b611e67d1a1af\", \"e67abc6bd5e2cac169821afc51b207127f42b92a841e976f9b752157879ba8bd\", \"d38985a6a1bfd35037cb7776b2dc86797abbb7a06630f5d03df2785d50d5a2ac\", \"45ea0a3f6016d2bb90ab92c34a7aac9767671a8a84b9bcce6c019e60197c134b\", \"c098445d748ced5f178ef2ff96f2758cbec9eb32cb0fc65db313bcac1d3bc98f\" ], \"time\": 1388185914, \"mediantime\": 1388183675, \"nonce\": 924591752, \"bits\": \"1903a30c\", \"difficulty\": 1180923195.258026, \"chainwork\": \"000000000000000000000000000000000000000000000934695e92aaf53afa1a\", \"previousblockhash\": \"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569\", \"nextblockhash\": \"000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7\" } 这个区块包含 419 笔交易，第64个交易（0627052b...）是Alice的交易。height 字段告诉我们它是区块链中的第277316个区块。 使用Bitcoin Core的编程接口 bitcoin-cli 助手对于探索比特币核心API和测试功能非常有用。但API的重要功能是以编程方式访问。在本节中，我们将演示如何通过另一个程序访问比特币核心。 Bitcoin Core的API是JSON-RPC接口. JSON代表JavaScript Object Notation，是一种非常方便人类和程序阅读的数据格式。RPC代表远程过程调用，这意味着我们通过网络协议调用远程（在比特币核心节点上的）函数。在这种情况下，网络协议是HTTP或HTTPS（用于加密连接）。 当我们使用 bitcoin-cli 命令获取命令帮助时，它向我们展示了使用 curl（常用的命令行HTTP客户端）构造JSON-RPC调用的示例： $ curl --user myusername --data-binary '{\"jsonrpc\": \"1.0\", \"id\":\"curltest\", \"method\": \"getblockchaininfo\", \"params\": [] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/ 此命令表示 curl 向本地主机（127.0.0.1）提交HTTP请求，连接到默认的比特币端口（8332），并使用 text/plain 编码为 getblockchaininfo 方法提交 jsonrpc 请求。 你可能会注意到curl会要求凭证随请求一起发送。 Bitcoin Core在每次启动时创建一个随机密码，并将其放置在名称为 .cookie 的数据目录中。 bitcoin-cli 助手可以根据数据目录读取此密码文件。同样，你可以复制密码并将其传递给curl（或任何更高级别的Bitcoin Core RPC包装器）。或者，你可以使用Bitcoin Core源码目录中的 ./share/rpcuser/rpcuser.py 中提供的助手程序脚本创建一个静态密码。 你可以正在自己的程序中使用HTTP库来实现JSON-RPC调用，类似于前面的 curl 示例。 然而，大多数编程语言都有一些“包装”了比特币核心API的库，简便很多。我们将使用 python-bitcoinlib 库来简化API访问。你需要有一个正在运行的Bitcoin Core实例，用于进行JSON-RPC调用。 Running getblockchaininfo via Bitcoin Core’s JSON-RPC API 中的Python脚本调用 getblockchaininfo 并打印返回数据中的区块个数。 Example 3. Running getblockchaininfo via Bitcoin Core’s JSON-RPC API link:code/rpc_example.py[] 运行它可以得到下面的结果: $ python rpc_example.py 394075 它标明本地的Bitcoin Core节点在其区块链中有394075个区块。 接下来，让我们使用 getrawtransaction 和 decodetransaction 调用来检索Alice的咖啡交易细节。在Retrieving a transaction and iterating its outputs中，我们检索Alice的交易并列出交易的输出。对于每个输出，我们显示收件人地址和值。提醒一下，Alice的交易有一个支付给Bob’s Cafe的输出和一个返回给Alice的找零输出。 Example 4. Retrieving a transaction and iterating its outputs link:code/rpc_transaction.py[] 运行这段代码： $ python rpc_transaction.py ([u'1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA'], Decimal('0.01500000')) ([u'1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK'], Decimal('0.08450000')) 前面的两个例子都很简单。你并不需要写程序来运行它们；你可以轻松使用 bitcoin-cli 助手。然而，下一个例子需要几百次RPC调用，更清楚地说明了编程接口的作用。 在 Retrieving a block and adding all the transaction outputs 中，我们首先检索第277316个区块，然后使用交易ID检索区块内419个交易中的每一个。接下来，我们遍历每笔交易的输出并累加起来。 Example 5. Retrieving a block and adding all the transaction outputs link:code/rpc_block.py[] 运行这段代码： $ python rpc_block.py ('Total value in block: ', Decimal('10322.07722534')) 我们的示例代码计算出此区块的总价值为10322.07722534 BTC（包括25BTC奖励和0.0909BTC费用）。通过在区块浏览器中搜索哈希或高度，进行数据比较。一些区块浏览器报告不包括奖励和排除费用的总价值，看看你是否可以发现差异。 可选的客户端、程序库和工具包 比特币生态系统中有许多可选的客户端，程序库和工具包，甚至是完整节点的实现。它们以各种编程语言实现，为程序员提供其首选编程语言的原生接口。 下面列出了一些： C/C++ Bitcoin Core 比特币的参考实现 libbitcoin 跨平台的C++开发工具，节点和共识函数库 bitcoin explorer Libbitcoin的命令行工具 picocoin Jeff Garzik写的C语音的轻量级比特币客户端库 JavaScript bcoin 带有API的模块化，可扩展的完整节点实现 Bitcore Bitpay提供的完整节点，API和程序库 BitcoinJS 用于node.js和浏览器的纯JavaScript比特币库 Java bitcoinj Java版完整节点客户端库 Bits of Proof (BOP) 比特币的Java企业级实现 PHP bitwasp/bitcoin PHP比特币库, 和相关的项目 Python python-bitcoinlib Python比特币库，共识库，和Peter Todd写的节点 pycoin Richard Kiss写的Python比特币库 pybitcointools Vitalik Buterin写的Python比特币库 Ruby bitcoin-client Ruby封装的JSON-RPC API Go btcd Go语言的完整节点客户端 Rust rust-bitcoin 用于序列化，解析和API调用的Rust比特币库 C NBitcoin .NET框架的综合比特币库 Objective-C CoreBitcoin 为ObjC和Swift提供的比特币工具包 还有各种编程语言的库存在，还有更多的库在开发。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 13:50:56 "},"06第四章.html":{"url":"06第四章.html","title":"密钥和地址","keywords":"","body":"密钥和地址 你可能听说过比特币是基于 密码学 的，它是计算机安全领域广泛使用的数学分支。密码学在希腊文中的意思是“秘密写作”，但密码学的科学不仅仅包含秘密写作，它被称为加密。密码学也可以用来在不泄露保密内容的情况下，证明一个人知道保密内容（数字签名），或证明数据的真实性（数字指纹）。这些密码学基础是比特币的关键数学工具，并广泛用于比特币应用。讽刺的是，加密并不是比特币的重要组成部分，因为它的通信和交易数据没有加密，也不需要通过加密保护资金。在本章中，我们将介绍比特币中使用的密码学，以密钥，地址和钱包的形式控制资金的所有权。 简介 比特币的所有权通过 数字密钥（digital keys） ， 比特币地址（bitcoin addresses） 和 数字指纹（digital signatures） 建立。数字密钥实际上并不存储在网络中，而是由用户创建并存储在文件或称为 钱包（wallet） 的简单数据库中。用户钱包中的数字密钥完全独立于比特币协议，可以由用户的钱包软件生成和管理，无需参考区块链或访问互联网。密钥支撑了比特币的许多有趣特性，包括去中心化的信任和控制，所有权证明以及有密码学保障的安全模型。 为了包含在区块链中，大多数比特币交易需要有效的数字签名，这些交易只能使用密钥生成；因此，任何拥有该密钥副本的人都可以控制这些比特币。 用于花费资金的数字签名也被称为 证据（witness) ，是密码学中的术语。比特币交易中的证据证明了所花费资金的真实所有权。 密钥由一对公钥和私钥组成。将公钥视为类似于银行帐号，将私钥视为PIN或支票上的签名，用于控制帐户。比特币用户很少看到这些数字密钥。大多数情况下，它们存储在钱包文件中并由比特币钱包软件管理。 在比特币交易的付款部分，收款人的公钥通过其数字指纹表示，称为 比特币地址（bitcoin address） ，与支票上的收款人姓名一样使用（即“付款到谁的账户”）。大多数情况下，比特币地址是从公钥生成的并且对应于公钥。但是，并非所有的比特币地址都代表公钥；他们也可以代表其他受益者，如脚本，我们将在本章后面看到。通过这种方式，比特币地址可以抽象为资金接收者，这使交易目的地变得灵活，类似于纸质支票：可用于支付个人账户，支付公司账户，支付账单或兑换现金。比特币地址是密钥的唯一展现形式，用户常会看到，因为他们需要向世界公开。 首先，我们将介绍密码学并解释比特币中使用的数学。接下来，我们将看看密钥是如何生成，存储和管理的。我们将看一下用于表示私钥公钥，地址和脚本地址的各种编码格式。最后，我们将看看密钥和地址的高级用法：虚荣（Vanity)，多重签名，脚本地址和纸钱包。 公钥加密和加密货币 公钥密码技术发明于20世纪70年代，是计算机和信息安全的数学基础。 公钥密码技术发明后，发现了一些合适的数学函数，例如素数指数运算和椭圆曲线乘法。这些数学函数实际上是不可逆的，这意味着它们很容易在一个方向上计算，但在相反方向上计算是不可行的。基于这些数学函数，密码学可以创建数字密钥和不可伪造的数字签名。比特币使用椭圆曲线乘法作为其密码学的基础。 在比特币中，我们使用公钥密码技术来创建一个控制比特币访问的密钥对。密钥对由一个私钥和从它派生的一个唯一的公钥组成。公钥用于接收资金，私钥用于签署交易以支付资金。 公钥和私钥之间存在数学关系，可以用私钥生成一个消息的签名，然后使用公钥在不公开私钥的情况下验证签名。 在花费比特币时，当前比特币的所有者需要在交易中提供他的公钥和签名（每次都不同，但由相同的私钥创建）。通过公钥和签名，比特币网络中的每个人都可以验证该交易的有效性并接受，从而确认转让这笔比特币的人拥有它们。 > 在大多数钱包实现中，为了方便起见，私钥和公钥一起存储为 密钥对儿（key pair） 。由于可以从私钥计算公钥，因此只存储私钥也是可能的。 私钥和公钥 比特币钱包包含密钥对儿的集合，每个密钥对儿包含一个私钥和一个公钥。私钥（k）是一个数字，通常随机选取。我们使用椭圆曲线乘法（单向加密函数）通过私钥生成公钥（K）。从公钥（K）中，我们使用单向加密哈希函数来生成比特币地址（A）。在本节中，我们将开始生成私钥，查看用于将其转换为公钥的椭圆曲线数学运算，最后从公钥生成一个比特币地址。私钥，公钥和比特币地址之间的关系如Private key, public key, and bitcoin address所示。 Figure 1. Private key, public key, and bitcoin address 为什么使用非对称加密 (公钥私钥)? 为什么在比特币中使用非对称加密技术？因为它不是用来“加密”（保密）交易的。相反，非对称加密的有用特性是产生数字签名。私钥可用于为交易生成指纹（数字签名）。这个签名只能由知道私钥的人制作。但是，任何有权访问公钥和交易指纹的人都可以使用它们来验证签名确实是私钥的拥有者生成的。非对称加密的这一有用特性使任何人都可以验证每笔交易的每个签名，同时确保只有私钥所有者才能生成有效的签名。 私钥 私钥只是一个随机选取的数字。对私钥的所有权和控制权是用户控制相应比特币地址所关联的所有资金的根本。私钥用于通过证明交易中使用的资金的所有权来创建花费比特币所需的签名。私钥在任何时候都必须保密，因为向第三方透露它相当于让它们控制由该密钥保护的比特币。私钥还必须备份和防止意外丢失，因为如果丢失了私钥，它就无法恢复，并且它所保护的资金也会永远丢失。 > 比特币私钥只是一个数字。你可以使用硬币，铅笔和纸随机挑选你的私钥：投掷硬币256次，就可以获得随机的一串二进制（0和1）数字，在钱包中使用。然后可以从私钥生成公钥。 通过随机数生成私钥 生成密钥的第一步也是最重要的一步是找到一个安全的熵源或随机数。创建比特币私钥本质上与“选择一个1到2256之间的数字”相同。只要保证不可预测性和不可重复性，用于选择该数字的确切方法并不重要。比特币软件使用底层操作系统的随机数生成器生成256位的私钥（随机数）。通常，操作系统随机数生成器是由一个人为的随机源进行初始化的，这就是为什么你可能会被要求将鼠标摆动几秒钟。 更具体地来说，私钥可以是 0 到 n-1 的任何数字，这里n是一个常数 (n = 1.1578 * 1077, 略小于 2256) 定义为比特币中使用的椭圆曲线的阶数 (see 椭圆曲线密码学解释)。为了创建这样的密钥，我们随机选择一个256位的数字并检查它是否小于+n+。从编程的角度说，通常是通过从密码学安全的随机源收集的大量随机数输入SHA256散列算法中，该算法将产生256位的数字。如果结果小于+n+，我们就找到了一个合适的私钥。否则，我们只需使用另一个随机数再次尝试。 > Warning: 不要自己编写代码或使用你的编程语言提供的“简单”随机数生成器来创建一个随机数。使用密码学安全的伪随机数生成器（CSPRNG）和来自足够熵源的种子。研究你选择的随机数生成器库的文档，以确保其是密码学安全的。正确实施CSPRNG对于密钥的安全至关重要。 以下是以十六进制格式显示的随机生成的私钥（k）（256位，显示为64个十六进制数字，每个4位）： 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD > 比特币私钥的数值空间的大小（2256）是非常大的数目。十进制大约是1077。可见的宇宙估计含有1080原子。 要使用 Bitcoin Core 客户端生成新的密钥 (see [ch03_bitcoin_client]), 可以用 getnewaddress 命令. 出于安全考虑，它只显示公钥，而不显示私钥。可以使用 dumpprivkey 命令要求 bitcoind 公开私钥。dumpprivkey 命令以Base58 checksum编码显示私钥，称为 钱包导入格式（WIF），我们将在私钥格式中更详细地介绍。以下是使用这两个命令生成和显示私钥的示例： $ bitcoin-cli getnewaddress 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy $ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ dumpprivkey 命令打开钱包并提取由 getnewaddress 命令生成的私钥。除非它们都存储在钱包中，否则+bitcoind+不可能通过公钥知道私钥。 > dumpprivkey+命令不会通过公钥生成私钥，因为这是不可能的。该命令只是显示钱包已知的由 getnewaddress+命令生成的私钥。 你还可以使用比特币资源管理器命令行工具（参见[appdx_bx]）使用命令 seed，ec-new 和 ec-to-wif 来生成和显示私钥： $ bx seed | bx ec-new | bx ec-to-wif 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 公钥 公钥使用私钥通过椭圆曲线乘法计算，这是不可逆的：K = k G，其中 k 是私钥，G 是一个称为 生成点（generator point） 的固定的点，K 是公钥。如果你知道 K ，那么称为“寻找离散对数”的逆运算与尝试所有可能的 k* 值（即蛮力搜索）一样困难。在我们演示如何从私钥生成公钥之前，我们先来看一下椭圆曲线加密。 > 椭圆曲线乘法是密码学家称为“陷阱门”的一种函数：在一个方向（乘法）很容易做到，而在相反方向（除法）不可能做到。私钥的所有者可以很容易地创建公钥，然后与世界共享，因为知道没有人能够反转该函数并从公钥计算私钥。这种数学技巧成为证明比特币资金所有权的不可伪造且安全的数字签名的基础。 椭圆曲线密码学解释 椭圆曲线密码术是一种基于离散对数问题的非对称或公钥密码技术，用椭圆曲线上的加法和乘法表示。 An elliptic curve 是一个椭圆曲线的示例，与比特币使用的类似。 Figure 2. An elliptic curve 比特币使用由美国国家标准与技术研究院（NIST）建立的称为 secp256k1 的标准中定义的特定椭圆曲线和一组数学常数。secp256k1 曲线由以下函数定义，产生一个椭圆曲线： [\\begin{equation} {y^2 = (x^3 + 7)}~\\text{over}~(\\mathbb{F}_p) \\end{equation}] or [\\begin{equation} {y^2 \\mod p = (x^3 + 7) \\mod p} \\end{equation}] mod p (模素数p) 表明该曲线位于素数阶的有限域上。p, 也写作 (( \\mathbb{F}_p )), p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1, 是一个非常大的素数. 因为这条曲线是在有限的素数阶上而不是在实数上定义的，所以它看起来像是一个散布在二维中的点的模式，难以可视化。然而，运算与实数上的椭圆曲线的是相同的。作为示例，Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17在一个更小的素数阶17的有限域上显示了相同的椭圆曲线，显示了一个网格上的点的图案。 可以认为+secp256k1+比特币椭圆曲线是一个不可思议的大网格上的非常复杂的点阵。 Figure 3. Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17 例如，以下是坐标为（x，y）的点P，它是 secp256k1 曲线上的一个点： P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424) Using Python to confirm that this point is on the elliptic curve 展示了如何使用Python检验: Example 1. Using Python to confirm that this point is on the elliptic curve Python 3.4.0 (default, Mar 30 2014, 19:23:13) [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663 >>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240 >>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424 >>> (x ** 3 + 7 - y**2) % p 0 在椭圆曲线中，有一个叫做“无限点”的点，它大致相当于零点的作用。在计算机上，它有时用x = y = 0表示（它不满足椭圆曲线方程，但它是一个容易区分的情况）。 还有一个 + 运算符, 称为 \"加法\"，与传统的实数加法有类似的属性。给定椭圆曲线上的点 P1 和 P2，则 P3 = P1 + P2, 也在椭圆曲线上. 几何上来说，P3是通过在P1和P2之间画一条直线来计算的。这条线将在另外一点与椭圆曲线相交，称此点为 P3' = (x, y)。然后在x轴上反射得到 P3 =（x，-y）。 有几个特殊情况解释了“无限点”的需要。 如果 P1 和 P2 是同一点，则 P1 和 P1 之间的直线应该延伸到曲线上 P1 的切线。该切线恰好与曲线相交于一个新的点。你可以使用微积分技术来确定切线的斜率。尽管我们局限在具有两个整数坐标的曲线上，但这些机制仍然可以神奇的运转。 在某些情况下（如 P1 和 P2 具有相同的x值但不同的y值），切线将是垂直的，在这种情况下 P3=“无限点”。 如果 P1 是“无穷远点”，则 P1 + P2 = P2。同样，如果 P2 是无穷远点，则 P1 + P2 = P1。这展示了无穷远点如何扮演零的角色。 + 是可结合的，这意味着（A + B）+ C = A +（B + C）。这意味着我们可以书写 A + B + C，没有括号也没有歧义。 现在我们已经定义了加法，我们可以用扩展加法的标准方式来定义乘法。对于椭圆曲线上的点P，如果k是整数, 则 kP = P + P + P + … + P (k 次). 在这种情况下，k有时会被混淆地称为“指数”。 生成公钥 从一个随机生成的私钥 k 开始，我们将它乘以曲线上的一个预定点，称为 生成点（generator point） G，以在曲线上的其他位置生成另一个点，这是相应的公钥 K 。生成点被指定为 secp256k1 标准的一部分，并且对于比特币中的所有密钥都是相同的： [\\begin{equation} {K = k * G} \\end{equation}] 其中 k 是私钥， G 是生成点， K 是生成的公钥，即曲线上的一个点。由于所有比特币用户的生成点始终相同，因此G乘以G的私钥始终会生成相同的公钥K。 k 和 K 之间的关系是固定的，但只能从 k 到 K 的一个方向进行计算。这就是为什么比特币地址（从 K 派生）可以与任何人共享，并且不会泄露用户的私钥（ k ）。 > 私钥可以转换为公钥，但公钥不能转换回私钥，因为计算是单向的。 实现椭圆曲线乘法，我们将先前生成的私钥 k 与乘法生成点G相乘得到公钥 K ： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G 公钥K被定义为一个点 K = (x,y) K = (x, y) 其中, x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 为了可视化一个点与整数的乘积，我们将使用简单的椭圆曲线来代替实数 — 记住，算法是相同的。我们的目标是找到生成点 G 的多个 kG ，这与将 G 自身相加 k 次相同。在椭圆曲线中，一个点自身相加相当于在该点上绘制切线并找到它再次与曲线相交的位置，然后在x轴上反射该点。 Elliptic curve cryptography: visualizing the multiplication of a point G by an integer k on an elliptic curve 展示了 G , 2G , 4G 在曲线上的几何操作。 > 大多数比特币实现使用 OpenSSL cryptographic library 进行椭圆曲线运算。例如，可以使用 EC_POINT_mul() 函数生成公钥。 Figure 4. Elliptic curve cryptography: visualizing the multiplication of a point G by an integer k on an elliptic curve 比特币地址 比特币地址是一串数字和字符，可以与任何想要向你汇款的人分享。从公钥生成的地址由一串数字和字母组成，从数字“1”开始。以下是一个比特币地址的例子： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 比特币地址是交易中最常见的资金“接收者”地址。如果我们将比特币交易与纸质支票进行比较，那么比特币地址就是受益人，这是“支付给谁”后面要填写的。对纸质支票来说，受益人有时可以是银行账户的持有人，但也可以包括公司，机构甚至现金。由于纸质支票不需要指定账户，而是使用抽象名称作为资金的接收者，所以它们是非常灵活的支付工具。比特币的交易使用类似的抽象：比特币地址，从而使它们非常灵活。比特币地址可以表示私钥/公钥对儿的所有者，也可以表示其他内容，比如付款脚本，我们将在[p2sh]中看到。现在，让我们来看一个简单的例子，一个代表公钥的比特币地址。 比特币地址是由公钥单向加密散列而来的。“散列算法”是一种单向函数，可以为任意大小的输入产生指纹或“散列”。加密散列函数广泛用于比特币：比特币地址，脚本地址和挖矿PoW验证算法。用于从公钥生成比特币地址的算法是“安全散列算法”（SHA）和“RACE完整性基元评估消息摘要算法”（RIPEMD），具体来说是SHA256和RIPEMD160。 从公钥 K 开始，我们计算它的SHA256哈希值，然后再计算结果的RIPEMD160哈希值，产生一个160位（20字节）的数字： [\\begin{equation} {A = RIPEMD160(SHA256(K))} \\end{equation}] 其中 K 是公钥，A 是生成的比特币地址。 > 比特币地址与公钥不一样。比特币地址是使用单向函数从公钥导出的。 比特币地址几乎总是被编码为“Base58Check”（参见Base58 和 Base58Check 编码），该地址使用58个字符（Base58数字系统）和校验和来提供可读性，避免模糊不清，防止地址转录和输入中的错误。Base58Check也可用在其他需要用户阅读并正确转录数字（比如比特币地址，私钥，加密密钥或脚本哈希）的地方。在下一节中，我们将研究Base58Check编码和解码的机制以及由此产生的表示。Public key to bitcoin address: conversion of a public key into a bitcoin address 说明了公钥转换为比特币地址的过程。 Figure 5. Public key to bitcoin address: conversion of a public key into a bitcoin address Base58 和 Base58Check 编码 为了使用少量的符号，以紧凑的形式展示很长的数字，许多计算机系统使用基数（进制）高于10的混合字母数字表示。例如，传统的十进制系统使用0到9的10个数字，十六进制使用16个（字母A到F作为六个附加符号）。以十六进制格式表示的数字比等效的十进制表示更短。更加紧凑的Base64表示使用26个小写字母，26个大写字母，10个数字和另外2个字符（如 “+” 和 “/” ）在基于文本的媒体（如电子邮件）上传输二进制数据。Base64最常用于向电子邮件添加二进制附件。Base58是一种基于文本的二进制编码格式，用于比特币和许多其他加密货币。它在紧凑表示，可读性和错误检测与预防之间提供了平衡。Base58是Base64的一个子集，使用大小写字母和数字，省略了一些经常被混淆的，或在使用某些字体显示时看起来相同的。 具体来说，相比Base64，Base58没有0（数字0），O（大写o），l（小写L），I（大写i）和符号“+”和“/”。 Bitcoin’s Base58 alphabet 是完整的Base58字母表。 Example 2. Bitcoin’s Base58 alphabet 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz 为了增加防范输入错误或转录错误的额外安全性，Base58Check是有内置错误校验代码的Base58编码格式，经常在比特币中使用。校验和是添加到编码数据末尾的四个字节。校验和来自编码数据的哈希散列值，可用于检测和防止转录和输入错误。当使用Base58Check代码时，解码软件将计算数据的校验和并将其与代码中包含的校验和进行比较。如果两者不匹配，则会引入错误并且Base58Check数据无效。这可以防止错误的比特币地址被钱包软件接收，导致资金损失。 要将数据（数字）转换为Base58Check格式，我们首先为数据添加一个名为“版本字节”的前缀，以便轻松识别编码数据的类型。例如，比特币地址的前缀为零（十六进制中的0x00），而编码私钥时使用的前缀为128（十六进制中的0x80）。常用的版本前缀参见 Base58Check version prefix and encoded result examples 。 接下来，我们计算“double-SHA”校验和，在前面的结果（前缀和数据）上应用两次SHA256哈希算法： checksum = SHA256(SHA256(prefix+data)) 在产生的32字节散列（hash-of-a-hash）中，我们只取前四个字节，作为错误检查代码或校验和。将校验和追加到最后。 结果由三项组成：前缀，数据和校验和。该结果使用前面描述的Base58字母表进行编码。 Base58Check encoding: a Base58, versioned, and checksummed format for unambiguously encoding bitcoin data 展示了Base58Check编码过程。 Figure 6. Base58Check encoding: a Base58, versioned, and checksummed format for unambiguously encoding bitcoin data 在比特币中，大部分呈现给用户的数据都是Base58Check编码的，以使其紧凑，易于阅读并易于检测错误。 Base58Check编码中的版本前缀用于创建容易区分的格式。这些字符使人们很容易得知编码数据的类型以及如何使用它。例如，Base58Check编码的比特币地址以1开头，Base58Check编码的密钥钱包导入格式（WIF）以5开头。一些示例版本前缀和Base58字符显示在 Base58Check version prefix and encoded result examples中。 Table 1. Base58Check version prefix and encoded result examples Type Version prefix (hex) Base58 result prefix Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K, or L BIP-38 Encrypted Private Key 0x0142 6P BIP-32 Extended Public Key 0x0488B21E xpub 密钥格式 私钥和公钥都可以用不同的格式表示。即使这些格式看起来不同，但它们的编码相同。这些格式主要用于使人们轻松阅读和转录密钥而不会引入错误。 私钥格式 私钥可以用不同的格式表示，所有这些格式都对应于相同的256位数字。 Private key representations (encoding formats) 显示了用于表示私钥的三种常用格式。不同的格式用在不同的情况。十六进制和原始二进制格式在软件内部使用，很少向用户显示。WIF用于在钱包之间导入/导出，并经常用于私钥的QR码（条形码）表示。 Table 2. Private key representations (encoding formats) Type Prefix Description Raw None 32 bytes Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128- and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding Example: Same key, different formats 展示了三种编码形式的私钥. Table 3. Example: Same key, different formats Format Private key Hex 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 所有这些表示都是显示相同数字和相同私钥的不同方式。它们看起来不同，但任何一种格式都可以轻松转换为任何其他格式。请注意，“原始二进制”没有显示在Example: Same key, different formats中。 我们使用 Bitcoin Explorer 的 wif-to-ec 命令（参见[appdx_bx]）来演示两个WIF密钥代表相同的私钥： $ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd $ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd Base58Check解码 Bitcoin Explorer 命令（参见[appdx_bx]）让我们很容易通过编写shell脚本和命令行“管道”，操作比特币密钥，地址和交易。你可以使用Bitcoin Explorer在命令行上解码Base58Check格式。 我们使用 base58check-decode 命令解码未压缩的密钥： $ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn wrapper { checksum 4286807748 payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd version 128 } 结果包含密钥的数据内容，WIF版本前缀128，以及校验和。 请注意，压缩密钥的“数据内容”附加了后缀+01+，表示派生的公钥将被压缩： $ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ wrapper { checksum 2339607926 payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 version 128 } 将十六进制编码为Base58Check 要编码到Base58Check，与上一个命令相对，我们使用Bitcoin Explorer的 base58check-encode 命令（请参见 [appdx_bx] ）并提供十六进制私钥，以及WIF版本的前缀128： bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 从十六进制（压缩的密钥）编码为Base58Check 要将“压缩”的私钥（请参见压缩的私钥）编码为Base58Check，要将后缀+01+附加到十六进制密钥后面，然后按照之前的方式进行编码： $ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128 KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 生成的WIF-compressed格式以“K”开头，表示内部的私钥具有后缀“01”，将仅用于生成压缩的公钥（请参阅压缩的公钥）。 公钥格式 公钥也能以不同的方式呈现，通常是compressed或uncompressed公钥。 如之前所见，公钥是由一对坐标+（x，y）组成的椭圆曲线上的一个点。它通常带有前缀+04，后跟两个256位数字：一个是该点的x坐标，另一个是y坐标。前缀+04+表示未压缩的公钥，+02+或+03+开头表示压缩的公钥。 这是我们先前创建的私钥生成的公钥，显示为坐标 x 和 y ： x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 这是以520位数字（130十六进制数字）表示的公钥，结构为 04 x y ： K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A↵ 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 压缩的公钥 压缩公钥被引入到比特币中，以减少交易处理的大小并节省存储空间。大多数交易包括公钥，这是验证所有者凭证并花费比特币所需的。每个公钥需要520位（ 前缀 + x + y ），每个块有几百个交易，每天产生千上万的交易时，会将大量数据添加到区块链中。 正如我们在公钥看到的那样，公钥是椭圆曲线上的一个点（x，y）。因为曲线表达了一个数学函数，所以曲线上的一个点代表该方程的一个解，因此，如果我们知道x坐标，我们可以通过求解方程来计算y坐标 y2 mod p =（ x3 + 7 ）mod p。这允许我们只存储公钥的x坐标，省略y坐标并减少密钥的大小和所需的256位空间。在每次交易中，几乎减少了50％的尺寸，加起来可以节省大量的数据！ 未压缩的公钥的前缀为+04+，压缩的公钥以+02+或+03+前缀开头。让我们看看为什么有两个可能的前缀：因为方程的左边是 y2，所以y的解是一个平方根，它可以具有正值或负值。从视觉上来说，这意味着生成的y坐标可以在x轴的上方或下方。从An elliptic curve中的椭圆曲线图可以看出，曲线是对称的，这意味着它在x轴上像镜子一样反射。因此，虽然我们可以省略y坐标，但我们必须存储y的sign（正数或负数）；换句话说，我们必须记住它高于或低于x轴，因为每个选项代表不同的点和不同的公钥。当在素数阶p的有限域上以二进制算法计算椭圆曲线时，y坐标是偶数或奇数，如前所述，它对应于正/负号。因此，为了区分y的两个可能值，我们存储一个压缩公钥，如果y是偶数，则前缀为+02+；如果是奇数，则存储前缀为+03+，从而允许软件从x坐标正确推导出y坐标，并将公钥解压为该点的完整坐标。Public key compression中说明了公钥的压缩。 Figure 7. Public key compression 以下先前生成的公钥，显示为以264位（66位十六进制数字）存储的压缩公钥，前缀+03+表示y坐标为奇数： K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 这个压缩的公钥对应于相同的私钥，表示它是从相同的私钥生成的。但是，它看起来与未压缩的公钥不同。更重要的是，如果我们使用双散列函数（ RIPEMD160（SHA256（K） ）将此压缩公钥转换为比特币地址，它将生成一个不同的比特币地址。这可能会造成混淆，因为这意味着单个私钥可以产生以两种不同格式（压缩和未压缩）表示的公钥，这两种格式产生两个不同的比特币地址。但是，两个比特币地址的私钥是相同的。 压缩公钥正在逐渐成为比特币客户端的默认设置，这对减少交易和区块链的规模具有重大影响。但是，并非所有客户端都支持压缩的公钥。支持压缩公钥的较新客户端必须考虑来自不支持压缩公钥的较旧客户端的交易。当钱包应用从另一个比特币钱包应用导入私钥时，这一点尤其重要，因为新钱包需要扫描区块链以查找与这些导入的密钥相对应的交易。比特币钱包应该扫描哪些比特币地址？由未压缩的公钥生成的比特币地址，还是由压缩公钥生成的比特币地址？两者都是有效的比特币地址，并且可以用私钥签名，但它们是不同的地址！ 要解决此问题，从钱包中导出私钥时，用WIF表示它们在新比特币钱包中以不同方式实现，表明这些私钥已用于生成compressed公钥和compressed比特币地址。这允许导入的钱包区分源自旧的或较新的钱包的私钥，并分别在区块链中搜索与未压缩的或压缩的公共密钥对应的比特币地址的交易。下一节我们来看看更详细的工作原理。 压缩的私钥 讽刺的是，术语“压缩私钥”是一种用词不当，因为当私钥以\"WIF-compressed\"的形式导出时，它实际上比“未压缩”的私钥多一个字节。这是因为私钥增加了一个字节的后缀（在Example: Same key, different formats中以十六进制显示为01），表示私钥来自较新的钱包并且应该仅用于产生压缩的公钥。私钥本身并不压缩，也不能被压缩。术语“压缩私钥”实际上是指“只能从私钥导出压缩的公钥”，而“未压缩的私钥”实际上是指“只能从私钥导出未压缩的公钥才”。你只应将导出格式称为“WIF-compressed”或“WIF”，不要将私钥本身称为“压缩”的以避免进一步混淆。 Example: Same key, different formats 展示了相同的密钥以 WIF 和 WIF-compressed 格式编码。 Table 4. Example: Same key, different formats Format Private key Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 十六进制压缩的私钥格式在结尾处有一个额外的字节（十六进制中的01）。虽然Base58编码的版本前缀对于WIF和WIF-compressed格式都是相同的（0x80），但在数字末尾添加一个字节会导致Base58编码的第一个字符从5更改为 K 或 L 。可以把它看作Base58相当于数字100和数字99之间的十进制编码差异。虽然100是比99更长的一位数字，但它前缀是1而不是9。长度的变化会影响前缀。在Base58中，随着数字长度增加一个字节，前缀5变为 K 或 L 。 请记住，这些格式不可互换使用。在实现压缩公钥的新钱包中，私钥只能以WIF-compressed方式导出（带有 K 或 L 前缀）。如果钱包是较旧的实现并且不使用压缩的公钥，则私钥只能以WIF形式导出（带有前缀5）。这里的目标是向导入这些私钥的钱包发出信号，告知它是否必须在区块链中搜索压缩或未压缩的公钥和地址。 如果一个比特币钱包能够实现压缩公钥，它将在所有交易中使用这些公钥。钱包中的私钥将用于派生曲线上的公钥，并压缩。压缩后的公钥将用于生成比特币地址用于交易。从实现压缩公钥的新钱包中导出私钥时，将修改WIF，并在私钥上添加一个字节的后缀+01+。由此产生的Base58Check编码的私钥称为“WIF-compressed”，并以字母 K 或 L 开头，而不是像来自旧钱包的WIF编码一样以“5”开头。 > “压缩私钥”是一个误用！它们没有被压缩；相反，WIF-compressed意味着密钥只能用于派生压缩的公钥及其相应的比特币地址。讽刺的是，一个“WIF-compressed”编码私钥多了1个字节，因为它具有附加的+01+后缀，可以将其与“未压缩”的区别开来。 用 C++ 实现密钥和地址 让我们看一下创建比特币地址的完整过程，从私钥到公钥（椭圆曲线上的一个点），再到双重哈希地址，最后是Base58Check编码。Creating a Base58Check-encoded bitcoin address from a private key 中的C++代码显示了完整的过程。代码示例使用了 [alt_libraries] 中介绍的libbitcoin库来提供一些帮助函数。 Example 3. Creating a Base58Check-encoded bitcoin address from a private key link:code/addr.cpp[] 该代码使用预定义的私钥在每次运行时产生相同的比特币地址，如 Compiling and running the addr code 所示。 Example 4. Compiling and running the addr code # Compile the addr.cpp code $ g++ -o addr addr.cpp -std=c++11 $(pkg-config --cflags --libs libbitcoin) # Run the addr executable $ ./addr Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK > Compiling and running the addr code 中的代码从一个压缩的公钥（参见 压缩的公钥）生成了一个比特币地址 (1PRTT...)。如果你使用未压缩的公钥，它会产生不同的比特币地址 (14K1y...). 用 Python 实现密钥和地址 Python中最全面的比特币库 是Vitalik Buterin写的 pybitcointools。在 Key and address generation and formatting with the pybitcointools library中, 我们使用 pybitcointools 函数库 (imported as \"bitcoin\") 以各种格式生成和显示密钥与地址。 Example 5. Key and address generation and formatting with the pybitcointools library link:code/key-to-address-ecc-example.py[] Running key-to-address-ecc-example.py 展示了运行结果。 Example 6. Running key-to-address-ecc-example.py $ python key-to-address-ecc-example.py Private Key (hex) is: 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6 Private Key (decimal) is: 26563230048437957592232553826663696440606756685920117476832299673293013768870 Private Key (WIF) is: 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K Private Key Compressed (hex) is: 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601 Private Key (WIF-Compressed) is: KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S Public Key (x,y) coordinates is: (41637322786646325214887832269588396900663353932545912953362782457239403430124L, 16388935128781238405526710466724741593761085120864331449066658622400339362166L) Public Key (hex) is: 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec↵ 243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176 Compressed Public Key (hex) is: 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec Bitcoin Address (b58check) is: 1thMirt546nngXqyPEz532S8fLwbozud8 Compressed Bitcoin Address (b58check) is: 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3 A script demonstrating elliptic curve math used for bitcoin keys 是另外一个例子，使用椭圆曲线计算的 Python ECDSA 库。 Example 7. A script demonstrating elliptic curve math used for bitcoin keys link:code/ec-math.py[] Installing the Python ECDSA library and running the ec_math.py script shows the output produced by running this script. > Note: A script demonstrating elliptic curve math used for bitcoin keys 使用 os.urandom, 体现了底层操作系统提供的密码学安全的随机数生成器（CSRNG）。警告：根据操作系统的不同，os.urandom 可能无法以足够的安全性，并且可能不适合生成高质量的比特币密钥。 Example 8. Installing the Python ECDSA library and running the ec_math.py script $ # Install Python PIP package manager $ sudo apt-get install python-pip $ # Install the Python ECDSA library $ sudo pip install ecdsa $ # Run the script $ python ec-math.py Secret: 38090835015954358862481132628887443905906204995912378278060168703580660294000 EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380) BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873 高级的密钥和地址 在下面的章节中，我们将看看高级形式的密钥和地址，例如加密私钥，脚本和多重签名地址，虚荣地址和纸钱包。 加密私钥 (BIP-38) 私钥必须保密，但对私钥的“保密性”的需求是在实践中很难实现，因为它与同样重要的 可用性 安全目标相冲突。当你需要备份私钥以避免丢失私钥时，保持私钥私密性更加困难。存储在通过密码加密的钱包中可能是安全的，但该钱包需要备份。有时，用户需要将密钥从一个钱包移动到另一个钱包 - 例如，升级或替换钱包软件。私钥的备份也可能存储在纸张上（请参见纸钱包）或外部存储介质（如USB闪存驱动器）中。但是如果备份本身被盗或丢失怎么办？这些相互冲突的安全目标促成了一种便携式和便捷的加密私钥的标准，这种加密方式可以被许多不同的钱包和比特币客户端理解，通过BIP-38标准化(参见 [appdxbitcoinimpproposals]). BIP-38 提出了一个通用标准，用密码对私钥进行加密，并使用Base58Check对其进行编码，以便它们可以安全地存储在备份介质上，在钱包之间安全地传输，或保存在密钥可能暴露的任何其他情况下。加密标准使用高级加密标准（AES），这是NIST建立的标准，广泛用于商业和军事应用的数据加密实现。 BIP-38加密方案将通常使用WIF编码（前缀为“5”的Base58Check字符串）的比特币私钥作为输入。此外，BIP-38加密方案需要一个密码短语，通常由几个词或一串复杂的字母数字字符组成。BIP-38加密的结果是以前缀+6P+开始的Base58Check加密私钥。如果你看到一个以+6P+开头的密钥，则该密钥是加密的，需要密码才能将其转换（解密）为可用于任何钱包的WIF格式的私钥（前缀+5+）。许多钱包应用程序现在可识别BIP-38加密的私钥，并提示用户输入密码以解密并导入密钥。第三方应用程序，例如非常实用的基于浏览器的应用程序 Bit Address (Wallet Details tab), 可以用来解密BIP-38密钥。 BIP-38加密密钥最常见的用例是可用于备份私钥的纸钱包。只要用户选择强密码，带有BIP-38加密私钥的纸钱包就非常安全，并且是创建离线比特币存储（也称为“冷存储”）的好方法。 使用bitaddress.org测试Example of BIP-38 encrypted private key中的加密密钥，了解如何通过输入密码来获取解密的密钥。 Table 5. Example of BIP-38 encrypted private key Private Key (WIF) 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Passphrase MyTestPassphrase Encrypted Key (BIP-38) 6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ 支付给脚本的哈希（Pay-to-Script Hash，P2SH）和多重签名地址 如我们所知，传统的以数字“1”开头的比特币地址，源自公钥，而公钥又是通过私钥生成的。尽管任何人都可以将比特币发送到“1”地址，但只能通过提供相应的私钥签名和公钥哈希来花费比特币。 以数字“3”开头的比特币地址是支付给脚本的哈希（P2SH）地址，有时被错误地称为多重签名或多重地址。它们将比特币交易的受益人指定为脚本的哈希，而不是公钥的所有者。该功能在2012年1月由BIP-16提出 (参见 [appdxbitcoinimpproposals]), 正在被广泛采用，因为它提供了向地址本身添加功能的机会。与将资金“发送”到传统的“1”比特币地址（也称为付费至公钥的哈希（P2PKH））的交易不同，发送至“3”地址的资金需要的不仅仅是一个公钥哈希和一个私钥签名作为所有权证明。这些要求是创建地址时在脚本中指定的，并且对该地址的所有输入也要按照相同的要求进行设置。 P2SH地址由交易脚本创建，该脚本定义谁可以使用交易的输出（有关更多详细信息，请参见[p2sh]）。对P2SH地址进行编码使用与创建比特币地址时用到的相同的双重哈希函数，只是应用于脚本而不是公钥: script hash = RIPEMD160(SHA256(script)) 生成的“脚本哈希”使用前缀5进行Base58Check编码，导致编码地址以+3+开头。P2SH地址的示例： 3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM, 可以使用Bitcoin Explorer的 script-encode, sha256, ripemd160, 和 base58check-encode 命令（参见 [appdx_bx]) 生成： $ echo \\ 'DUP HASH160 [89abcdefabbaabbaabbaabbaabbaabbaabbaabba] EQUALVERIFY CHECKSIG' > script $ bx script-encode > P2SH不一定与多重签名交易相同。P2SH地址常用来表示多重签名脚本，但它也可能表示其他类型交易的脚本。 多重签名地址与P2SH 目前，P2SH功能最常见的实现是多重签名地址脚本。顾名思义，底层脚本需要多个签名才能证明所有权，才能花费资金。比特币多重签名特征被设计为需要来自总共N个密钥的M个签名（也称为“阈值”），称为M-N多重签名，其中M等于或小于N. 例如，[ch01_intro_what_is_bitcoin] 中的咖啡店老板Bob可以使用一个多重签名地址，要求属于他的一把钥匙和属于他的妻子的一把钥匙中的一个签名，以确保他们中的任何一个签字可以签署锁定到这个地址的一笔交易输出。这与在传统银行中实施的“联名账户”类似，夫妻的任一方都可以花费一个签名。 再例如，网页设计师Gopesh，可能会为其业务提供2/3的多重签名地址，确保除非至少有两个业务合作伙伴签署交易，否则不会花费任何资金。 我们将在 [transactions] 中探讨如何创建花费 P2SH（和多重签名）地址的资金的交易。 虚荣地址（Vanity Addresses） 虚荣地址是包含人类可读信息的有效比特币地址。例如，1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33 是一个有效的地址，其中包含形成单词“Love”的字母作为前四个Base-58字母。虚拟地址需要生成并测试数十亿个候选私钥，直到找到具有所需模式的比特币地址。虽然在虚荣生成算法中有一些优化，但这个过程主要包括随机选择一个私钥，导出公钥，导出比特币地址，并检查它是否符合所需的虚拟模式，重复数十亿次，直到匹配被发现。 一旦找到与所需模式相匹配的虚拟地址，所有者就可以使用从中得到的私钥来并以与其他地址完全相同的方式使用比特币。虚拟地址的安全性不低于其他地址。它们依赖于与其他地址相同的椭圆曲线加密（ECC）和SHA。 在 [ch01_intro_what_is_bitcoin] 中, 我们介绍了在菲律宾开展业务的儿童慈善机构Eugenia。假设Eugenia正在组织比特币筹款活动，并希望使用虚拟比特币地址来宣传筹款活动。Eugenia将创建一个以“1Kids”开头的虚荣地址来宣传儿童慈善筹款活动。让我们看看这个虚荣的地址如何创建，以及它对于Eugenia慈善机构的安全意味着什么。 生成虚荣地址 认识到比特币地址仅仅是Base58字母表中的符号代表的数字很重要。搜索诸如“1Kids”之类的模式可以被视为搜索范围从 1Kids11111111111111111111111111111 到 +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz + 的地址。该范围内的地址约有 5829（约1.4 * 10 ^ 51 ^）个，全部以“1Kids”开头。 [table_4-11 ] 显示了具有前缀1Kids的地址范围。 Table 6. The range of vanity addresses starting with \"1Kids\" From 1Kids11111111111111111111111111111 1Kids11111111111111111111111111112 1Kids11111111111111111111111111113 ... To 1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz 让我们把“1Kids”模式当作数字，看看我们在比特币地址中可能发现这种模式的概率（参见The frequency of a vanity pattern (1KidsCharity) and average search time on a desktop PC）。一台普通的台式电脑个人电脑，没有任何专门的硬件，可以每秒搜索约100000个密钥。 Table 7. The frequency of a vanity pattern (1KidsCharity) and average search time on a desktop PC Length Pattern Frequency Average search time 1 1K 1 in 58 keys 2 1Ki 1 in 3,364 50 milliseconds 3 1Kid 1 in 195,000 4 1Kids 1 in 11 million 1 minute 5 1KidsC 1 in 656 million 1 hour 6 1KidsCh 1 in 38 billion 2 days 7 1KidsCha 1 in 2.2 trillion 3–4 months 8 1KidsChar 1 in 128 trillion 13–18 years 9 1KidsChari 1 in 7 quadrillion 800 years 10 1KidsCharit 1 in 400 quadrillion 46,000 years 11 1KidsCharity 1 in 23 quintillion 2.5 million years 如你所见，即使Eugenia能够访问几千台电脑，也不能很快创建“1KidsCharity”虚拟地址。每增加一个字符都会将难度增加58倍。超过7个字符的模式通常由专用硬件寻找，例如具有多个GPU的定制桌面电脑。这些往往是用于比特币挖矿的“钻井平台”，为比特币不再适合盈利，但可用于找到虚荣地址。GPU系统上的虚度搜索速度比通用CPU上的快很多个数量级。 找到虚荣地址的另一种方法是将工作外包给一个虚荣矿工池，例如 Vanity Pool。这是一项服务，允许那些使用GPU硬件的人为其他人搜索比特币虚拟地址。仅需小额付款（本文写作时为0.01比特币或大约5美元），Eugenia可以将7个字符的模式虚拟地址搜索外包，并在几个小时内获得结果，而不必进行几个月的CPU搜索。 生成虚拟地址是一个暴力搜索：尝试一个随机密钥，检查结果地址以查看它是否与所需模式匹配，重复直到成功。 Vanity address miner 显示了一个“虚荣矿工”的例子，这是一个用C++编写的用于查找虚荣地址的程序。这个例子使用了我们在[alt_libraries]中介绍的libbitcoin库。 Example 9. Vanity address miner link:code/vanity-miner.cpp[] > Note: Compiling and running the vanity-miner example 使用 std::random_device. 根据具体实现不同，它可能反映了底层操作系统提供的CSRNG。在类Unix等操作系统的情况下，它从+/dev/urandom+中提取。这里使用的随机数生成器用于演示目的，它不适合生成生产环境质量要求的比特币密钥，因为它没有足够的安全性来实现。 示例代码必须使用 C ++ 编译器编译并链接libbitcoin库（必须先安装在该系统上）。要运行该示例，请运行不带参数的 vanity-miner 可执行文件（参见Compiling and running the vanity-miner example），它将尝试查找以“1kid”开头的虚拟地址。 Example 10. Compiling and running the vanity-miner example $ # Compile the code with g++ $ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the example $ ./vanity-miner Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f $ # Run it again for a different result $ ./vanity-miner Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623 # Use \"time\" to see how long it takes to find a result $ time ./vanity-miner Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349 real 0m8.868s user 0m8.828s sys 0m0.035s 我们可以看到，我们使用Unix命令 time 来测量执行时间，示例代码需要几秒钟找到三字符模式“kid”的匹配项。更改源代码中的 search 模式并查看四或五个字符模式需要多长时间！ 虚荣地址的安全性 虚荣地址可以用来增强和破坏安全性，它们确实是一把双刃剑。作为提高安全性时，独特的地址使得攻击者难以用自己的地址替代你的地址，并欺骗客户付钱给他们，而不是你。不幸的是，虚荣地址也使得任何人都可以创建一个地址，以便将任何随机地址或甚至另一个虚荣地址重新排列，从而欺骗客户。 Eugenia 可以发布一个随机生成的地址（例如 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy ），人们可以向这个址发送给他们的捐款。或者，她可以生成一个以1Kids开头的虚荣地址，以使其更具特色。 在这两种情况下，使用单个固定地址（而不是为每个捐助者单独生成动态地址）的风险之一是小偷可能渗透你的网站并用自己的地址替换它，从而将捐赠转移给自己。如果你在多个不同的地方刊登了捐款地址，用户可能会在进行付款之前直观地检查地址，以确保它与你的网站，电子邮件和传单上看到的地址相同。像 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 这样的随机地址，普通用户可能会检查前几个字符“1J7mdg”并确认地址匹配。使用虚名地址生成器，想窃取资金的人可以快速生成与前几个字符匹配的地址，如Generating vanity addresses to match a random address所示。 Table 8. Generating vanity addresses to match a random address Original Random Address 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy Vanity (4-character match) 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy Vanity (5-character match) 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n Vanity (6-character match) 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX 那么虚荣的地址是否能增加安全性呢？如果Eugenia生成虚拟地址 1Kids33q44erFfpeXrmDSz7zEqG2FesZEN ，用户可能会查看虚空模式单词 和后续的 的几个字符，例如注意到地址的“1Kids33”部分。这会迫使攻击者产生一个至少匹配六个角色（两个以上）的虚荣地址，花费的努力比Eugenia花费4个字符虚荣心的努力高出3364倍（582）。从根本上说，Eugenia花费的努力（或支付虚荣矿工池）“推动”攻击者必须产生更长的模式虚荣。如果Eugenia支付一个虚荣矿工池产生一个8个字符的虚荣地址，攻击者将被推入10个角色的领域，这在个人计算机上是不可行的，即使使用定制的虚荣采矿装备或虚荣池也很昂贵。对于Eugenia而言，负担得起的东西对于攻击者来说是不可承受的，特别是如果潜在的欺诈收益不足以支付虚荣地址生成的代价。 纸钱包 纸钱包是印在纸上的比特币私钥。通常为方便起见，纸钱包还包括相应的比特币地址，但这不是必须的，因为它可以用私钥生成。纸钱包是创建备份或离线比特币存储（也称为“冷存储”）的非常有效的方式。作为备份机制，纸钱包可以防止由于计算机故障（如硬盘驱动器故障，被盗或意外删除）而导致密钥丢失。作为一种“冷存储”机制，如果纸钱包密钥是离线生成的，永远不会存储在计算机系统中，可以很好的防范黑客，按键记录器和其他在线计算机威胁。 纸钱包可以有许多形状，大小和设计，最基本的只是纸上的密钥和地址。 Simplest form of a paper wallet—a printout of the bitcoin address and private key 展示了纸钱包最简单的形式。 Table 9. Simplest form of a paper wallet—a printout of the bitcoin address and private key Public address Private key (WIF) 1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 例如位于bitaddress.org的客户端JavaScript生成器的工具可以轻松生成纸钱包。此页面包含生成密钥和纸钱包所需的全部代码，即使与互联网完全断开。要使用它，请将HTML页面保存在本地硬盘或外部USB存储上，断开互联网并在浏览器中打开它。更好的是，使用干净的操作系统启动计算机，例如可以从CD-ROM启动的Linux操作系统。离线时使用此工具生成的任何密钥都可以通过USB（非无线）在本地打印机上打印，从而创建纸钱包，其密钥仅存在于纸张上，从未存储在任何在线系统上。将这些纸钱包放入防火保险柜中，并将比特币“发送”至其比特币地址，以实施简单而高效的“冷存储”解决方案。 An example of a simple paper wallet from bitaddress.org 展示了从bitaddress.org网站生成的纸钱包. Figure 8. An example of a simple paper wallet from bitaddress.org 简单纸钱包的缺点是印刷的钥匙容易被盗。能够访问纸张的小偷可以窃取它或拍摄钥匙，即可控制这些钥匙锁定的比特币。更复杂的纸钱包存储系统使用BIP-38加密的私人密钥。纸钱包上印有的钥匙受到由主人记在脑中的密码保护。没有密码，加密的密钥就没用了。纸钱包仍然优于密码保护的钱包，因为密钥从未在线并且必须从安全或其他有物理保护的存储装置中获取。 An example of an encrypted paper wallet from bitaddress.org. The passphrase is \"test.\" 显示在bitaddress.org网站上创建的带有加密私钥（BIP-38）的纸币。 Figure 9. An example of an encrypted paper wallet from bitaddress.org. The passphrase is \"test.\" > Warning: 尽管你可以多次将资金存入纸钱包，但你应该一次性收回所有资金，一次性花费。这是因为在解锁和花费资金的过程中，如果花费少于全部金额，某些钱包可能会生成零钱地址。此外，如果你用来签署交易的计算机受到威胁，可能会泄露私钥。一次性花费纸钱包的全部余额，可以降低密钥泄漏的风险。如果你只需要少量资金，请在一笔交易中将剩余资金发送到一个新的纸钱包中。 纸钱包可以有许多不同的设计和尺寸，和不同的特征。一些用来当作礼物赠送，并具有季节性主题，如圣诞节和新年主题。其他设计用于存放在银行保险库或带有隐藏的密码保护的保险箱中，或者使用不透明的刮擦贴纸，或者使用防篡改粘贴箔折叠和密封。图 #paper_wallet_bpw 到 #paper_wallet_spw 显示具有安全和备份功能的各种纸钱包示例。 Figure 10. An example of a paper wallet from bitcoinpaperwallet.com with the private key on a folding flap Figure 11. The bitcoinpaperwallet.com paper wallet with the private key concealed 其他设计还提供了钥匙和地址的附加副本，形式为与票根类似的可拆卸存根，允许你存储多个副本以防止火灾，洪水或其他自然灾害。 Figure 12. An example of a paper wallet with additional copies of the keys on a backup \"stub\" Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 13:43:57 "},"07第五章.html":{"url":"07第五章.html","title":"钱包","keywords":"","body":"钱包 在比特币中，“钱包”一词用于描述几个不同的东西。 从较高的角度来说，钱包是用户使用的应用程序，控制对用户资金的访问，管理密钥和地址，追踪余额以及创建和签署交易。 更狭义地，从程序员的角度来看，“钱包”一词是指用于存储和管理用户密钥的数据结构。 在本章中，我们将看看第二个含义，即钱包是私钥的容器，通常以结构化文件或简单数据库的形式实现。 钱包技术概述 在本节中，我们总结了用于构建用户友好，安全和灵活的比特币钱包的各种技术。 关于比特币的一个常见误解是比特币钱包包含比特币。实际上，钱包只包含密钥。“比特币”被记录在比特币网络的区块链中。用户通过使用钱包中的密钥签署交易来控制网络上的硬币。从某种意义上说，比特币钱包是一个 密钥串 keychain 。 > 比特币钱包包含钥匙，而不是硬币。每个用户都有一个包含密钥的钱包。钱包真的是包含私钥/公钥的钥匙串 (参见 [private_public_keys]). 用户使用密钥签署交易，从而证明他们拥有交易的输出（他们的比特币）。比特币以交易输出的形式（通常记作vout或txout）存储在区块链中。 根据包含的密钥是否彼此相关划分，主要有两种类型的钱包。 第一种是 非确定性钱包 nondeterministic wallet ，其中每个密钥都是从随机数中独立生成的。密钥不相互关联。这种类型的钱包也被称JBOK钱包（Just a Bunch Of Keys）。 第二种是 确定性钱包 deterministic wallet，其中所有密钥都来自单个主密钥，称为 种子 seed 。这种钱包中的所有密钥都是相互关联的，如果有原始种子，可以再次生成。确定性钱包中使用了许多的 密钥派生 key derivation 方法。 最常用的派生方法使用树状结构，并称为 分层确定性 hierarchical deterministic 钱包或HD钱包。 确定性钱包是从种子初始化的。为了使这些更容易使用，种子被编码为英文单词，也被称为助记词 mnemonic code words 。 接下来的几节将从较高的角度介绍这些技术。 非确定性（随机）钱包 在第一个比特币钱包（现在称为Bitcoin Core）中，钱包是随机生成的私钥集合。例如，Bitcoin Core客户端首次启动时生成100个随机私钥，并根据需要生成更多的密钥，每个密钥只使用一次。这些钱包正在被确定性的钱包取代，因为它们的管理，备份和导入很麻烦。随机密钥的缺点是，如果你生成了很多密钥，你必须保留所有密钥的副本，这意味着钱包必须经常备份。每个密钥都必须备份，否则，如果钱包变得不可用，则其控制的资金将不可撤销地丢失。这与避免地址重用的原则直接冲突，即每个比特币地址仅用于一次交易。地址重用将多个交易和地址相互关联来，会减少隐私。 0型非确定性钱包是穷人的选择，如果你想避免地址重用，就要管理许多密钥，频繁备份。尽管Bitcoin Core客户端包含0型钱包，但Bitcoin Core开发人员不鼓励使用此钱包。 Type-0 nondeterministic (random) wallet: a collection of randomly generated keys 展示了一个非确定性钱包，它包含一个松散的随机密钥集合。 > 除了简单的测试以外，不推荐使用非确定性钱包，备份和使用起来太麻烦了。请使用基于行业标准的有 助记词 HD wallet 进行备份。 Figure 1. Type-0 nondeterministic (random) wallet: a collection of randomly generated keys Deterministic (Seeded) Wallets 确定性的，或“基于种子的”钱包是包含私钥的钱包，这些私钥都是通过使用单向散列函数从公共种子派生的。种子是随机生成的数字，与其他数据（如索引编号或“chain code”（参见分层确定性钱包（HD Wallets）(BIP-32/BIP-44)））组合以导出私钥。在确定性钱包中，种子足以恢复所有的派生密钥，因此在创建时一次备份就足够了。种子对于钱包导出或导入也是足够的，允许在不同的钱包实施之间轻松迁移所有用户的密钥。Type-1 deterministic (seeded) wallet: a deterministic sequence of keys derived from a seed 展示了确定性钱包的逻辑图。 Figure 2. Type-1 deterministic (seeded) wallet: a deterministic sequence of keys derived from a seed 分层确定性钱包（HD Wallets）(BIP-32/BIP-44) 确定性钱包的开发使得从单个“种子”中获得许多密钥变得容易。确定性钱包的最高级形式是由BIP-32标准定义的HD钱包。HD钱包包含以树结构导出的密钥，父密钥可以导出一系列的子密钥，每个子密钥可以导出一系列孙子密钥等等，可达到无限深度。这个树结构在Type-2 HD wallet: a tree of keys generated from a single seed中进行了说明。 Figure 3. Type-2 HD wallet: a tree of keys generated from a single seed 与随机（非确定性）密钥相比，HD钱包具有两大优势。首先，树结构可以用来表达额外的组织含义，例如，使用子密钥的特定分支来接收传入的支付，使用另一个分支来接收支付时的零钱。分支的密钥也可用于组织机构设置，将不同分支分配给部门，子公司，特定功能或会计类别。 HD钱包的第二个优点是用户可以创建一系列公钥而无需访问相应的私钥。这允许HD钱包用于不安全的服务器或仅作为接收用途，为每次交易发出不同的公钥。公钥不需要事先预加载或派生，服务器也没有可以花费资金的私钥。 种子和助记词 (BIP-39) HD钱包是管理许多密钥和地址的非常强大的机制。如果将它们与标准化方式相结合，从一系列易于转录，导出和跨钱包导入的英语单词创建种子，就更加有用。这被称为 助记 ，BIP-39定义了这个标准。今天，大多数比特币钱包（以及用于其他加密货币的钱包）都使用此标准，并且可以使用可互操作的助记词导入和导出种子以进行备份和恢复。 我们实际来看一下。下列哪类种子更易于转录，在纸上记录，无误地读取，导出/导入另一个钱包？ A seed for an deterministic wallet, in hex 0C1E24E5917779D297E14D45F14E1A1A A seed for an deterministic wallet, from a 12-word mnemonic army van defense carry jealous true garbage claim echo media make crunch 钱包最佳实践 随着比特币钱包技术的成熟，出现了一些常见的行业标准，使比特币钱包具有广泛的互操作性，易用性，安全性和灵活性。这些通用标准是： 助记词（mnemonic code words）, 基于BIP-39 分层确定性钱包（HD wallets）, 基于BIP-32 多用途分层确定性结构（Multipurpose HD wallet structure）, 基于BIP-43 多币种和多帐户钱包（Multicurrency and multiaccount wallets），基于BIP-44 这些标准可能会改变或因未来的发展而过时，但现在它们形成了一系列连锁技术，这些技术已成为比特币事实上的钱包标准。 这些标准已被软件和硬件比特币钱包广泛采用，使所有这些钱包可以互操作。用户可以导出其中一个钱包上生成的助记词并将其导入另一个钱包，恢复所有交易，密钥和地址。 支持这些标准的软件钱包的一些例子包括（按字母顺序排列）Breadwallet，Copay，Multibit HD和Mycelium。支持这些标准的硬件钱包的例子包括（按字母顺序列出）Keepkey，Ledger和Trezor。 以下各节详细介绍这些技术。 > 如果你正在实施比特币钱包，则应按照BIP-32，BIP-39，BIP-43和BIP-44标准，将其构建为HD钱包，并将种子编码为助记词用于备份，就像以下章节介绍的那样。 使用比特币钱包 在 [user-stories] 中我们介绍了Gabriel, 一位在里约热内卢的富有进取精神的年轻人，他正在经营一家简单的网上商店，销售比特币品牌的T恤，咖啡杯和贴纸。 Gabriel 使用 Trezor 比特币硬件钱包 (A Trezor device: a bitcoin HD wallet in hardware) 安全地管理他的比特币。Trezor是一个有两个按钮的简单的USB设备，用于存储密钥（以HD钱包的形式） ，签署交易。Trezor钱包实现了本章介绍的所有工业标准，因此Gabriel并不依赖任何专有技术或单一供应商解决方案。 Figure 4. A Trezor device: a bitcoin HD wallet in hardware 当Gabriel首次使用Trezor时，该设备通过内置硬件随机数生成器生成助记符和种子。在这个初始化阶段，钱包在屏幕上逐一显示带有编号的单词序列（参见 Trezor displaying one of the mnemonic words）。 Figure 5. Trezor displaying one of the mnemonic words 记录下助记词，Gabriel可以在他的Trezor设备丢失或损坏时使用备份的助记词进行恢复。这种助记符可以用于新的Trezor设备或任意一个兼容的软件或硬件钱包。请注意，助记词的顺序很重要。 Table 1. Gabriel’s paper backup of the mnemonic 1. army 7. garbage 2. van 8. claim 3. defense 9. echo 4. carry 10. media 5. jealous 11. make 6. true 12. crunch > 为简单起见，在 Gabriel’s paper backup of the mnemonic 中展示了12个助记词。实际上，大多数硬件钱包可以产生更安全的24个助记词。不管长度如何，助记词的使用方式完全相同。 对于第一次网店实践，Gabriel使用Trezor设备上生成的单个比特币地址。所有客户都可以使用这个地址进行所有订单。正如我们将看到的，这种方法有一些缺点，可以通过HD钱包进行改进。 钱包技术细节 现在我们来仔细研究比特币钱包所使用的每个重要行业标准。 助记词（Mnemonic Code Words）(BIP-39) 助记词是表示（编码）用作派生确定性钱包的种子的随机数的一个单词序列。单词序列足以重新创建种子，并重新创建钱包和所有派生的密钥。使用助记词实现确定性钱包的钱包应用会在首次创建钱包时向用户显示12至24个单词的序列。这个单词序列是钱包的备份，可用于在相同或任何兼容的钱包应用中恢复和重新创建所有密钥。与随机数字序列相比，助记词使得用户更容易备份钱包，因为它们易于阅读和正确转录。 > 助记词通常与“大脑钱包（brainwallets）”混淆。他们不一样。主要区别在于大脑钱包由用户选择的单词组成，而助记词由钱包随机创建并呈现给用户。这个重要的区别使助记词更加安全，因为人类是非常贫乏的随机性来源。 助记词在BIP-39中定义（参见[appdxbitcoinimpproposals]）。注意，BIP-39是助记词标准的一个实现。还有一个不同的标准，使用一组不同的词，在BIP-39之前由Electrum钱包使用。 BIP-39由生产Trezor硬件钱包的公司提出，与Electrum不兼容。但是，BIP-39现在已经获得了广泛的行业支持，数十种产品可以互操作，被视为事实上的行业标准。 BIP-39定义了助记词和种子的创建方法，我们通过九个步骤来描述它。为了清楚起见，该过程分为两部分：步骤1至6在 [generate_mnemonic_words] 中，步骤7至9在 从助记符到种子 中。 生成助记词 助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。钱包从一个熵源开始，添加校验和，将熵映射到单词列表： 创建一个128到256位的随机序列（熵）。 通过取其SHA256散列的第一个（熵长度/ 32）位创建随机序列的校验和。 将校验和添加到随机序列的末尾。 将结果拆分为11位长的多个段。 将每个11位值映射到有2048个单词的预定义字典中的一个单词。 助记词就是这些单词的序列。 Generating entropy and encoding as mnemonic words 展示了如何使用熵来生成助记词。 Figure 6. Generating entropy and encoding as mnemonic words Mnemonic codes: entropy and word length 显示了熵数据的大小与助记词的长度之间的关系。 Table 2. Mnemonic codes: entropy and word length Entropy (bits) Checksum (bits) Entropy + checksum (bits) Mnemonic length (words) 128 4 132 12 160 5 165 15 192 6 198 18 224 7 231 21 256 8 264 24 从助记符到种子 助记词表示长度为128到256位的熵。然后使用熵通过使用密钥扩展函数PBKDF2来导出更长的（512位）种子。之后使用生成的种子构建确定性钱包并导出其密钥。 密钥扩展函数需要两个参数：助记词和 盐 salt 。在密钥扩展函数中使用盐的目的是使构建一个查找表并暴力破解难以实现。在BIP-39标准中，盐有另一个目的 - 它允许引入密码，作为保护种子的附加安全因素，我们将在 BIP-39中可选的密码中详细描述。 步骤7到9中描述的过程从 [generated_mnemonic_words] 中的过程继续： PPBKDF2密钥扩展函数的第一个参数是步骤6中产生的 助记词 PPBKDF2密钥扩展函数的第一个参数是 盐（salt） 。盐由字符串 \"mnemonic\" 加上可选的用户提供的密码组成。 PBKDF2使用HMAC-SHA512算法执行2048轮散列来扩展助记词和盐，产生一个512位值，就是种子。 From mnemonic to seed 展示了如何使用助记词来生成种子。 Figure 7. From mnemonic to seed > 密钥扩展方法及其2048轮哈希是一种非常有效的防止对助记词或密码短语攻击的保护。它使得尝试超过几千个密码和助记符组合的成本非常高，而可能派生的种子数量很大（2512）。 表格 #mnemonic_128_no_pass, #mnemonic_128_w_pass, and #mnemonic_256_no_pass 显示一些助记词和他们产生的种子（没有任何密码）的例子。 Table 3. 128-bit entropy mnemonic code, no passphrase, resulting seed Entropy input (128 bits) 0c1e24e5917779d297e14d45f14e1a1a Mnemonic (12 words) army van defense carry jealous true garbage claim echo media make crunch Passphrase (none) Seed (512 bits) 5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39 a88b76373733891bfaba16ed27a813ceed498804c0570 Table 4. 128-bit entropy mnemonic code, with passphrase, resulting seed Entropy input (128 bits) 0c1e24e5917779d297e14d45f14e1a1a Mnemonic (12 words) army van defense carry jealous true garbage claim echo media make crunch Passphrase SuperDuperSecret Seed (512 bits) 3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28ab3ab091897d0 715861dc8a18358f80b79d49acf64142ae57037d1d54 Table 5. 256-bit entropy mnemonic code, no passphrase, resulting seed Entropy input (256 bits) 2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c Mnemonic (24 words) cake apple borrow silk endorse fitness top denial coil riot stay wolf luggage oxygen faint major edit measure invite love trap field dilemma oblige Passphrase (none) Seed (512 bits) 3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3a04356e53d062e5 5f1e0deaa082df8d487381379df848a6ad7e98798404 BIP-39中可选的密码 BIP-39标准允许在派生种子中使用可选的密码。如果没有使用密码，助记词将被一个常量字符串 mnemonic 的盐扩展，产生一个特定的512位种子。如果使用密码短语，则扩展函数会从同一助记符中生成一个 不同的 种子。对于一个助记词，每一个可能的密码都会导致不同的种子。本质上，没有 “错误的” 密码。所有密码都是有效的，会生成不同的种子，形成一大批未初始化的钱包。可能的钱包的集合非常大（2512），因此没有可能暴力破解或意外猜测出正在使用的钱包。 > BIP-39中没有 “错误的” 口令。每个密码都会导致一些钱包，除非以前使用过，钱包将是空的。 可选的密码引入了两个重要功能： 第二重保护，需要记忆的密码使得只获得助记词没有用，避免助记词被盗时的损失。 一种似是而非的拒绝形式或“胁迫钱包”，一个选定的密码会导致进入一个带有少量资金的钱包，用于将攻击者的注意力从有大部分资金的“真实”钱包引开。 但是，要注意使用密码也会导致丢失的风险： 如果钱包所有者无行为能力或死亡，而且没有其他人知道密码，则种子无用，钱包中存储的所有资金都将永久丢失。 相反，如果所有者在与种子相同的位置备份密码，它将失去第二重保护的意义。 虽然密码非常有用，但应该结合精心策划的备份和恢复过程，需要考虑主人是否存活，要允许其家人恢复加密货币资产。 使用助记词 BIP-39有许多不同的编程语言库实现： python-mnemonic 提出BIP-39标准的SatoshiLabs团队用Python写的参考实现 bitcoinjs/bip39 BIP-39的JavaScript实现，是流行的bitcoinJS框架的一部分。 libbitcoin/mnemonic BIP-39的C++实现，是流行的Libbitcoin框架的一部分。 还有一个在网页中实现的BIP-39生成器，这对于测试非常有用。 A BIP-39 generator as a standalone web page 展示了生成助记符，种子和扩展私钥的网页。 Figure 8. A BIP-39 generator as a standalone web page 这个页面 (https://iancoleman.github.io/bip39/) 可以离线或在线访问 通过种子创建HD钱包 HD钱包是由一个 根种子 root seed 创建的，是一个128位，256位或512位的随机数。通常，这个种子是从 助记词 mnemonic 生成的，详见前一节。 HD钱包中的每个密钥都是从这个根种子确定性地派生出来的，这使得可以在任何兼容的HD钱包中从该种子重新创建整个HD钱包。这使得备份，恢复，导出和导入包含数千乃至数百万个密钥的HD钱包变得很容易，只需传输根种子的助记词即可。 创建 主密钥 master keys 和主链码 master chain code 的过程如 Creating master keys and chain code from a root seed 所示。 Figure 9. Creating master keys and chain code from a root seed 将根种子作为 HMAC-SHA512 算法的输入，生成的哈希结果用来生成 主私钥 master private key (m) 和 主链码 master chain code (c)。 然后使用我们在 [pubkey] 中看到的椭圆曲线乘法 m * G 利用主密钥（m）生成相应的主公钥（M）。 主链码（c）用于在从父键创建子键的函数中引入熵，我们将在下一节看到。 子私钥的派生 HD钱包使用 子密钥派生 child key derivation (CKD) 方法从父密钥派生子密钥。 子密钥派生方法基于单向散列函数，该函数结合： 一个父级私钥或公钥 (ECDSA未压缩密钥) 一个称作链码(chain code)的种子（256 bits） 一个索引数字（32 bits） 链码用于向过程中引入确定性随机数据，所以只知道索引和子密钥不足以派生其他子密钥。除非有链码，否则知道一个子钥匙不能找到它的兄弟姐妹。初始链码种子（树的根部）由种子制成，而后续子链码则从每个父链码中导出。 这三项（父密钥，链码和索引）被组合并哈希以生成子键，如下所示。 使用HMAC-SHA512算法将父公钥，链码和索引组合并散列，以产生512位散列。这个512位散列平分为两部分。右半部分256位作为后代的链码，左半部分256位被添加到父私钥以生成子私钥。在 Extending a parent private key to create a child private key 中，我们看到这个例子中的索引设置为0，以产生父项的“零”级（第一个索引）孩子。 Figure 10. Extending a parent private key to create a child private key 更改索引允许我们扩展父项并创建序列中的其他子项，例如Child 0，Child 1，Child 2等。每个父项可以有 2,147,483,647（2 31）个子项（232 范围的一半 231是可用的，另一半保留用于特殊类型的推导，我们将在本章后面讨论）。 在树的下一层重复这个过程，每个孩子都可以成为父项并在无限的世代中创造自己的孩子。 使用派生的子密钥 子私钥与非确定性（随机）密钥没有区别。因为派生函数是单向函数，不能使用子项来寻找父项和寻找任何兄弟姐妹。不能通过第n个子项找到它的兄弟姐妹，如第 n-1 个子项或者第 n+1 个子项，或者任何这个序列上的子项。只能通过父密钥和链码派生所有的孩子。如果没有子链码，子密钥也不能派生任何孙项。你需要子私钥和子链码来启动一个新分支并派生孙项。 那么，子私钥能用来干什么呢？它可以用来制作公钥和比特币地址。然后，它可以用来签署交易，并花费任何支付给该地址的费用。 > 子私钥，相应的公钥和比特币地址都与随机创建的密钥和地址没有区别。在创建它们的HD钱包之外是不知道它们属于一个序列的。一旦创建，就像“普通”键一样工作。 扩展密钥 如我们所见，基于三个输入：密钥，链码和所需子项的索引，可以使用密钥派生函数在树的任何级别创建子项。这两个基本要素是密钥和链式代码，它们的组合称为 扩展密钥 extended key 。也可以认为“扩展密钥”是“可扩展的密钥”，因为这样的密钥可以用来派生孩子。 扩展密钥简单地表示为由256位的密钥和256位的链码串联成的512位序列。有两种类型的扩展密钥：扩展私钥是私钥和链码的组合，可用于派生子私钥（从它们产生子公钥）；扩展公钥是公钥和链码，可用于创建子公钥（ 只有子公钥 ），如 [public_key_derivation] 中所述。 将扩展密钥视为HD钱包树形结构中分支的根。可以通过分支的根，派生出其他分支。扩展私钥可以创建一个完整的分支，而扩展公钥只能创建一个公钥分支。 > 扩展密钥由私钥或公钥和链码组成。扩展密钥可以创建子项，在树结构中生成自己的分支。共享一个扩展密钥可以访问整个分支。 扩展密钥使用Base58Check编码，可以轻松导出导入BIP-32兼容的钱包。扩展密钥的Base58Check编码使用特殊的版本号，当使用Base58字符进行编码时，其前缀为“xprv”和“xpub”，以使其易于识别。因为扩展的密钥是512或513位，所以它比我们以前见过的其他Base58Check编码的字符串要长得多。 这是一个Base58Check编码的扩展私钥： xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c 这是对应的Base58Check编码的扩展公钥： xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9 子公钥派生 如前所述，HD钱包的一个非常有用的特性是能够从父公钥中获得子公钥，而没有私钥。这为我们提供了两种派生子公钥的方法：从子私钥或直接从父公钥获取子公钥。 因此，可以使用扩展公钥，导出HD钱包该分支中的所有 公钥（注意只有公钥）。 此快捷方式可用于创建非常安全的公钥 - 只有部署服务器或应用程序具有扩展公钥的副本，并且没有任何私钥。这种部署可以产生无限数量的公钥和比特币地址，但无法花费发送到这些地址的任何资金。与此同时，在另一个更安全的服务器上，扩展私钥可以导出所有相应的私钥来签署交易并花费金钱。 这个解决方案的一个常见应用是在提供电子商务应用程序的Web服务器上安装扩展公钥。网络服务器可以使用公钥导出函数来为每个交易（例如，为顾客购物车）创建新的比特币地址。 Web服务器上不会有任何易被盗的私钥。没有HD钱包，唯一的方法就是在单独的安全服务器上生成数千个比特币地址，然后将其预先加载到电子商务服务器上。这种方法很麻烦，需要不断的维护以确保电子商务服务器不会“用完”密钥。 另一个常见应用是用于冷存储或硬件钱包。在这种情况下，扩展私钥可以存储在纸钱包或硬件设备（如Trezor硬件钱包）上，而扩展公钥可以保持在线。用户可以随意创建“接收”地址，而私钥可以安全地在离线状态下存储。为了花费资金，用户可以在离线签名比特币客户端使用扩展私钥签名，或在硬件钱包设备上签名交易（例如Trezor）。 Extending a parent public key to create a child public key 演示了用扩展父公钥派生子公钥的机制。 Figure 11. Extending a parent public key to create a child public key 在网店中使用扩展公钥 让我们看看如何使用HD钱包继续Gabriel的网上商店故事。 Gabriel 首先出于爱好建立了他的网上商店，基于简单的Wordpress。他的商店非常简单，只有几个页面和有一个比特币地址的下单表单。 Gabriel 使用他的Trezor设备生成的第一个比特币地址作为他的商店的主要比特币地址。这样，所有收到的付款都将支付给他的Trezor硬件钱包所控制的地址。 客户将使用表单提交订单并将支付款项发送至Gabriel发布的比特币地址，触发一封电子邮件，其中包含Gabriel要处理的订单详情。每周只有几个订单，这个系统运行得很好。 然而，这家小型网上商店变得非常成功，吸引了当地的许多订单。不久，Gabriel 便不知所措了。由于所有订单都支付相同的地址，很难正确匹配订单和交易，尤其是当同一数量的多个订单紧密结合在一起时。 Gabriel 的 HD 钱包通过在不知道私钥的情况下派生子公钥的能力提供了更好的解决方案。Gabriel 可以在他的网站上加载一个扩展公钥（xpub），用来为每个客户订单派生一个唯一的地址。Gabriel 可以从他的Trezor花费资金，但在网站上加载的 xpub 只能生成地址并获得资金。HD钱包的这个特点是一个很好的安全功能。Gabriel 的网站不包含任何私钥，因此不需要高度的安全性。 Gabriel将Web软件与Trezor硬件钱包一起使用导出xpub。必须插入Trezor设备才能导出公钥。请注意，硬件钱包永远不会导出私钥 —— 这些密钥始终保留在设备上。 Exporting an xpub from a Trezor hardware wallet 展示了Gabriel用于导出xpub的Web界面。 Figure 12. Exporting an xpub from a Trezor hardware wallet Gabriel将 xpub 复制到他的网上商店的比特币商店软件中。并使用 Mycelium Gear ，这是一个开源的网上商店插件，用于各种网站托管和内容平台。 Mycelium Gear使用 xpub 为每次购买生成一个唯一的地址。 强化的子密钥派生 从 xpub 派生公钥的分支是非常有用的，但有潜在的风险。访问 xpub 不会访问子私钥。但是，因为 xpub 包含链码，所以如果某个子私钥已知，或者以某种方式泄漏，则可以与链式代码一起使用，派生所有其他子私钥。一个泄露的子私钥和一个父链码可以生成所有其他的子私钥。更糟的是，可以使用子私钥和父链码来推导父私钥。 为了应对这种风险，HD钱包使用一种称为 hardened derivation 的替代派生函数，该函数“破坏”父公钥和子链码之间的关系。强化派生函数使用父私钥来派生子链码，而不是父公钥。这会在父/子序列中创建一个“防火墙”，链码不能危害父级或同级的私钥。父私钥替代父公钥作为散列函数的输入，强化后的派生函数看起来与正常的子私钥派生几乎相同，如 Hardened derivation of a child key; omits the parent public key 中的图所示。 Figure 13. Hardened derivation of a child key; omits the parent public key 当使用强化的私有派生函数时，生成的子私钥和链码与正常派生函数所产生的完全不同。由此产生的“分支”密钥可用于生成不易受攻击的扩展公钥，因为它们所包含的链码不能用于揭示任何私钥。因此，强化派生用于在继承树上使用扩展公钥的级别之上创建“屏障”。 简而言之，如果你想使用 xpub 的便利性来派生分支公钥，而不想面临泄漏链码的风险，应该从强化的父项派生。作为最佳实践，主密钥的1级子密钥始终使用强化派生，以防止主密钥受到破坏。 常规派生与强化派生的索引号 在派生函数中使用的索引号是一个32位整数。为了便于区分通过常规推导函数派生的密钥与通过强化派生派生的密钥，该索引号分为两个范围。 0到231 - 1（0x0到0x7FFFFFFF）之间的索引号仅用于常规推导。 231 和 232 - 1（0x80000000到0xFFFFFFFF）之间的索引号仅用于硬化派生。因此，如果索引号小于231，则子密钥是常规的，而如果索引号等于或大于 231，则子密钥是强化派生的。 为了使索引号码更容易阅读和显示，强化子密钥的索引号从零开始显示，但带有一个符号。第一个常规子密钥表示成0，第一个强化子秘钥（ 索引号是 0x80000000 ）表示成0'。以此类推，第二个强化子密钥（ 0x80000001 ) 表示成1'。当你看到HD钱包索引i’时，它表示231+i. HD钱包密钥标识符 (path) HD钱包中的密钥使用“路径(path)”命名约定来标识，树的每个级别都用斜杠（/）字符分隔（请参见 HD wallet path examples）。从主密钥派生的私钥以“m”开头。从主公钥派生的公钥以“M”开始。因此，主私钥的第一个子私钥为 m/0。第一个子公钥是 M/0。第一个子私钥的第二个子私钥是 m/0/1，依此类推。 从右向左读取一个密钥的“祖先”，直到到达派生出它的主密钥。例如，标识符 m/x/y/z 描述了私钥 m/x/y 的第z个子私钥，m/x/y 是私钥 m/x 的第y个子私钥，m/x 是 m 的第x个子私钥。 Table 6. HD wallet path examples HD path Key described m/0 The first (0) child private key from the master private key (m) m/0/0 The first grandchild private key from the first child (m/0) m/0'/0 The first normal grandchild from the first hardened child (m/0') m/1/0 The first grandchild private key from the second child (m/1) M/23/17/0/0 The first great-great-grandchild public key from the first great-grandchild from the 18th grandchild from the 24th child HD钱包的树状结构导航 HD钱包的树状结构提供了巨大的灵活性。每个父级扩展密钥的可以有40亿个子密钥：20个常规子密钥和20亿强化子密钥。这些子密钥中的每一个又可以有另外40亿子密钥。这棵树像你想要的一样深，有无限的世代。然而，这些灵活性，导致在这个无限树中导航变得非常困难。在不同实现之间转移HD钱包尤其困难，因为内部分支和子分支的可能性是无穷无尽的。 有两个BIP为HD钱包的树状结构提出了一些建议的标准，为这种复杂性提供解决方案。BIP-43建议使用第一个强化子索引作为表示树状结构“用途”的特殊标识符。基于BIP-43，HD钱包应该只使用树的一个1级分支，索引号通过定义其用途来标识树的其余部分的结构和名称空间。例如，仅使用分支 m/i'/ 的HD钱包表示特定用途，用途由索引号“i”标识。 BIP-44在BIP-43下提出了一个多帐户结构作为“用途”号码 44' 。所有遵守BIP-44的HD钱包通过仅使用树的一个分支来体现：m/44'/。 BIP-44定义了包含五个预定义树级的结构： m / purpose' / coin_type' / account' / change / address_index 第一级 “用途” 始终设置为 44'，第二级 “coin_type” 表示加密货币的类型，以支持多货币HD钱包，其中每种货币在第二级下具有其自己的子树。现在定义了三种货币：比特币是 m/44'/0'，比特币测试网是m/44'/1'，莱特币（Litecoin）是 m/44'/2'。 树的第三层是“帐户”，允许用户将他们的钱包细分为单独的逻辑子帐户，以用于会计或组织目的。例如，一个HD钱包可能包含两个比特币“账户”：m/44'/0'/0' 和 m/44'/0'/1'。每个帐户都是自己的子树的根。 在第四层，“零钱”，HD钱包有两个子树，一个用于创建接收地址，另一个用于创建零钱地址。请注意，虽然以前的层级使用强化派生，但此层级使用常规派生。这是为了允许树的这个级别导出扩展的公钥以供在不安全的环境中使用。“地址_索引”由HD钱包的第四级派生，也就是第五级。例如，主账户中比特币支付的第三个接收地址为 M/44'/0'/0'/0/2。 BIP-44 HD wallet structure examples 显示了几个例子。 Table 7. BIP-44 HD wallet structure examples HD path Key described M/44'/0'/0'/0/2 主要比特币账户的第三个接收地址公钥 M/44'/0'/3'/1/14 第四个比特币帐户的第十五个零钱地址公钥 m/44'/2'/0'/0/1 Litecoin主账户中的第二个私钥，用于签署交易 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 14:13:56 "},"08第六章.html":{"url":"08第六章.html","title":"交易","keywords":"","body":"交易 简介 交易是比特币系统中最重要的部分。比特币中其他的一切都旨在确保交易可以创建，传播，验证并最终添加到交易（区块链）的全球总账中。交易是对比特币系统参与者之间的价值转移进行编码的数据结构。每笔交易都是比特币区块链中的公开条目，即全球复式簿记分类账。 在本章中，我们将检查各种形式的交易，它们包含的内容，如何创建它们，如何验证以及它们如何成为所有交易永久记录的一部分。当我们在本章中使用术语“钱包”时，我们指的是构建交易的软件，而不仅仅是密钥的数据库。 交易详情 在 [ch02_bitcoin_overview] 中，我们使用区块浏览器查看了Alice在Bob的咖啡店购买咖啡的交易（ Alice’s transaction to Bob’s Cafe ）。 区块浏览器显示一个从Alice的“地址”到Bob的“地址”的交易。这是交易中包含的内容的简化视图。事实上，我们将在本章中看到，大部分信息都是由区块浏览器构建的，实际上并不在交易中。 Figure 1. Alice’s transaction to Bob’s Cafe 交易背后 实际的交易看起来与典型的区块浏览器提供的非常不同。实际上，我们在各种比特币应用界面中看到的高层次结构 并不实际存在于 比特币系统中。 我们可以使用Bitcoin Core的命令行界面（ getrawtransaction 和 decoderawtransaction ）来检索Alice的“原始”交易，对其进行解码并查看它包含的内容。结果如下所示： Alice’s transaction decoded { \"version\": 1, \"locktime\": 0, \"vin\": [ { \"txid\": \"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\" : \"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\", \"sequence\": 4294967295 } ], \"vout\": [ { \"value\": 0.01500000, \"scriptPubKey\": \"OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG\" }, { \"value\": 0.08450000, \"scriptPubKey\": \"OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\", } ] } 你可能只注意到有关此次交易的几个信息，大多数信息缺失了！Alice的地址在哪里？Bob的地址在哪里？ Alice发送的0.1输入在哪里？在比特币中，没有硬币，没有发送者，没有接收者，没有余额，没有帐户，也没有地址。所有这些东西都是在更高层次上构建的，以使事情更易于理解。 你可能会注意到很多奇怪的，难以辨认的字段和十六进制字符串。别担心，我们将在本章中详细解释每个字段。 交易的输出和输入 比特币交易的基本构建块是 交易的输出 transaction output 。交易输出是不可分割的比特币货币，记录在区块链中，被整个网络识别为有效的。比特币完整节点跟踪所有可用和可花费的输出，称为 未花费的交易输出 unspent transaction outputs 或 UTXO 。所有UTXO的集合被称为 UTXO set ，目前有数以百万的UTXO。UTXO集的大小随着新UTXO的增加而增长，并在UTXO被消耗时缩小。每个交易都表示UTXO集中的更改（状态转移）。 当我们说用户的钱包“收到”比特币时，意思是钱包检测到一个可以使用该钱包控制的密钥来花费的UTXO。因此，用户的比特币“余额”是用户钱包可以花费的所有UTXO的总和，可以分散在数百个交易和数百个块中。余额的概念是由钱包应用创建的。钱包扫描区块链并将钱包可以使用它的密钥花费的任何UTXO汇总计算用户的余额。大多数钱包维护数据库或使用数据库服务来存储它们可以花费的所有UTXO的快照。 一个交易输出可以有一个任意的（整数）等于satoshis倍数的值作为。正如美元可以分为小数点后两位数字一样，比特币可以被分为小数点后八位，作为satoshis。尽管输出可以具有任意值，但一旦创建就是不可分割的。这是需要强调的输出的一个重要特征：输出是 不连续的 和 不可分割的 的价值，以整数satoshis为单位。未使用的输出只能由交易全部花费。 如果UTXO大于交易的期望值，它仍然必须全部使用，并且必须在交易中生成零钱。换句话说，如果你有一个价值20比特币的UTXO，并且只需要支付1比特币，那么你的交易必须消费整个20比特币的UTXO，并产生两个输出：一个支付1比特币给你想要的收款人，另一个支付19比特币回到你的钱包。由于交易输出的不可分割性，大多数比特币交易将不得不产生零钱。 想象一下，一个购物者购买了1.50美元的饮料，并试图从她的钱包找到硬币和钞票的组合，以支付1.50美元。如果可能，购物者将找到正好的零钱，例如，一美元钞票和两个二十五分硬币（0.25美元），或小面值（六个二十五分硬币）的组合；或者，直接向店主支付5美元，她会得到3.50美元的找零，放回她的钱包并且可用于未来的交易。 同样，比特币交易必须从用户的UTXO创建，无论用户有什么样的面额。用户无法将UTXO削减一半，就像不能将美元分成两半使用一样。用户的钱包应用通常会从用户的可用UTXO中进行选择，使组合的金额大于或等于期望交易金额。 与现实一样，比特币应用可以使用多种策略来满足支付需求：合并几个较小的单位，找到正好的零钱，或者使用比交易价值更大的单元并进行找零。所有这些花费UTXO的复杂操作都由用户的钱包自动完成，对用户不可见。只有在编写程序构建来自UTXO的原始交易时才有意义。 交易消耗先前记录的未使用的交易输出，并创建可供未来交易使用的新交易输出。这样，大量的比特币价值通过创建UTXO的交易链在所有者之间转移。 输出和输入链的例外是称为 币基 coinbase 交易的特殊类型的交易，它是每个块中的第一个交易。这笔交易由“获胜”的矿工设置，创建全新的比特币并支付给该矿工作为挖矿奖励。此特殊的coinbase交易不消费UTXO，相反，它有一种称为“coinbase”的特殊输入类型。这就是比特币在挖矿过程中创造的货币数量，正如我们将在 [minig] 中看到的那样。 > 先有的什么？输入还是输出？鸡还是鸡蛋？严格地说，输出是第一位的，因为产生新比特币的币基交易没有输入，是凭空产生的输出。 交易输出 每笔比特币交易都产生输出，这些输出记录在比特币账本上。除了一个例外（参见 [op_return] ），几乎所有这些输出都创造了称为UTXO的可支付的比特币，由整个网络认可并可供所有者在未来的交易中花费。 每个完整节点比特币客户端都跟踪UTXO。新交易消耗（花费）UTXO集合的一个或多个输出。 交易输出由两部分组成: 一些比特币，最小单位为 聪 satoshis 定义了花费这些输出所需条件的加密谜题 这个谜题也被称为 锁定脚本 locking script ，见证脚本 witness script ，或者 scriptPubKey。 在 交易脚本和脚本语言 中详细讨论了前面提到的锁定脚本中使用的交易脚本语言。 现在，我们来看看Alice的交易（ 交易背后 ），看看我们是否可以识别输出。在JSON编码中，输出位于名为 vout 的数组（列表）中： \"vout\": [ { \"value\": 0.01500000, \"scriptPubKey\": \"OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG\" }, { \"value\": 0.08450000, \"scriptPubKey\": \"OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\", } ] 如你所见，该交易包含两个输出。每个输出由一个值和一个加密谜题定义。在Bitcoin Core显示的编码中，该值以比特币为单位，但在交易本身中，它被记录为以satoshis为单位的整数。每个输出的第二部分是设置消费条件的加密谜题。 Bitcoin Core将其显示为 scriptPubKey 并展示了该脚本的人类可读的表示。 锁定和解锁UTXO的主题将在稍后的 创建脚本 ( 锁定 + 解锁 ) 中讨论。在 交易脚本和脚本语言 中讨论了 scriptPubKey 中使用的脚本语言。但在深入研究这些话题之前，我们需要了解交易输入和输出的总体结构。 交易序列化 —— 输出 当交易通过网络传输或在应用程序之间交换时，它们是 序列化 的。序列化是将数据结构的内部表示转换为可以一次传输一个字节的格式（也称为字节流）的过程。序列化最常用于对通过网络传输或存储在文件中的数据结构进行编码。交易输出的序列化格式展示在 Transaction output serialization 中。 Table 1. Transaction output serialization Size Field Description 8 字节 (小端序） 数量 Amount 以聪（satoshis = 10-8 bitcoin) 为单位的比特币价值 1——9 字节 (VarInt) 锁定脚本的大小 Locking-Script Size 后面的锁定脚本的字节数 变量 锁定脚本 Locking-Script 定义花费该输出的条件的脚本 大多数比特币库和框架在内部不以字节流的形式存储交易，因为每次需要访问单个字段时都需要进行复杂的解析。为了方便和易读，比特币库在数据结构（通常是面向对象的结构）中存储交易。 从交易的字节流表示转换为库的内部表示数据结构的过程称为 反序列化 deserialization 或 交易解析 transaction parsing 。转换回字节流以通过网络进行传输，进行哈希或存储在磁盘上的过程称为 序列化 serialization。大多数比特币库具有用于交易序列化和反序列化的内置函数。 看看你是否可以从序列化的十六进制形式手动解码Alice的交易，找到我们以前看到的一些字段。两个输出部分在 Alice’s transaction, serialized and presented in hexadecimal notation 中突出显示： Example 1. Alice’s transaction, serialized and presented in hexadecimal notation 0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73 4d2804fe65fa35779000000008b483045022100884d142d86652a3f47 ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039 ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84 16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1 7b4a10fa336a8d752adfffffffff0260e31600000000001976a914ab6 8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000 1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac 00000000 这里有一些提示: 突出显示的部分有两个输出，每个输出按照 Transaction output serialization 所示进行了序列化。 0.015比特币是1,500,000聪. 十六进制表示为 16 e3 60 . 在序列化的交易中，16 e3 60 以小端序（低位字节在前）编码，所以看起来是： 60 e3 16。 scriptPubKey 的长度是 25 字节, 十六进制表示为 19 。 交易输入 交易输入标识（通过引用）将使用哪个UTXO并通过解锁脚本提供所有权证明。 为了建立交易，钱包从其控制的UTXO中选择具有足够价值的UTXO进行所请求的付款。有时候一个UTXO就足够了，有时候需要多个UTXO。对于将用于进行此项付款的每个UTXO，钱包将创建一个指向UTXO的输入，并使用解锁脚本将其解锁。 让我们更详细地看看输入的组成部分。输入的第一部分是指向UTXO的指针，引用交易的哈希值和输出索引，该索引标识该交易中特定的UTXO。第二部分是一个解锁脚本，由钱包构建，为了满足UTXO中设置的花费条件。大多数情况下，解锁脚本是证明比特币所有权的数字签名和公钥。但是，并非所有解锁脚本都包含签名。第三部分是序列号，稍后将进行讨论。 考虑 交易背后 中的示例，交易的输出是 vin 数组: The transaction inputs in Alice’s transaction \"vin\": [ { \"txid\": \"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\" : \"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\", \"sequence\": 4294967295 } ] 如你所见，列表中只有一个输入（因为这个UTXO包含足够的值来完成此次付款）。输入包含四个元素： 交易ID，引用包含正在使用的UTXO的交易 输出索引（ vout ），标识使用来自该交易的哪个UTXO（第一个从0开始） scriptSig，满足UTXO上的条件的脚本，用于解锁并花费 一个序列号（后面讨论） 在Alice的交易中，输入指向交易ID： 7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18 输出索引 0（即由该交易创建的第一个UTXO）。解锁脚本由Alice的钱包构建，首先检索引用的UTXO，检查其锁定脚本，然后使用它构建必要的解锁脚本以满足它。 只看输入内容，你可能已经注意到我们对这个UTXO一无所知，只有对包含它的交易的引用。我们不知道它的价值（satoshi的数量），也不知道设置花费条件的锁定脚本。要找到这些信息，我们必须通过检索底层交易来检索引用的UTXO。请注意，因为输入值没有明确说明，我们还必须使用引用的UTXO来计算将在此次交易中支付的费用（请参见 交易费用 ）。 不仅Alice的钱包需要检索输入中引用的UTXO。一旦这个交易被广播到网络中，每个验证节点也将需要检索在交易输入中引用的UTXO以验证交易。 这些交易本身似乎不完整，因为它们缺乏上下文。他们在其输入中引用UTXO，但不检索该UTXO，我们不知道输入值或锁定条件。在编写比特币软件时，只要你想要验证交易，计算费用或检查解锁脚本，你的代码首先必须从区块链中检索引用的UTXO，以便构建输入中引用的UTXO隐含但不包括的上下文。例如，要计算支付的费用金额，你必须知道输入和输出值的总和。如果不检索输入中引用的UTXO，则不知道它们的价值。因此，像单笔交易中计费的看似简单的操作实际上涉及多个交易的多个步骤和数据。 我们可以使用在检索Alice的交易时使用的相同的Bitcoin Core命令序列（ getrawtransaction 和 decoderawtransaction ）。得到前面输入中引用的UTXO： Alice’s UTXO from the previous transaction, referenced in the input \"vout\": [ { \"value\": 0.10000000, \"scriptPubKey\": \"OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\" } ] 我们看到这个UTXO的值为 0.1 BTC，包含一个锁定脚本（ scriptPubKey ）： \"OP_DUP OP_HASH160…\". > 为了完全理解Alice的交易，我们必须检索输入引用的交易。几乎每个比特币库和API中都有一个函数，用于检索以前的交易和未使用的交易输出。 交易序列化 —— 输入 当交易被序列化以便在网络上传输时，它们的输入被编码为字节流，如 Transaction input serialization 所示。 Table 2. Transaction input serialization Size Field Description 32 字节 交易的哈希值 Transaction Hash 指向包含要花费的UTXO的交易的指针 4 字节 输出的索引 Output Index 要花费的UTXO的索引，从0开始 1——9 字节 (VarInt) 解锁脚本的大小 Unlocking-Script Size 后面的解锁脚本的字节长度 变量 解锁脚本 Unlocking-Script 满足UTXO锁定脚本条件的脚本 4 字节 序列号 Sequence Number 用于锁定时间（locktime）或禁用 (0xFFFFFFFF) 与输出一样，看看是否能够在序列化格式中查找来自Alice的交易的输入。首先，解码的输入如下： \"vin\": [ { \"txid\": \"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\" : \"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\", \"sequence\": 4294967295 } ], 现在，看看我们是否可以在 Alice’s transaction, serialized and presented in hexadecimal notation 中的序列化的十六进制编码中识别这些字段： Example 2. Alice’s transaction, serialized and presented in hexadecimal notation 0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73 4d2804fe65fa35779000000008b483045022100884d142d86652a3f47 ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039 ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84 16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1 7b4a10fa336a8d752adfffffffff0260e31600000000001976a914ab6 8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000 1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000 000 提示: 交易ID是以反向字节顺序序列化的，因此它以（十六进制）18 开头并以 79 结尾 输出索引是一个4字节的零，容易识别 scriptSig 的长度为139个字节，十六进制的 8b 序列号设置为 FFFFFFFF，也易于识别 交易费用 大多数交易包括交易费用，以奖励比特币矿工，保证网络安全。费用本身也可以作为一种安全机制，因为攻击者通过大量交易充斥网络在经济上是不可行的。 [mining] 更详细地讨论了矿工以及矿工收取的费用和奖励。 本节探讨交易费用如何包含在典型的交易中。大多数钱包会自动计算并包含交易费用。但是，如果你以编程方式构建交易或使用命令行界面，则必须手动进行计算并包含这些费用。 交易费用是将交易纳入下一个区块的激励措施，也是对每次交易征收小额费用以抵制系统滥用的防范机制。交易费由矿工收集，该矿工将开采在区块链上记录交易的区块。 交易费用是以交易数据的大小（KB）计算的，而不是比特币交易的价值。总体而言，交易费用是根据比特币网络内的市场力量设定的。矿工根据许多不同的优先条件（包括费用）处理交易，也可能在某些情况下免费处理交易。交易费用会影响处理优先权，这意味着如果交易费用足够，交易就可能包含在下一个开采区块中，而费用不足或不收费的交易可能会延迟，在几个区块后以尽力而为的方式处理，或者根本不处理。交易费用不是强制性的，没有费用的交易最终可以被处理；但是，包括交易费用鼓励优先处理。 随着时间的推移，交易费用的计算方式以及它们对交易优先级的影响已经发生了变化。起初，交易费用在整个网络中是固定不变的。逐渐地，收费结构放松，并可能受到基于网络容量和交易量的市场力量的影响。至少从2016年初开始，比特币的容量限制已经造成了交易之间的竞争，导致了更高的费用，使免费的交易成为了历史。免费或低费用的交易很少能被开采，有时甚至不会通过网络传播。 在Bitcoin Core中，收费中继策略由 minrelaytxfee 选项设置。当前的默认值是每KB数据0.00001比特币或0.01毫比特币。因此，默认情况下，低于0.00001比特币的交易将被视为免费，并且只在内存池有空间时才会被中转；否则，它们将被丢弃。比特币节点可以通过调整 minrelaytxfee 的值来覆盖默认的收费中继策略。 任何创建交易的比特币服务，包括钱包，交易所，零售应用等，都 必须 实施动态费用。动态费用可以通过第三方费用估算服务或内置费用估算算法来实现。如果你不确定，请先从第三方服务开始，如果你希望移除第三方依赖关系，设计并实现自己的算法。 费用估算算法根据容量和“竞争”交易提供的费用计算适当的费用。这些算法的从简单（最后一个区块的平均费用或中值费用）到复杂（统计分析）。他们估计必要的费用（每字节多少satoshis），使交易被选中并包含在一定数量的区块内的可能性很高。大多数服务为用户提供选择高，中，低优先级费用的选项。高优先级意味着用户支付更高的费用，但交易很可能包含在下一个区块中。中等和低优先级意味着用户支付较低的交易费用，但交易可能需要更长时间才能确认。 许多钱包应用使用第三方服务计算费用。一种流行的服务是 http://bitcoinfees.21.co，它提供了一个API和一个可视图表，显示了不同优先级的 satoshi/字节 费用。 > 比特币网络上的固定费用已不再可行。设置固定费用的钱包将产生糟糕的用户体验，因为交易通常会“卡住”，不被验证。不了解比特币交易和费用的用户会因为“停滞的”交易感到沮丧，他们会认为钱已经丢失了。 Fee estimation service bitcoinfees.21.co 中的图表以10 satoshi/字节的增量显示实时的费用估算值，以及每个费用范围内的预期确认时间（以分钟和块数表示）。对于每个费用范围（例如，61-70 satoshi/字节），两个横条显示了未确认交易的数量（1405）和过去24小时内的交易总数（102,975）。根据图表，此时建议的高优先级费用为 80 satoshi /字节，可能使交易在下一个区块中开采（0块延迟）。交易规模的中位数为226字节，所以此交易规模的建议费用为 18,080 satoshis（0.00018080 BTC）。 费用估算数据可以通过简单的HTTP REST API检索， https://bitcoinfees.21.co/api/v1/fees/recommended. 例如，在命令行中使用 curl 命令： Using the fee estimation API $ curl https://bitcoinfees.21.co/api/v1/fees/recommended {\"fastestFee\":80,\"halfHourFee\":80,\"hourFee\":60} API返回一个带有当前费用估计的JSON对象，包含最快速度确认（ fasterFee ），三个块内确认（ halfHourFee ）和六个块内确认（ hourFee ）的费用，单位是 satoshi/字节。 Figure 2. Fee estimation service bitcoinfees.21.co 将费用添加到交易 交易的数据结构没有费用字段。相反，费用隐含表示为输入总和与输出总和的差额。从所有输入中扣除所有输出后剩余的金额都是矿工收取的费用： Transaction fees are implied, as the excess of inputs minus outputs: Fees = Sum(Inputs) – Sum(Outputs) 这是一个有点令人困惑的交易元素，也是需要理解的重要一点，因为如果你正在构建自己的交易，则必须确保你不会花费了很少的输入却无意中包含非常高的费用。这意味着你必须考虑所有输入，必要时创建找零，否则最终会给矿工一个非常高的小费！ 例如，如果你使用20比特币UTXO进行1比特币支付，则必须将19比特币零钱输出回你的钱包。否则，19比特币将被算作交易费用，并将由矿工在一个区块中进行交易。虽然你会得到优先处理并让矿工很高兴，但这可能不是你想要的。 > 如果你忘记在手动构建的交易中添加找零输出，则你将支付零钱作为交易费用。 “不用找了！” 可能不是你想要的。 我们再来看看Alice购买咖啡的情况，看看它在实践中是如何运作的。爱丽丝想花0.015比特币来买咖啡。为确保此交易得到及时处理，她希望包含交易费用，例如0.001。这意味着交易的总成本将是0.016。她的钱包因此必须提供一些UTXO，加起来0.016比特币或更多，如有必要，可以创建找零。假设她的钱包有一个0.2比特币的UTXO。因此，它需要消费这个UTXO，创建一个给Bob 0.015的输出，和一个0.184比特币的零钱输出，返回她自己的钱包，剩下0.001比特币未分配，作为隐含的交易费用。 现在让我们看看不同的场景。菲律宾的儿童慈善总监Eugenia已经完成了为儿童购买教科书的筹款活动。她收到了来自世界各地的数千人的小额捐款，共计50比特币，所以她的钱包充满了非常多的小额未使用输出（UTXO）。现在她想从本地出版商处购买数百本教科书，用比特币支付。 Eugenia的钱包应用试图构建一个较大的付款交易，因此它必须从可用的小金额UTXO集合中获取资金。这意味着由此产生的交易将有超过一百个小型UTXO输入，只有一个输出支付给书籍出版商。具有许多输入的交易将大于一千字节，也许几千字节大小。因此，它需要比中等规模交易高得多的费用。 Eugenia的钱包应用程序将通过衡量交易规模并将其乘以每千字节的费用来计算适当的费用。许多钱包会为较大的交易多付费用，以确保交易得到及时处理。较高的费用并不是因为Eugenia花费更多的钱，而是因为她的交易规模更大更复杂 - 收费与交易的比特币价值无关。 交易脚本和脚本语言 比特币交易脚本语言，称为 Script ，是一种类似Forth的逆波兰表示法的基于堆栈的执行语言。如果这听起来像是胡言乱语，那么你可能没有研究过60年代的编程语言，但没关系 - 我们将在本章中解释它。放置在UTXO上的锁定脚本和解锁脚本都是用这种脚本语言编写的。当一个交易被验证时，每个输入中的解锁脚本将与相应的锁定脚本一起执行，以查看它是否满足花费条件。 脚本是一种非常简单的语言，在有限的范围内设计，可在一系列硬件上执行，可能与嵌入式设备一样简单。它只需要很少的处理，并且不能完成许多现代编程语言能够做的事情。为了用于验证可编程的金钱，这是一个深思熟虑的安全特性。 今天，大多数通过比特币网络处理的交易具有“支付给Bob的比特币地址”的形式，并且基于称为 Pay-to-Public-Key-Hash（付费到公钥哈希） 的脚本。但是，比特币交易不限于“支付给Bob的比特币地址”类型的脚本。事实上，可以编写锁定脚本来表达各种复杂的条件。为了理解这些更复杂的脚本，我们必须首先了解交易脚本和脚本语言的基础知识。 在本节中，我们将演示比特币交易脚本语言的基本组件，并说明如何使用它来表达简单的花费条件以及解锁脚本如何满足这些条件。 > 比特币交易验证不是基于静态模式的，而是通过执行脚本语言来实现的。这种语言允许表示几乎无限的各种条件。这就是比特币如何获得“可编程金钱”力量的。 图灵不完备 比特币交易脚本语言包含许多操作符，但是故意在一个重要方面进行了限制 - 除了条件控制外，没有循环或复杂的流程控制功能。这确保语言不是 图灵完备 Turing Complete 的，这意味着脚本具有有限的复杂性和可预测的执行时间。脚本不是通用语言。这些限制确保了该语言不能用于创建无限循环或其他形式的“逻辑炸弹”，这种“逻辑炸弹”可能嵌入交易中，导致对比特币网络的拒绝服务攻击。请记住，每笔交易都由比特币网络上的每个完整节点验证。有限制的语言会阻止交易验证机制被当作漏洞。 无状态验证 比特币交易脚本语言是无状态的，在执行脚本之前没有状态，在执行脚本之后也不保存状态。因此，执行脚本所需的所有信息都包含在脚本中。脚本在任何系统上都能可预测地执行。如果你的系统验证了脚本，你可以确定比特币网络中的其他每个系统都会验证该脚本，这意味着有效的交易对每个人都有效，每个人都知道这一点。结果的可预测性是比特币系统的一个重要好处。 创建脚本 ( 锁定 + 解锁 ) 比特币的交易验证引擎依靠两种类型的脚本来验证交易：锁定脚本和解锁脚本。 锁定脚本是放置在输出上的花费条件：它指定将来要花费输出必须满足的条件。由于历史原因，锁定脚本被称为 scriptPubKey ，因为它通常包含公钥或比特币地址（公钥的哈希）。在本书中，我们将其称为“锁定脚本”，以表示此脚本技术更广泛的可能性。在大多数比特币应用中，我们所称的锁定脚本将作为 scriptPubKey 出现在源代码中。你还会看到被称为 witness script 的锁定脚本（参见 [segwit]）或更一般地称为 cryptographic puzzle 。这些术语在不同的抽象层次代表着相同的东西。 解锁脚本是可以“解决”或满足锁定脚本放置到输出上的条件，从而花费输出的脚本。解锁脚本是每个交易输入的一部分。大多数情况下，它们包含用户钱包利用私钥生成的数字签名。由于历史原因，解锁脚本被称为 scriptSig ，因为它通常包含数字签名。在大多数比特币应用中，源代码将解锁脚本称为 scriptSig 。你还将看到称为 witness 的解锁脚本（参见[segwit]）。在本书中，我们将其称为“解锁脚本”来表示更广泛的锁定脚本，因为并非所有解锁脚本都必须包含签名。 每个比特币验证节点通过一起执行锁定和解锁脚本来验证交易。每个输入都包含一个解锁脚本，并引用先前存在的UTXO。验证软件将复制解锁脚本，检索输入引用的UTXO，并从该UTXO复制锁定脚本。然后按顺序执行解锁和锁定脚本。如果解锁脚本满足锁定脚本条件，则输入有效（参见 单独执行解锁和锁定脚本 ）。所有输入都是作为交易整体验证的一部分独立验证的。 请注意，UTXO永久记录在区块链中，因此不会改变，也不会因为在新交易中花费它的失败尝试而受到影响。只有正确满足输出条件的有效交易才会导致输出被视为“已花费”并从未使用的交易输出集和（UTXO集）中移除。 Combining scriptSig and scriptPubKey to evaluate a transaction script 是最常见类型的比特币交易（支付到公钥的哈希）的解锁和锁定脚本示例，显示了在脚本验证之前将解锁脚本和锁定脚本连接在一起所产生的组合脚本。 Figure 3. Combining scriptSig and scriptPubKey to evaluate a transaction script 脚本执行栈 比特币的脚本语言称为基于堆栈的语言，因为它使用称为 栈 stack 的数据结构。堆栈是一个非常简单的数据结构，可以将其视为一叠卡片。一个堆栈允许两个操作：push和pop。Push会在堆栈顶部添加一个项目。 Pop从堆栈中删除顶部的项目。堆栈上的操作只能作用于堆栈中最顶端的项目。堆栈数据结构也称为后进先出或“LIFO”队列。 脚本语言通过从左向右处理每个项目来执行脚本。\"数字\"（数据常量）被push进入堆栈。\"操作\"从堆栈中pop一个或多个参数，执行操作，并可能将结果push到堆栈。例如，OP_ADD 会从堆栈中弹出两个项目，做加法，并将结果push到堆栈上。 条件运算符评估一个条件，产生TRUE或FALSE的布尔结果。例如，OP_EQUAL pop堆栈中的两个项目，如果它们相等，则push TRUE（TRUE由数字1表示），如果不相等，则push FALSE（由零表示）。比特币交易脚本通常包含一个条件操作符，以便它们可以生成表示有效交易的TRUE结果。 一个简单的脚本 现在让我们将有关脚本和堆栈的知识应用于一些简单的示例。 在 Bitcoin’s script validation doing simple math 中，脚本 2 3 OPADD 5 OP_EQUAL 演示了算术加法运算符 OP_ADD，将两个数字相加并将结果放在堆栈上，后面跟着条件运算符 OP_EQUAL，它检查结果总和是否相等到 5 。为简洁起见，在示例中省略了 OP 前缀。有关可用脚本运算符和函数的更多详细信息，请参见 [tx_script_ops]。 虽然大多数锁定脚本都是指公钥哈希（本质上是比特币地址），因此需要所有权证明来支付资金，脚本并不一定非常复杂。生成TRUE值的锁定和解锁脚本的任何组合都是有效的。我们用作脚本语言示例的简单算术也是一个有效的锁定脚本，可用于锁定交易输出。 使用算术示例脚本的一部分作为锁定脚本: 3 OP_ADD 5 OP_EQUAL 可以被包含以下解锁脚本的交易满足： 2 验证软件将锁定和解锁脚本结合在一起： 2 3 OP_ADD 5 OP_EQUAL 正如我们在 Bitcoin’s script validation doing simple math 中的示例中看到的，执行此脚本时，结果为 OP_TRUE，交易有效。这不仅是一个有效的交易输出锁定脚本，而且由此产生的UTXO可以被具有任何知道数字2满足脚本的人花费。 Tip 如果堆栈顶层结果为 TRUE（ 标记为 {0x01} ），任何其他非零值，或者脚本执行后堆栈为空，则交易有效。如果堆栈顶部的值为 FALSE（一个零长度的空值，标记为{}），或者脚本被运算符显式终止了，例如 OP_VERIFY，OP_RETURN 或一个条件终止符，如 OP_ENDIF，则交易无效。详细信息，请参见 [tx_script_ops]。 Figure 4. Bitcoin’s script validation doing simple math 以下是一个稍微复杂的脚本，计算 2 + 7 - 3 + 1 。请注意，当脚本在一行中包含多个运算符时，堆栈允许一个运算符的结果由下一个运算符执行： 2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL 尝试使用笔和纸验证前面的脚本。当脚本执行结束时，在堆栈中应该保留值 TRUE。 单独执行解锁和锁定脚本 在原始的比特币客户端中，解锁和锁定脚本按顺序连接并执行。出于安全原因，2010年发生了变化，原因是存在一个漏洞，允许恶意解锁脚本将数据推送到堆栈并破坏锁定脚本。在当前的实现中，如下所述，脚本是在两次执行之间传输堆栈的情况下单独执行的。 首先，使用堆栈执行引擎执行解锁脚本。如果解锁脚本没有错误地执行（例如，它没有遗留的“悬挂（dangling）”操作符），则复制主堆栈并执行锁定脚本。如果使用从解锁脚本复制的堆栈数据执行锁定脚本的结果为“TRUE”，则解锁脚本已成功解决由锁定脚本施加的条件，证明该输入是用于花费UTXO的有效授权。如果在执行组合脚本后仍然存在除“TRUE”之外的结果，则输入无效，因为它未能满足放置在UTXO上的消费条件。 支付到公钥哈希 Pay-to-Public-Key-Hash (P2PKH) 在比特币网络上处理的绝大多数交易花费由支付到公钥哈希（P2PKH）锁定的输出这些输出包含一个锁定脚本。这些输出包含将它们锁定到公钥哈希（比特币地址）的脚本。由P2PKH脚本锁定的输出可以通过出示公钥，和由相应私钥创建的数字签名来解锁（花费）（ 参见 数字签名 (ECDSA) ）。 例如，让我们再看看Alice对Bob’s Cafe的付款。Alice向咖啡厅的比特币地址支付了0.015比特币。该交易输出将具有以下形式的锁定脚本： OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG Cafe Public Key Hash 等同于咖啡馆的比特币地址，没有Base58Check编码。大多数应用程序会以十六进制编码显示 public key hash ，而不是以“1”开头的大家熟悉的比特币地址Base58Check格式。 上述锁定脚本可以由以下形式的解锁脚本满足： 这两个脚本组合在一起形成以下的验证脚本： OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG 执行时，只有在解锁脚本与锁定脚本设置的条件匹配时，此组合脚本才会输出TRUE。换句话说，如果解锁脚本具有来自咖啡馆的私钥的有效签名，该公钥对应于公钥哈希集合作为负担，则结果为TRUE。 图 #P2PubKHash1 和 #P2PubKHash2 显示（分两部分）了逐步执行的组合脚本，证明这是一个有效的交易。 Figure 5. Evaluating a script for a P2PKH transaction (part 1 of 2) Figure 6. Evaluating a script for a P2PKH transaction (part 2 of 2) 数字签名 (ECDSA) 到目前为止，我们还没有深入探讨“数字签名”的细节。在本节中，我们将探讨数字签名如何工作，以及如何在不泄露私钥的情况下提供私钥的所有权证明。 比特币中使用的数字签名算法是 Elliptic Curve Digital Signature Algorithm 或 ECDSA 。 ECDSA是用于基于椭圆曲线私钥/公钥对的数字签名的算法，如 [elliptic_curve] 中所述。 ECDSA由脚本函数 OP_CHECKSIG，OP_CHECKSIGVERIFY，OP_CHECKMULTISIG 和 OP_CHECKMULTISIGVERIFY 使用。无论何时，你在锁定脚本中看到这些脚本的话，解锁脚本都必须包含ECDSA签名。 数字签名在比特币中有三个用途（参见下面的边栏）。首先，签名证明私钥的所有者，暗示资金的所有者，已经 授权 支出这些资金。其次，授权证明是 不可否认的 undeniable（nonrepudiation）。第三，签名证明交易（或交易的特定部分）在签名后没有也不能被任何人修改。 请注意，交易的每个输入都是独立签署的。这是至关重要的，因为签名和输入都不必属于同一个“所有者”或被其使用。事实上，一个名为“CoinJoin”的特定交易方案利用这一事实来创建隐私的多方交易。 > 交易的每个输入及其可能包含的任何签名完全独立于任何其他输入或签名。多方可以协作构建交易并各自签署一个输入。 Wikipedia’s Definition of a \"Digital Signature\" A digital signature is a mathematical scheme for demonstrating the authenticity of a digital message or documents. A valid digital signature gives a recipient reason to believe that the message was created by a known sender (authentication), that the sender cannot deny having sent the message (nonrepudiation), and that the message was not altered in transit (integrity). Source: https://en.wikipedia.org/wiki/Digital_signature 数字签名如何工作 数字签名是由两部分组成的数学模式 mathematical scheme。第一部分是使用私钥（签名密钥）从消息（交易）创建签名的算法。第二部分是，允许任何人使用消息和公钥验证签名的算法 创建数字签名 在比特币的ECDSA算法实现中，被签名的“消息”是交易，或者更准确地说是交易中特定数据子集的哈希（参见 签名哈希的类型 (SIGHASH) ）。签名密钥是用户的私钥。结果是如下签名： ((Sig = F{sig}(F{hash}(m), dA))) 其中: dA 是签名私钥 m 是交易（或交易的一部分） F**hash 是哈希函数 F**sig 是签名算法 Sig 是签名结果 更多关于ECDSA的细节可以在 ECDSA 数学 中找到。 F**sig 方法生成签名 Sig ，由两部分组成： R 和 S: Sig = (R, S) 现在已经计算了两个值+ R 和 S +，它们使用称为 Distinguished Encoding Rules 或 DER 的国际标准编码方案序列化为字节流。 签名的序列化 (DER) 让我们再看一下Alice创建的交易。在交易输入中有一个解锁脚本，其中包含来自Alice钱包的DER编码签名： 3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301 该签名是Alice的钱包生成的 R 和 S 的序列化字节流，用于证明她拥有授权使用该输出的私钥。序列化格式由以下九个元素组成： 0x30 —— 标识 DER 序列的开始 0x45 —— 序列长度 (69 bytes) 0x02 —— 接下来是一个整数 0x21 —— 整数的长度 (33 bytes) R —— 00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb 0x02 —— 接下来是另一个整数 0x20 —— 另一个整数的长度 (32 bytes) S —— 4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 一个后缀 (0x01) 标识使用的哈希类型 (SIGHASH_ALL) 看看你是否可以使用这个列表解码Alice的序列化（DER编码）签名。重要的数字是 R 和 S ；其余的数据是DER编码方案的一部分。 验证签名 要验证签名，必须拿到签名（ R 和 S ），序列化交易和公钥（对应的用于创建签名的私钥）。实质上，对签名的验证意味着“只有生成此公钥的私钥的所有者才能在此交易上产生此签名”。 签名验证算法采用消息（交易或其部分数据的散列），签名者的公钥和签名（ R 和 S 值），如果签名对此消息和公钥有效，则返回TRUE。 签名哈希的类型 (SIGHASH) 数字签名是应用于消息的，对比特币来说，消息就是交易。签名意味着签名者对具体交易数据的 保证 commitment 。最简单的形式是，签名应用于整个交易，从而保证所有输入，输出和其他交易字段。但是，签名也可以只保证交易中的一部分数据，在许多场景下很有用，我们将在本节中看到。 比特币的签名可以使用 SIGHASH 指示交易数据的哪部分包含在由私钥签名的哈希中。SIGHASH 标志是附加到签名后面的单个字节。每个签名都有一个 SIGHASH 标志，并且该标志对于不同输入是不同的。具有三个签名输入的交易可以具有三个不同的带有 SIGHASH 标志的签名，每个签名签署（保证）交易的不同部分。 请记住，每个输入都能在其解锁脚本中包含一个签名。因此，包含多个输入的交易可能具有不同的带有 SIGHASH 标志的签名，这些标志会在每个输入中保证交易的不同部分。还要注意的是，比特币交易可能包含来自不同“所有者”的输入，他们可能在部分构建的（无效的）交易中仅签署一个输入，需要其他人合作收集所有必要的签名才能进行有效交易。许多 SIGHASH 标志类型只有在你认为多位参与者在比特币网络之外协作并各自更新部分签名的交易时才有意义。 有三种 SIGHASH 标志: ALL, NONE, 和 SINGLE, 如 SIGHASH types and their meanings 所示。 Table 3. SIGHASH types and their meanings SIGHASH flag Value Description ALL 0x01 签名应用于所有输入和输出。 NONE 0x02 签名应用于所有输入，不包括任何输出 SINGLE 0x03 签名应用于所有输入，但仅应用于与签名输入具有相同索引编号的一个输出 另外，还有一个修饰符标志 SIGHASH_ANYONECANPAY，它可以与前面的每个标志结合使用。当设置了 ANYONECANPAY 时，只有一个输入被签名，剩下的（及其序列号）保持开放可以修改。 ANYONECANPAY 的值为 0x80，并按位OR应用，生成组合的标志，如 SIGHASH types with modifiers and their meanings 所示。 Table 4. SIGHASH types with modifiers and their meanings SIGHASH flag Value Description ALL\\ ANYONECANPAY 0x81 签名应用于一个输入和所有输出 NONE\\ ANYONECANPAY 0x82 签名应用于一个输入，不应用于输出 SINGLE\\ ANYONECANPAY 0x83 签名应用于一个输入和有相同索引号的输出 在签名和验证过程中应用 SIGHASH 标志的方式是创建交易的副本，将内部的某些字段截断（设置长度为零并清空）。将产生的交易序列化。将 SIGHASH 标志添加到序列化交易的末尾，并对结果进行哈希散列。哈希本身就是被签名的“消息”。根据使用哪个 SIGHASH 标志，交易的不同部分被截断。结果散列取决于交易中数据的不同子集。在散列之前最后一步包含了 SIGHASH ，签名也保证了 SIGHASH 类型，不能被（矿工）改变。 > 所有 SIGHASH 类型都签署了交易的 nLocktime 字段（请参见 [transaction_locktime_nlocktime]）。另外，SIGHASH 类型本身在签名之前附加到交易中，在签名后不能修改。 在Alice的交易示例中（请参见 签名的序列化 (DER) 中的列表），我们看到DER编码签名的最后一部分是 01 ，它是 SIGHASH_ALL 标志。这会锁定交易数据，所以Alice的签名会保证所有输入和输出的状态。这是最常见的签名形式。 让我们看看其他类型的 SIGHASH 以及它们如何在实践中使用： ALL|ANYONECANPAY 这种结构可以用来进行“众筹”式的交易。试图筹集资金的人可以创建一个单一输出的交易。单一输出向资金筹集人支付“目标”金额。这样的交易显然是无效的，因为它没有输入。现在，其他人可以通过添加自己的输入来进行修改这笔交易，作为捐赠。他们用 ALL|ANYONECANPAY 来签名自己的输入。除非收集到足够的投入，达到输出的价值，否则交易无效。每一笔捐款都是一种“承诺/抵押”，在筹集到目标金额之前，筹款不能收回。 NONE 这种结构可用于创建特定数量的“不记名支票”或“空白支票”。它交付输入，但允许更改输出锁定脚本。任何人都可以将自己的比特币地址写入输出锁定脚本并赎回资金。但是，输出值本身被签名锁定。 NONE|ANYONECANPAY 这种结构可以用来建立一个“集尘器”。钱包里有微型UTXO的用户，如果不支付超过灰尘价值的费用，就无法消费这些东西。有了这种签名，微型UTXO可以捐赠给任何人，聚集并在任何时候花费它们。 有一些关于修改或扩展 SIGHASH 系统的建议。其中一个是 Blockstream 的 Glenn Willen 提出的 BitTek Sighash Modes ，是 Elements 项目的一部分。它旨在创建一个灵活的 SIGHASH 类型替代方案，允许“输入和输出的任意的，矿工可重写的位掩码”，可以表达“更复杂的合同预先承诺方案，例如在分布式资产交换中签署带有更改的报价\"。 > 你不会在用户的钱包应用程序中看到+ SIGHASH 标志选项。除了少数例外，钱包构建P2PKH脚本并使用 +SIGHASH_ALL 标志进行签名。要使用不同的 SIGHASH 标志，你必须编写软件来创建和签署交易。更重要的是，SIGHASH 标志可以被特殊用途的比特币应用程序使用，实现新用途。 ECDSA 数学 如前所述，签名是由一个数学函数 F**sig 创建的，产生由两个值 R 和 S 组成的签名。在本节中，我们将更详细地讨论函数 F**sig。 签名算法首先生成 ephemeral（临时）私钥公钥对。在涉及签名私钥和交易哈希的转换之后，此临时密钥对用于计算R和S值。 临时密钥对基于随机数 k ，也就是临时私钥。从 k 开始，我们生成相应的临时公钥 P（按照P = k * G计算，与比特币公钥的生成方式相同；参见 [pubkey] ）。数字签名的 R 值就是临时公钥 P 的 x 坐标。 算法计算签名的S值，如下： S = k-1 (Hash(m) + dA R) mod p* 其中: k 是临时私钥 R 是临时公钥的 x 坐标 dA 是签名私钥 m 是交易数据 p 是椭圆曲线的主要阶数 “验证”是签名生成函数的反函数，使用 R，S 值和公钥来计算一个值 P，它是椭圆曲线上的一个点（签名创建中使用的临时公钥）： P = S-1 Hash(m) G + S-1 R Qa where: R 和 S 是签名的值 Qa 是Alice的公钥 m 是被签名的交易数据 G 是椭圆曲线的生成点 如果计算点 P 的 x 坐标等于 R ，那么验证者可以推断签名是有效的。 请注意，在验证签名时，没有用到私钥，也不会被泄露。 > ECDSA是一门相当复杂的数学；完整的解释超出了本书的范围。许多优秀的在线指南会一步一步地讲解它：搜索“ECDSA解释”或尝试这一个：http://bit.ly/2r0HhGB[]。 随机性在签名中的重要性 正如我们在 ECDSA 数学 中看到的，签名生成算法使用随机密钥 k 作为临时私钥/公钥对的基础。 k 的值并不重要，只要它是随机的。如果使用相同的值 k 在不同的消息（交易）上生成两个签名，那么则任何人都可以计算签名私钥。在签名算法中重复使用 k 的相同值会导致私钥的暴露！ > 如果在两个不同交易的签名算法中使用相同的 k ，则可以计算私钥并将其公开给全世界！ 这不仅仅是一种理论上的可能性。我们已经看到这个问题导致私钥暴露在比特币的几种不同的交易签名算法中。由于无意中重复使用 k 值，有人资金被盗。重用 k 值的最常见原因是没有初始化正确的随机数生成器。 为避免此漏洞，最佳做法是不生成带有熵的随机数生成器的 k，而是使用通过交易数据本身作为种子的确定性随机过程。这确保每笔交易产生不同的 k。 k 的确定性初始化的行业标准算法在 Internet Engineering Task Force 发布的 RFC 6979 中定义。 如果你正在实施一种算法来签署比特币交易，你必须使用RFC 6979或类似的确定性随机算法来确保你为每笔交易生成不同的 k。 比特币地址，余额和其他抽象 我们发现交易在“幕后”看起来与它们在“钱包”，区块链浏览器，和其他面向用户的应用程序中的呈现方式非常不同。交易的结构中似乎没有来自前几章的许多简单和熟悉的概念，比如比特币地址和余额。我们看到交易本身不包含比特币地址，而是通过锁定和解锁比特币的离散值的脚本进行操作。余额不存在于此系统的任何位置，但每个钱包应用程序会突出显示用户钱包的余额。 现在我们已经研究了实际包含在比特币交易中的内容，我们可以研究更高层次的抽象是如何从交易的看似原始的组成部分中获得的。 让我们再看看Alice的交易是如何在区块链浏览器（ Alice’s transaction to Bob’s Cafe ）上展示的。 Figure 7. Alice’s transaction to Bob’s Cafe 在交易左侧，区块链浏览器显示Alice的比特币地址为“发件人”。事实上，这些信息并不在交易本身中。当区块链浏览器检索到该交易时，它还检索到输入中引用的前一个交易，并从这个之前的交易中提取第一个输出。该输出中是一个锁定脚本，将UTXO锁定到Alice的公钥散列（一个P2PKH脚本）。区块链浏览器提取公钥哈希并使用Base58Check编码对其进行编码，以生成并显示代表该公钥的比特币地址。 同样，在右侧，区块链浏览器显示了两个输出；第一个是Bob的比特币地址，第二个是Alice的比特币地址（找零）。再次，为了创建这些比特币地址，区块链浏览器从每个输出中提取锁定脚本，将其识别为P2PKH脚本，并从内部提取公钥哈希。最后，区块链浏览器使用Base58Check重新编码该公钥，以生成并显示比特币地址。 如果你点击了Bob的比特币地址，区块链浏览器会显示 The balance of Bob’s bitcoin address 中的视图。 Figure 8. The balance of Bob’s bitcoin address 区块链浏览器显示Bob的比特币地址的余额。但比特币系统中没有任何地方存在“余额”的概念。这里显示的值是由区块链浏览器构建的，如下所示。 为了构建“总共收到的”金额，区块链浏览器首先解码比特币地址的Base58Check编码，以检索编码在地址中的Bob的公钥的160位哈希。然后，区块链浏览器将搜索交易数据库，寻找包含Bob公钥散列P2PKH锁定脚本的输出。通过汇总所有输出的值，区块链浏览器可以产生收到的总价值。 构建当前余额（显示为“最终余额 Final Balance”）需要更多的工作。区块链浏览器维护了目前未使用的输出的单独的数据库，即UTXO集。为了维护此数据库，区块链浏览器必须实时监控比特币网络，添加新创建的UTXO，并实时删除已花费的UTXO，当它们出现在未经确认的交易中时。这是一个复杂的过程，它依赖于跟踪交易的传播过程，以及与比特币网络保持一致，以确保遵循正确的链条。有时，区块链浏览器不同步，并且其UTXO集的视角不完整或不正确。 从UTXO集合中，区块链浏览器汇总所有引用Bob的公钥哈希值的未使用输出的值，并产生显示给用户的“最终余额”数字。 为了制作这一张带两个“余额”图片，区块链浏览器必须对几十，几百甚至几十万的交易进行索引和搜索。 总之，钱包应用程序，区块链浏览器和其他比特币用户界面呈现给用户的信息通常由更高级别的抽象组成，这些抽象通过搜索许多不同的交易，检查其内容并操纵其中包含的数据而派生。为了呈现这种简单的比特币交易视图，类似于从一个发件人到一个收件人的银行支票，这些应用程序必须抽象许多底层细节。他们主要关注常见类型的交易：P2PKH 和 SIGHASH_ALL 在每个输入上签名。因此，虽然比特币应用程序可以以易于阅读的方式呈现超过80％的交易，但它们有时会被偏离规范的交易所难倒。包含更复杂的锁定脚本，或不同的 SIGHASH 标志，或许多输入和输出的交易，表明了这些抽象的简单性和缺陷。 每天，在区块链中确认数百个不包含P2PKH输出的交易。区块链浏览器通常会用红色警告信息显示他们无法解码地址。以下链接包含未完全解码的最新的“奇怪交易”：https：//blockchain.info/strange-transactions[] 。 我们将在下一章中看到的，这些并不一定是奇怪的交易。它们是包含比普通 P2PKH 更复杂的锁定脚本的交易。我们将学习如何解码和理解更复杂的脚本及其支持的应用程序。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 14:45:58 "},"09第七章.html":{"url":"09第七章.html","title":"高级交易和脚本","keywords":"","body":"高级交易和脚本 概述 上一章我们介绍了比特币交易的基本元素，并研究了最常见的交易脚本类型，即P2PKH脚本。在本章中，我们将介绍更高级的脚本以及如何使用它来构建复杂条件下的交易。 首先，我们将介绍 multisignature 脚本。接下来，我们将看一下第二个常见的交易脚本 Pay-to-Script-Hash ，它打开了复杂脚本的世界。然后，我们将研究通过 timelocks 为比特币添加时间维度的新的脚本运算符。最后，我们将看看 Segregated Witness，这是对交易结构的架构更改。 多重签名 多重签名脚本设置了一个条件，N 个公钥记录在脚本中，并且需要其中至少 M 个提供签名才能解锁资金。这也被称为 M-of-N 方案，其中 N 是密钥的总数，M 是验证所需签名个数的阈值。例如，一个 2-of-3 的多重签名是三个公钥被列为潜在签名者并且其中至少两个必须被用来创建签名，从而创建有效的交易花费资金。 目前，标准的 多重签名脚本最多只能列出3个公钥，这意味着你可以执行从 1-of-1 到 1-of-3 之间的任意组合的多重签名。本书出版时，列出3个公钥的限制可能已经解除，因此请检查 IsStandard() 函数以查看网络当前接受的操作。请注意，3键的限制仅适用于标准（也称为“裸”）多重签名脚本，而不适用于包含在支付到脚本哈希（P2SH）中的多重签名脚本。 P2SH多重签名脚本限于15个键，最多允许15-of-15的多重签名。我们将在 支付到脚本哈希 Pay-to-Script-Hash (P2SH) 中学习P2SH。 M-of-N 多重签名条件的锁定脚本设置通常形式如下： M ... N CHECKMULTISIG 其中 N 是列出的公钥数量，M 是花费这笔支出所需的签名个数。 一个 2-of-3 多重签名条件的锁定脚本设置如下： 2 3 CHECKMULTISIG 上面的锁定脚本可以被包含签名和公钥对儿的解锁脚本满足： 或者3个公钥中的任意两个对应的私钥生成的签名的组合 两个脚本组合起来形成下面的验证脚本 2 3 CHECKMULTISIG 执行时，只有在解锁脚本与锁定脚本设置的条件匹配时，此组合脚本才会评估为TRUE。在这种情况下，条件是解锁脚本是否具有来自3个公钥中的两个对应私钥的有效签名。 CHECKMULTISIG执行中的一个错误 在 CHECKMULTISIG 的执行过程中有一个错误，需要稍微解决一下。当 CHECKMULTISIG 执行时，它应该消耗堆栈中的 M + N + 2 个项目作为参数。 但是，由于该错误，CHECKMULTISIG 会弹出额外的值或超出预期的值。 让我们用前面的验证示例更详细地看一下： 2 3 CHECKMULTISIG 首先，CHECKMULTISIG+弹出顶部元素，它是 +N（在本例中为“3”）。然后它弹出 N 个元素，这是可签名的公钥。在这个例子中，是公钥 A，B 和 C 。然后，它弹出一个项目，即 M ，仲裁数（需要多少个签名）。这里 M = 2。此时，CHECKMULTISIG 应该弹出最后的 M 个元素，这是签名，并查看它们是否有效。然而，不幸的是，实现中的一个错误会导致 CHECKMULTISIG 弹出另一个元素（ 总数为M + 1 ）。额外的项目在检查签名时被忽略，因此它对 CHECKMULTISIG 本身没有直接影响。但是，必须存在额外的值，因为如果它不存在，当 CHECKMULTISIG 试图弹出空堆栈时，它将导致堆栈错误和脚本失败（将交易标记为无效）。由于额外的项目被忽略，它可以是任何东西，但通常使用 0。 由于这个bug成为了共识规则的一部分，现在必须永久复制。因此，正确的脚本验证将如下所示： 0 2 3 CHECKMULTISIG 所以，正确的解锁脚本不是 而是: 0 从现在起，如果你看到一个 multisig 解锁脚本，你应该在开始时看到一个额外的 0，其唯一目的是修正意外成为共识规则的错误。 支付到脚本哈希 Pay-to-Script-Hash (P2SH) 支付到脚本哈希（P2SH）是2012年推出的一种强大的新型交易，大大简化了复杂交易脚本的使用。为了解释对P2SH的需求，我们来看一个实际的例子。 在 [ch01_intro_what_is_bitcoin] 中，我们介绍了位于迪拜的电子产品进口商Mohammed。Mohammed公司的公司帐户广泛使用比特币的多重签名功能。多重签名脚本是比特币高级脚本功能的最常见用途之一，并且是一个非常强大的功能。Mohammed的公司为所有客户付款使用多重签名脚本，在会计术语中称为“应收账款”或AR。使用多重签名方案时，客户进行的任何付款都会被锁定，以至于他们需要至少两个签名才能从Mohammed及其合作伙伴或拥有备份密钥的律师处获得释放。像这样的多重签名方案提供公司治理控制并防止盗窃，盗用或损失。 最终的脚本很长，看起来是这样的： 2 5 CHECKMULTISIG 尽管多重签名脚本是一个强大的功能，但它们使用起来很麻烦。对于前面的脚本，Mohammed必须在付款之前将此脚本传达给每位客户。每个客户都必须使用特殊的比特币钱包软件来创建自定义交易脚本，并且每个客户都必须了解如何使用自定义脚本创建交易。此外，由此产生的交易将比简单的支付交易大五倍，因为该脚本包含非常长的公钥。该特大交易的负担将由客户以费用的形式承担。最后，像这样的大型交易脚本将在每个完整节点的内存中的UTXO集中存储，直到耗尽内存为止。所有这些问题使得在实践中使用复杂的锁定脚本变得困难。 P2SH是为了解决这些实际困难而开发的，使复杂脚本的使用像支付比特币地址一样简单。通过P2SH支付，复杂的锁定脚本将被其数字指纹（一种加密哈希）所取代。当试图花费UTXO的交易在之后出现时，除了解锁脚本外，它还必须包含与锁定脚本的指纹相同的脚本。简而言之，P2SH的意思是“支付给与该哈希值相匹配的脚本，这个脚本将在稍后花费输出时使用”。 在P2SH交易中，由哈希值代替的锁定脚本称为 赎回脚本 redeem script，因为它在赎回时提供给系统，而不是作为锁定脚本。 Complex script without P2SH 显示没有P2SH的脚本，Complex script as P2SH 显示与P2SH编码的脚本相同。 Table 1. Complex script without P2SH Locking Script 2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG Unlocking Script Sig1 Sig2 Table 2. Complex script as P2SH Redeem Script 2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG Locking Script HASH160 EQUAL Unlocking Script Sig1 Sig2 如你所见，使用P2SH时，复杂的脚本详细说明了花费输出（赎回脚本）的条件，但不是在锁定脚本中显示。只有它的散列在锁定脚本中，而且赎回脚本本身稍后会作为解锁脚本的一部分在花费输出时呈现。这将费用和复杂性的负担从交易的发送者转移到了接收者（消费者）。 让我们看看Mohammed的公司，复杂的多重签名脚本，以及由此产生的P2SH脚本。 首先，Mohammed公司为所有客户的付款使用多重签名脚本： 2 5 CHECKMULTISIG 如果占位符被实际的公钥取代（这里显示为以04开头的520位数字），你可以看到该脚本变得非常长： 2 04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800 5 CHECKMULTISIG 整个脚本可以使用20字节的加密散列取代，首先应用SHA256散列算法，然后对结果应用RIPEMD160算法。 我们在命令行上使用 libbitcoin-explorer（bx）来生成脚本哈希，如下所示： echo \\ 2 \\ [04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \\ [04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \\ [047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \\ [0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \\ [043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \\ 5 CHECKMULTISIG \\ | bx script-encode | bx sha256 | bx ripemd160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e 上述一系列命令首先将Mohammed的multisig redeem脚本编码为十六进制的序列化的比特币脚本。下一个 bx 命令计算其SHA256散列值。下一个 bx 命令再次使用RIPEMD160进行哈希运算，产生最终的脚本哈希： Mohammed的赎回脚本的20字节哈希值是: 54c557e07dde5bb6cb791c7a540e0a4796f5e97e P2SH交易使用以下锁定脚本将输出锁定到此哈希值，而不是之前更长的赎回脚本： HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL 如你所见，它要短得多。与“支付到5个密钥的多重签名脚本”不同，P2SH等价交易是“支付到这个哈希值的脚本”。向Mohammed公司付款的客户只需在付款中包含更短的锁定脚本。当Mohammed和他的合作伙伴想要使用这个UTXO时，他们必须出示原始赎回脚本（用哈希值锁定UTXO的那个脚本）和解锁它的必要签名，如下所示： 这两个脚本组合为两个阶段。首先，根据锁定脚本检查赎回脚本以确保哈希值匹配： HASH160 EQUAL 如果赎回脚本哈希值匹配，解锁脚本将自行执行，以解锁赎回脚本： 2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG 本章介绍的几乎所有脚本都只能作为P2SH脚本实现。它们不能直接用在UTXO的锁定脚本中。 P2SH 地址 P2SH功能的另一个重要部分是将脚本哈希编码为地址的能力，如BIP-13中所定义的那样。P2SH地址是脚本的20字节散列的Base58Check编码，就像比特币地址是公钥的20字节散列的Base58Check编码一样。 P2SH地址使用版本前缀“5”，这导致以“3”开头的Base58Check编码地址。 例如，Mohammed的复杂脚本，通过哈希和Base58Check编码，生成P2SH地址 39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw。我们可以用 bx 命令来确认 echo \\ '54c557e07dde5bb6cb791c7a540e0a4796f5e97e'\\ | bx address-encode -v 5 39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw 现在，Mohammed可以给他的客户提供这个“地址”，他们几乎可以使用任何比特币钱包进行简单付款，就像它是一个比特币地址一样。前缀3给他们一个暗示，这是一种特殊的地址类型，对应于脚本而不是公钥，但是它的作用方式与支付比特币地址的方式完全相同。 P2SH地址隐藏了所有的复杂性，因此付款人看不到脚本。 P2SH 的好处 与在锁定输出时直接使用复杂脚本相比，P2SH具有以下优点： 复杂的脚本在交易输出中被更短的指纹代替，从而使交易数据更小。 脚本可以编码为地址，发件人和发件人的钱包不需要复杂的工程来实现P2SH。 P2SH将构建脚本的负担转移给收件人，而不是发件人。 P2SH将长脚本的数据存储负担从输出中（存储在区块链中的UTXO集中）转移到输入中（仅存储在区块链中）。 P2SH将长文件的数据存储负担从当前时间（支付）转移到未来时间（花费时间）。 P2SH将长脚本的交易费用从发件人转移到收件人，收件人必须包含很长的兑换脚本才能使用。 赎回脚本和验证 在Bitcoin Core客户端版本0.9.2之前，Pay-to-Script-Hash通过 IsStandard() 函数仅限于标准类型的比特币交易脚本。这意味着消费交易中提供的赎回脚本只能是标准类型之一：P2PK，P2PKH或multisig。 从Bitcoin Cor客户端版本0.9.2开始，P2SH交易可以包含任何有效的脚本，使P2SH标准更加灵活，并允许对许多新型和复杂类型的交易进行实验。 你无法将P2SH放入P2SH赎回脚本中，因为P2SH规范不是递归的。另外，技术上可以在赎回脚本中包含 RETURN（ 参见 数据记录输出 (RETURN) ），规则中的任何内容都无法阻止你这样做，但没有实际意义，因为在验证期间执行 RETURN 将导致交易被标记为无效。 请注意，因为赎回脚本在你尝试使用P2SH的输出之前未呈现给网络，所以如果你使用无效的赎回脚本的哈希锁定该输出，它将被忽略。 UTXO将被成功锁定，但你将无法花费这笔费用，包含赎回脚本的花费交易不会被接受，因为它是无效的脚本。这会产生风险，因为你可以将比特币锁定在以后不能使用的P2SH中。网络会接收对应于无效的赎回脚本的锁定脚本。 > P2SH锁定脚本包含赎回脚本的散列，但不会提供有关赎回脚本本身内容的线索。即使赎回脚本无效，P2SH交易也将被视为有效的并被接受。你可能会意外锁定比特币，之后无法花费。 数据记录输出 (RETURN) 比特币的分布式时间戳账本，区块链（blockchain），具有远远超出支付范围的潜在用途。许多开发人员尝试使用交易脚本语言，利用系统的安全性和灵活性，应用于数字公证服务，股票证书和智能合约等。将比特币的脚本语言用于这些目的的早期尝试包括创建交易输出，在区块链上记录数据；例如，记录文件的数字指纹，使得任何人都可以通过引用该交易作为该文件在特定日期存在的证明。 使用比特币区块链来存储与比特币付款无关的数据是一个有争议的话题。许多开发人员认为这种使用是滥用，并希望阻止它。其他人则认为这是区块链技术强大功能的一个示例，并且希望鼓励这种实验。那些反对纳入未付款数据的人争辩说，它会导致“区块链膨胀”，使那些运行完整比特币节点的人承担存储区块链无意承载的数据带来的成本。此外，此类交易创建了不能用于支付的，使用20字节的目标比特币地址的UTXO。由于该地址用于数据，因此它不对应于私钥，生成的UTXO不会被花费；这是虚假的付款。因此，永远不会花费的这些交易永远不会从UTXO集中移除，并导致UTXO数据库的大小永远增加或“膨胀”。 在Bitcoin Core客户端的0.9版本中，通过引入 RETURN 运算符达成了一个折衷方案。 RETURN 允许开发人员将80个字节的非付款数据添加到交易输出中。但是，与使用“假”UTXO不同，RETURN 运算符会创建一个显式的 可验证不可消费 的输出，该输出不需要存储在UTXO集合中。 RETURN 输出记录在区块链中，因此它们消耗磁盘空间并会导致区块链大小的增加，但它们不存储在UTXO集中，因此不会使UTXO内存池膨胀，完整节点页不用承担昂贵的内存负担。 RETURN 脚本看起来如下 RETURN 数据部分被限制为80字节，并且通常表示哈希，例如SHA256算法的输出（32字节）。许多应用程序在数据前加上前缀以帮助识别应用。例如，[http://proofofexistence.com[Proof](http://proofofexistence.com[proof/) of Existence] 数字公证服务使用8字节前缀 DOCPROOF，十六进制ASCII编码为 44 4f 43 50 52 4f 4f 46。 请记住，没有对应于 RETURN 的“解锁脚本”，用于“花费” RETURN 输出。 RETURN 的全部意义在于你不能把钱锁定在那个输出中，因此它不需要被保存在UTXO集合中（潜在可花费的）—— RETURN 是可验证不可花费的。RETURN 通常是比特币金额为零的输出，因为分配给这种输出的任何比特币都会永久丢失。如果在交易中引用 RETURN 作为输入，脚本验证引擎将暂停验证脚本的执行并将交易标记为无效。RETURN 的执行本质上导致脚本以 FALSE “返回”并暂停。因此，如果你意外地将 RETURN 输出引用为交易中的输入，则该交易无效。 标准交易（符合 IsStandard() 检查的交易）只能有一个 RETURN 输出。但是，一个 RETURN 输出可以与任何其他类型的输出组合在一个交易中。 Bitcoin Core 0.10中增加了两个新的命令行选项。选项 datacarrier 控制是否中转和开采 RETURN 交易，默认设置为“1”以允许。选项 datacarriersize 接受一个数字参数，指定 RETURN 脚本的最大字节数，缺省为83字节，表示 RETURN 数据最多80个字节，加上 RETURN 操作码的一个字节，和 PUSHDATA 操作码的两个字节。 > RETURN 最初提出的最大限制为80个字节，但在发布功能时限制已减少到40个字节。2015年2月，在比特币核心版本0.10中，限制提高到80字节。节点可以选择不中转或使用 RETURN，或者只中转和开采包含少于80字节数据的 RETURN 交易。 时间锁 Timelocks 时间锁是对交易或输出的限制，只允许在某个时间点之后花费。比特币从一开始就具有交易级别的时间锁定功能。它由交易中的 nLocktime 字段实现。 2015年末和2016年中推出了两个新的时间锁功能，可提供UTXO级别的时间锁定。这些是 CHECKLOCKTIMEVERIFY 和 CHECKSEQUENCEVERIFY。 时间锁定对于推迟日期的交易非常有用，将资金锁定在未来的日期。更重要的是，时间锁将比特币脚本延伸到时间维度，为复杂的多步智能合约打开了大门。 交易时间锁 (nLocktime) 从一开始，比特币就具有交易级别的时间锁定功能。交易锁定时间是交易级别的设置（交易数据结构中的一个字段），用于定义交易有效的最早时间，并且可以在网络上中转或添加到区块链。Locktime也被称为 nLocktime ，来自Bitcoin Core代码库中使用的变量名称。在大多数交易中它被设置为0以表示立即传播和执行。如果 nLocktime 非零且低于5亿，会被解释为为区块高度，表示交易无效并且不会在指定块高度之前中转或包含在区块链中。如果它超过5亿，它会被解释为Unix纪元时间戳（自1970年1月1日以来的秒数），表示交易在指定时间之前无效。使用 nLocktime 指定未来区块或时间的交易必须由发起的系统持有，只有在它们生效后才传输到比特币网络。如果交易在指定的 nLocktime 之前传输到网络，交易将被第一个节点认为无效并拒绝，不会被中转到其他节点。 nLocktime 的使用等同于推迟日期的纸质支票。 交易锁定时间限制 nLocktime 具有局限性，虽然它允许一些输出在将来被花费，但不会使这些输出在那个时间之前不能被花费。我们用下面的例子来解释一下。 Alice签署了一笔交易，将其的一个输出指定到Bob的地址，并将 nLocktime 设置为3个月之后。Alice将该交易发送给了Bob。通过这次交易，Alice和Bob知道： 在3个月过去之前，Bob不能发起赎回资金的交易。 Bob可能会在3个月后发起交易。 但是: Alice可以创建另一个交易，在没有锁定时间的情况下重复使用相同的输入。因此，Alice可以在3个月过去之前花费相同的UTXO。 Bob无法保证Alice不这么做。 了解交易 nLocktime 的局限性非常重要。唯一的保证是鲍勃在3个月之前不能赎回，而无法保证鲍勃将获得资金。要达到这样的保证，时间限制必须放在UTXO上，并成为锁定脚本的一部分，而不是交易的一部分。这是通过称为 检查锁定时间验证 Check Lock Time Verify (CLTV) 的下一种时间形式实现的。 Check Lock Time Verify (CLTV) 2015年12月，一种新的时间锁形式作为软分叉升级引入了比特币。根据BIP-65中的规范，一种名为 CHECKLOCKTIMEVERIFY（CLTV）的脚本操作符添加到脚本语言中。 CLTV 是每个输出的时间锁，而不是 使用 nLocktime 情况下的每个交易的时间锁。允许时间锁的应用更加灵活。 简而言之，通过在输出的赎回脚本中添加 CLTV 操作码，可以限制输出只能在指定的时间过后才能使用。 > nLocktime 是交易级别的时间锁，CLTV 是基于输出的时间锁。 CLTV 并没有取代 nLocktime，而是限制特定UTXO，以使它们只能在 nLocktime 设置为更大或相等的值的未来交易中使用。 CLTV 操作码将一个参数作为输入，该参数以与 nLocktime（区块高度或Unix纪元时间）相同的格式表示。如 VERIFY 后缀所示，CLTV 是在结果为 FALSE 时停止执行脚本的操作码。如果结果为TRUE，则继续执行。 为了用 CLTV 锁定输出，可以在创建这笔输出的交易中，将其插入到输出的赎回脚本中。例如，如果Alice正在向Bob的地址支付，输出通常会包含如下所示的P2PKH脚本： DUP HASH160 EQUALVERIFY CHECKSIG 为了将其锁定一段时间，比如从现在开始3个月，这笔交易将带有如下的赎回脚本： CHECKLOCKTIMEVERIFY DROP DUP HASH160 EQUALVERIFY CHECKSIG 其中 是从这笔交易被开采后3个月的区块高度或者时间戳估计，当前区块高度 + 12,960 (区块) 或者 当前Unix时间戳 + 7,760,000 (秒). 现在，不要在意 CHECKLOCKTIMEVERIFY 之后的 DROP 操作符，我们之后会解释。 当Bob尝试花费这个UTXO时，构建一个以UTXO作为输入的交易，在输入的解锁脚本中使用他的签名和公钥，并将交易的 nLocktime 设置为等于或大于 CHECKLOCKTIMEVERIFY 中Alice设置的 timelock，然后在比特币网络上广播交易。 Bob的交易被进行如下的评估，如果Alice设置的 CHECKLOCKTIMEVERIFY 的参数小于或等于消费交易的 nLocktime，则脚本执行继续（如同执行 \"no operation\" 或NOP操作码一样）。否则，脚本执行会停止，并且交易被视为无效。 更准确地说，CHECKLOCKTIMEVERIFY 失败并暂停执行，标记交易无效，如果达成以下条件（来源：BIP-65）： 栈为空；或者 栈顶元素小于0；或者 栈顶元素锁定时间的类型（区块高度或时间戳）与 nLocktime 字段不同；或者 栈顶元素大于交易的 nLocktime 字段；或者 输入的 nSequence 字段为 0xffffffff。 > CLTV 和 nLocktime 使用相同的格式来描述时间锁，可以是区块高度，也可以是自Unix纪元以来的秒数。重要的是，当一起使用时，nLocktime 的格式必须与输出中的 CLTV 的格式匹配 —— 它们都必须表示区块高度，或以秒为单位的时间。 执行后，如果满足 CLTV，则其前面的时间参数将保留为栈顶元素，需要使用 DROP 将其删除，以正确执行后续脚本操作码。出于这个原因，你经常会在脚本中看到 CHECKLOCKTIMEVERIFY 和 DROP。 通过将 nLocktime 与 CLTV 结合使用，交易锁定时间限制 中描述的场景会发生变化。Alice不能再花费这笔资金了（因为它被Bob的密钥锁定），Bob在3个月的锁定时间到期之前也不能花费。 通过将时间锁功能直接引入脚本语言，CLTV 允许我们开发一些非常有趣的复杂脚本。 标准的定义参见 BIP-65 (CHECKLOCKTIMEVERIFY)。 相对时间锁 nLocktime 和 CLTV 都是 绝对的时间锁 absolute timelocks，表示一个绝对的时间点。接下来我们要研究的两个时间锁功能是 相对时间锁 relative timelocks，它们指定从输出在区块链中被确认时开始的一段时间，作为花费输出的条件。 相对时间锁是有用的，它们允许两个或多个相互依赖的交易组成的交易链进行脱链处理，对一个依赖于前一个交易确认后一段时间的交易施加时间限制。换句话说，直到UTXO被记录在区块链上时，时钟才会开始计数。这个功能在双向状态通道（bidirectional state channels）和闪电网络（Lightning Networks）中特别有用，我们将在 [state_channels] 中看到。 相对时间锁与绝对时间锁一样，都是通过交易级功能和脚本级操作码实现的。交易级别的相对时间锁实现为 nSequence（每个交易输入中设置的字段）值的共识规则。脚本级别的相对时间锁使用 CHECKSEQUENCEVERIFY（CSV）操作码实现。 相对时间锁是根据 BIP-68, Relative lock-time using consensus-enforced sequence numbers 和 BIP-112, CHECKSEQUENCEVERIFY 中的规范实现的。 BIP-68和BIP-112于2016年5月作为共识规则的软分叉升级启用。 nSequence相对时间锁 通过设置 nSequence 字段，可以在交易的每个输入上设置相对时间锁。 nSequence的原始含义 nSequence 字段的本意在于（但从未正确实施）允许修改 mempool 中的交易。在该用途中，包含 nSequence 值低于 232 - 1（0xFFFFFFFF）的输入的交易指示尚未“完成”的交易。这样的交易将保留在 mempool 中，直到它被另一个花费相同的输入但具有更高的 nSequence 值的交易替代。一旦接收到输入的 nSequence 值为 0xFFFFFFFF 的交易，它将被视为“完成的”并被开采。 nSequence 的原始含义从未正确实现，nSequence 的值通常在不使用时间锁定的交易中被设置为0xFFFFFFFF。对于具有 nLocktime 或 CHECKLOCKTIMEVERIFY 的交易，必须将 nSequence 值设置为小于 231，才能使时间保护具有效果，如下所述 nSequence 作为共识执行的相对时间锁 自BIP-68启用以来，新的共识规则适用于包含 nSequence 值小于231的输入的任何交易。从编程的角度来说，这意味着如果最高有效位（第1 具有小于 231 的 nSequence 值的交易输入被解释为具有相对时间锁。这种交易只有在输入已经过相对时间锁表示的时间后才有效。例如，具有 nSequence 为30个块的相对时间锁的一个输入的交易，仅在从输入中引用的UTXO被开采的时间起，至少经过30个块时才有效。由于 nSequence 是每个输入的字段，交易可能包含任意数量的时间锁定输入，所有这些输入都必须满足时间要求交易才有效。一个交易可以同时包括时间锁定的输入（ nSequence = 231 ）。 nSequence 值以块或秒为单位，但与我们在 nLocktime 中使用的格式略有不同。类型标志（type-flag）用于区分表示区块数还是表示时间（以秒为单位）。类型标志被设置在第23个最低有效位（即值1 当将 nSequence 解释为相对时间锁时，仅考虑16个最低有效位。一旦标志位（比特32和23）检测完成，通常使用 nSequence 的16位掩码（例如，nSequence ＆ 0x0000FFFF ）。 BIP-68 definition of nSequence encoding (Source: BIP-68) 展示了 nSequence 的二进制结构, 由 BIP-68 定义。 Figure 1. BIP-68 definition of nSequence encoding (Source: BIP-68) 基于 nSequence 值共识执行的相对时间锁在BIP-68中定义。 这个标准定义在 BIP-68, Relative lock-time using consensus-enforced sequence numbers 中。 使用CSV的相对时间锁 与CLTV和 nLocktime 一样，有一个在脚本中使用 nSequence 值作为相对时间锁的脚本操作码。该操作码是 CHECKSEQUENCEVERIFY，通常简称为 CSV。 在UTXO的赎回脚本中执行时，CSV 操作码仅允许输入的 nSequence 值大于或等于 CSV 参数的交易。从本质上讲，这限制了UTXO直到相对于UTXO开采的时间已经过去了一定数量的区块或秒之后才能被花费。 与CLTV一样，CSV 中的值必须与相应的 nSequence 值中的格式匹配。如果 CSV 指定的是区块数量，nSequence 也必须是区块数量。如果 CSV 指定的是秒，那么 nSequence 也必须是秒。 当几个（链接的）交易被创建和签名，但保持“脱链”状态不会传播时，使用 CSV 的相对时间锁特别有用。直到父交易被传播，开采和沉淀到相对时间锁定中指定的时间后，才能使用子交易。可以在 [state_channels] 和 [lightning_network] 中看到这个用例的应用。 CSV 在 BIP-112, CHECKSEQUENCEVERIFY 中详细定义。 过去中位时间 Median-Time-Past 作为启用相对时间锁的一部分，时间锁（绝对和相对）的“时间”计算方式有所变化。在比特币中，实际时间（wall time）和共识时间（consensus time）之间存在着微妙但重要的差异。比特币是一个去中心化的网络，这意味着每个参与者都有自己的时间视角。网络上的事件并不是每时每刻都在发生。必须在每个节点的角度考虑网络延迟。最终，所有内容都会同步,创建一个公共的账本。与 过去 一样，比特币每隔10分钟就会对账本的状态达成共识。 区块头中的时间戳是由矿工设置的。共识规则留有一定的余地来解决分散的节点之间的时钟精度差异。然而，这带来了一种不幸的激励，促使矿工在一个区块内对时间撒谎，以便通过纳入尚未成熟的时间锁定交易来收取额外的费用。有关更多信息，请参见下面的部分。 为了消除对撒谎的激励，并加强时间锁的安全性，BIP-113与关于相对时间锁的BIP同时提出并被启用，它定义了一个称为 过去中位时间 Median-Time-Past 的新的一直的时间测量方法。 Median-Time-Past 过去11个区块的时间戳并的中位数。中位时间成为共识时间，并用于所有时间锁的计算。通过取过去大约两个小时的中点，任何一个区块的时间戳影响都会减小。通过结合11个区块，没有一个矿工可以为了获得尚未成熟的时间锁定交易费用而影响时间戳。 Median-Time-Past改变了 nLocktime，CLTV，nSequence 和 CSV 的时间计算实现。由Median-Time-Past计算的共识时间总是比实际时间晚大约一个小时。如果你创建时间锁定交易，应该在估计 nLocktime，nSequence，CLTV 和 CSV 中编码的时间时考虑这一点。 Median-Time-Past 在 BIP-113 中被定义。 对抗费用狙击的时间锁防御 Timelock Defense Against Fee Sniping 费用狙击（Fee-sniping）是一种理论上的攻击场景，表示试图改写过去的区块的矿工“狙击”未来区块中更高费用的交易，来最大化盈利的方法。 例如，假设现在的最高块是块＃100,000。一些矿工尝试重新开采区块 #100,000，而不是尝试开采区块＃100,001来增长区块链。这些矿工可以选择在他们的候选区块＃100,000中包含任何有效的交易（尚未开采）。他们不必通过相同的交易来重新开采区块。事实上，他们有动力选择最有利可图的（每KB最高费用）交易并包含在他们的区块中。它们可以包括任何在“旧”块＃100,000中的交易，也可以包含来自当前mempool的任何交易。本质上，当他们重新创建块＃100,000时，他们可以选择将交易从“现在”转移到重写的“过去”。 今天，这种攻击不是很有利可图，因为区块奖励远高于每个区块的总费用。但是在将来，交易费用将成为奖励的一大部分（甚至奖励的全部）。那时候，这种情况就不可避免了。 在Bitcoin Core创建交易时，为了防止“费用狙击”，会默认使用 nLocktime 将其限制为“下一个区块”。在我们的场景中，Bitcoin Core会在其创建的任何交易中将 nLocktime 设置为100,001。正常情况下，这个 nLocktime 不起作用 —— 无论如何，交易只能包含在＃100001区块中；这是下一个区块。 但是，在区块链分叉攻击下，矿工们将无法从mempool中获取高额交易，因为所有这些交易都会被锁定到＃100,001区块。他们只能使用当时有效的交易重新计算＃100,000，实质上不会获得新的费用。 为此，Bitcoin Core将所有新交易的 nLocktime 设置为 ，并将所有输入的 nSequence 设置为0xFFFFFFFE以启用 nLocktime。 流程控制脚本（条件语句） 比特币脚本的一个更强大的功能是流程控制，也称为条件语句。你可能熟悉多种语言中的 IF...THEN...ELSE 流程控制。比特币的条件语句看起来有点不同，但基本构造是相同的。 比特币条件操作码允许我们构建一种有两种解锁方式的赎回脚本，取决于条件语句的结果是 TRUE 还是 FALSE。例如，如果 x 为 TRUE，则赎回脚本为A，否则（ELSE），赎回脚本为B. 此外，比特币条件表达式可以无限“嵌套”，条件语句可以包含另一个条件语句。比特币流程控制脚本可用于构建具有数百或甚至数千个可能的执行路径的复杂脚本。嵌套没有限制，但共识规则会对脚本的最大大小（以字节为单位）施加限制。 比特币使用 IF，ELSE，ENDIF 和 NOTIF 操作码实现流程控制。此外，条件表达式可以包含布尔运算符，例如 BOOLAND，BOOLOR，和 NOT。 乍一看，你可能会对比特币的流程控制脚本感到困惑。这是因为比特币脚本是一种堆栈语言。 1 AND 1 逆序表示为 1 1 ADD。 在大多数传统（过程式）编程语言中，流程控制看起来是这样的： Pseudocode of flow control in most programming languages if (condition): code to run when condition is true else: code to run when condition is false code to run in either case 在类似比特币脚本的基于堆栈的语音中，逻辑条件放在 IF 之前，使其看起来是逆序的： Bitcoin Script flow control condition IF code to run when condition is true ELSE code to run when condition is false ENDIF code to run in either case 在阅读比特币脚本时，记住条件判断是在 IF 操作码之前的。 条件语句的 VERIFY 操作码 比特币脚本中另外一种条件形式是以 VERIFY 结尾的任何操作码。VERIFY 后缀表示如果所评估的条件不是 TRUE，脚本将立即终止执行，并且交易被视为无效。 与 IF 语句提供不同的执行路径不同，VERIFY 后缀用作 守护语句 guard clause, 只有满足前面的条件时继续执行。 例如，以下脚本需要Bob的签名和产生特定散列的原象（pre-image）（密钥）。必须满足这两个条件才能解锁： A redeem script with an EQUALVERIFY guard clause. HASH160 EQUALVERIFY CHECKSIG 为了赎回这笔资金, Bob 必须创建提供原象（pre-image）和签名的解锁脚本： An unlocking script to satisfy the above redeem script 在不提供原象的情况下，Bob无法执行到检查其签名的脚本部分。 这个脚本可以用 IF 语句写成: A redeem script with an IF guard clause HASH160 EQUAL IF CHECKSIG ENDIF Bob的解锁脚本是相同的: An unlocking script to satisfy the above redeem script 带 IF 的脚本与使用 VERIFY 后缀的操作码的功能相同；他们都作为守护语句运行。但是，VERIFY 构造更高效，使用两个较少的操作码。 那什么时候使用 VERIFY，什么时候使用 IF 呢？如果我们只是附加一个先决条件（guard clause），那么 VERIFY 更好。但是，如果有多个执行路径（流程控制），那么需要使用 IF...ELSE 流程控制语句。 > 诸如 EQUAL 之类的操作码会将结果（ TRUE 或 FALSE ）推到堆栈上，用于后续操作码的判断。相反，操作码 EQUALVERIFY 不会在堆栈中留下任何内容。以 VERIFY 结尾的操作码都不会将结果留在堆栈上。 在脚本中使用流程控制 比特币脚本中，流程控制的一个常见用途是构建赎回脚本，提供多个执行路径，每种赎回方式都可以赎回UTXO。 看一个简单的例子，有两个签名者，Alice和Bob，任何一个都可以兑换。使用multisig时，这将表示为 1-of-2 的多重签名脚本。为了演示，我们使用 IF 语句做同样的事情： IF CHECKSIG ELSE CHECKSIG ENDIF 看到这个赎回脚本，你可能会想：“条件在哪里？在 IF 语句之前没有任何东西啊！” 条件不是赎回脚本的一部分。而是在解锁脚本中提供，从而允许 Alice 和 Bob “选择” 他们想要的执行路径。 Alice使用以下解锁脚本进行赎回： 1 最后的 1 作为条件（TRUE），使 IF 语句执行Alice签名的第一个赎回路径。 如果Bob要赎回，他必须通过给 IF 语句提供一个 FALSE 值来选择第二个执行路径： 0 Bob的解锁脚本在栈上放置了 0，导致 IF 语句执行第二个（ ELSE ）脚本，从而需要Bob的签名。 由于 IF 语句可以嵌套，我们可以创建执行路径的“迷宫”。解锁脚本可以提供一个选择执行路径实际执行的“映射”： IF script A ELSE IF script B ELSE script C ENDIF ENDIF 在这种情况下，有三个执行路径（脚本A，脚本B 和 脚本C）。解锁脚本以 TRUE 或 FALSE 值的顺序提供路径。例如，要选择路径 脚本B，解锁脚本必须以 1 0（ TRUE，FALSE ）结尾。这些值将被压入堆栈，以便第二个值（ FALSE ）作为堆栈顶部。外层的 IF 语句弹出 FALSE 并执行第一个 ELSE 语句。然后 TRUE 移动到栈顶，并由内部的（嵌套的）IF 判断，从而选择 B 执行路径。 使用这种构造，我们可以用数十或数百个执行路径构赎回脚本，每个脚本都提供了一种不同的方式来赎回UTXO。为了花费UTXO，我们构建一个解锁脚本，通过在每个流程控制点的栈上放置相应的 TRUE 和 FALSE 来选择执行路径。 复杂脚本示例 在本节中，我们将本章中的许多概念结合到一个示例中。 我们的例子使用了迪拜公司所有者Mohammed的故事，该公司经营进出口业务。 在这个例子中，Mohammed希望建立一个规则灵活的公司资本账户。他创建的方案需要根据时间锁进行不同级别的授权。多重签名方案的参与者是Mohammed，他的两个合伙人Saeed和Zaira，以及他们公司的律师Abdul。三位合伙人根据多数规则作出决定，即三位合伙人中的两位必须同意。但是，如果他们的密钥出现问题，他们希望他们的律师能够用三个合伙人中一个的签名来恢复资金。最后，如果所有合作伙伴都暂时没空或无法工作，他们希望律师能够直接管理帐户。 以下是Mohammed设计的实现此目标的赎回脚本： Variable Multi-Signature with Timelock 01 IF 02 IF 03 2 04 ELSE 05 CHECKSEQUENCEVERIFY DROP 06 CHECKSIGVERIFY 07 1 08 ENDIF 09 3 CHECKMULTISIG 10 ELSE 11 CHECKSEQUENCEVERIFY DROP 12 CHECKSIG 13 ENDIF Mohammed的脚本使用嵌套的 IF...ELSE 流程控制语句实现了三个执行路径。 在第一个执行路径中，这个脚本作为一个简单的 2-of-3 多重签名。此执行路径由第3行和第9行组成。第3行将multisig的法定数设置为 2（2/3）。这个执行路径可以通过在解锁脚本的末尾加上 TRUE TRUE 来选择： Unlocking script for the first execution path (2-of-3 multisig) 0 TRUE TRUE > 这个解锁脚本开头的 0 是因为 CHECKMULTISIG 中的一个错误，它会从堆栈中弹出一个额外的值。额外的值被 CHECKMULTISIG 忽略，但它必须存在。正如 CHECKMULTISIG执行中的一个错误 中所述，推入 0（通常）是该bug的解决方法。 第二个执行路径只能在创建 UTXO 30天后才能使用。到时，它需要律师Abdul和三个合伙人之一的前面（ 1-of-3 的多重签名 ）。这通过第7行来实现，该行将multisig的法定数设置为 1。要选择此执行路径，解锁脚本将以 FALSE TRUE 结束： Unlocking script for the second execution path (Lawyer + 1-of-3) 0 FALSE TRUE > 为什么 FALSE TRUE？因为这两个值被推送到堆栈上，所以首先推入 FALSE ，然后再推入 TRUE。 因此 TRUE 被第一个 IF 操作码弹出。 最后，第三个执行路径允许律师Abdul单独花费资金，但只能在90天后。要选择此执行路径，解锁脚本必须以 FALSE 结尾： Unlocking script for the third execution path (Lawyer only) FALSE 尝试在纸上运行脚本以查看它在堆栈上的行为。 阅读本示例时需要考虑几件事情。看看你能否找到答案： 为什么律师无法通过在解锁脚本上选择 FALSE 执行第三条路径来随时赎回？ 在UTXO开采之后的5天，35天和105天，分别可以使用的执行路径数量？ 如果律师失去了密钥，资金是否会流失？如果91天过去了，你的答案会改变吗？ 合伙人如何每隔29或89天“重置”时钟以防止律师获得资金？ 为什么这个脚本中的一些 CHECKSIG 操作码有 VERIFY 后缀，而其他的则没有？ 隔离见证 Segregated Witness 隔离见证 Segregated Witness (segwit) 是比特币共识规则和网络协议的升级，由BIP-9提出并作为软分叉实施，于2017年8月1日在比特币主网启用。 在密码学中，术语“见证”用于描述密码谜题的解决方案。对比特币来说，“见证”能够满足放在未支付交易输出（UTXO）上的加密条件。 在比特币的情况下，数字签名是“见证”的一种类型，但更宽泛地来说，“见证”是能够满足UTXO所设置的条件，解锁并花费UTXO的任何解决方案。术语“见证”是“解锁脚本”或“scriptSig”的更一般的术语。 在segwit引入之前，交易中的每个输入之后都是解锁它的见证数据。见证数据作为每个输入的一部分嵌入在交易中。术语 segregated_witness 或简称 segwit 仅仅意味着将特定输出的签名或解锁脚本分离。考虑最简单的形式，“单独的scriptSig”或“单独签名”。 因此，隔离见证是比特币的体系结构变化，旨在将见证数据从交易的 scriptSig（解锁脚本）字段移动到伴随交易的单独的 witness 数据结构中。客户端可以选择是否附带见证数据请求交易。 在本节中，我们将看看隔离见证的好处，描述部署和实施此架构的机制，并演示如何在交易和地址中使用隔离见证。 隔离见证由以下BIP定义: BIP-141 Segregated Witness 的主要定义。 BIP-143 版本0见证程序的交易签名验证 BIP-144 对等服务 - 新的网络消息和序列化格式 BIP-145 隔离见证的getblocktemplate（用于挖矿）更新 BIP-173 原生 v0-16 见证输出的 Base32 地址格式 为什么要隔离见证? 隔离见证是一种体系结构变化，它对比特币的可扩展性，安全性，经济效益和性能有以下影响： 交易可锻性 Transaction Malleability 通过将见证数据移动到交易外部，用作标识符的交易哈希将不再包含见证数据。由于见证数据是交易中唯一可以由第三方修改的部分（请参阅 交易标识符 Transaction identifiers ），因此去除它也消除了交易可锻性攻击的机会。使用隔离见证，交易哈希变得不可能由交易的创建者以外的任何人改变，这极大地改进了许多其他协议的实施，这些协议依赖于先进的比特币交易建设，例如支付通道，链式交易和闪电网络。 脚本版本控制 Script Versioning 通过隔离见证脚本的进入，每个锁定脚本前面都有一个 script_version 数字，类似于交易和区块的版本号。脚本版本号的添加允许脚本语言以向后兼容的方式升级（即使用软叉升级）来引入新的脚本操作符，语法或语义。以无中断方式升级脚本语言的能力将大大加速比特币的创新速度。 网络和存储的可扩展性 Network and Storage Scaling 见证数据通常是交易总规模的主要贡献者。更复杂的脚本，比如用于multisig或支付通道的脚本非常庞大。在某些情况下，这些脚本占交易数据的大部分（超过75％）。将见证数据移到交易之外，提高了比特币的可扩展性。节点可以在验证签名后裁剪见证数据，或者在进行简单付款验证时完全忽略见证数据。见证数据不需要传输到所有节点，也不需要被所有节点存储在磁盘上。 签名验证优化 Signature Verification Optimization 隔离见证升级了签名方法（ CHECKSIG，CHECKMULTISIG 等）以降低算法的计算复杂度。在隔离之前，用于生成签名的算法需要一些与交易大小成正比的散列操作。数据散列的计算复杂度相对于签名操作是O(n2），在验证签名的所有节点上引入了大量的计算负担。使用segwit时，算法将复杂度降低到O(n)。 离线签名改进 Offline Signing Improvement 隔离见证签名包含了签名的散列中每个输入引用的值（金额）。以前，离线签名设备（如硬件钱包）必须在签署交易之前验证每个输入的数量。这通常是通过流式传输大量关于以引用为输入的交易的数据来完成的。由于金额现在是已签名的散列的一部分，因此离线设备不需要先前的事务。如果金额不匹配（由被入侵的系统篡改），签名将无效。 隔离见证如何工作 隔离见证看起来改变了交易如何构建，是交易层面的特性，但事实并非如此。相反，隔离见证是对如何花费单个UTXO的改变，因此是每个输出层面的特性。 交易可以花费隔离见证的输出或传统（内联见证）的输出，或同时花费两者。因此，将交易称为“隔离见证交易”没有什么意义。我们应该将具体的交易输出称为“隔离见证输出”。 当交易花费UTXO时，它必须提供见证。在传统的UTXO中，锁定脚本要求在花费UTXO的交易的输入部分提供 在线的 见证数据。然而，隔离见证UTXO指定了一个锁定脚本，它可以被输入之外的（隔离的）见证数据满足。 软分叉 (向后兼容) 隔离见证是输出和交易架构方式的重大变化。这种改变通常需要每个比特币节点和钱包同时改变以升级共识规则 —— 所谓的硬分叉。然而，隔离见证的引入具有较少的破坏性变化，是向后兼容的，被称为软分叉。这种类型的升级允许非升级软件忽略更改并继续运行而不会中断。 隔离见证构建的输出，使不能识别\"见证\"的旧系统仍然可以验证它们。对于旧的钱包或节点，隔离见证输出看起来像是任何人都可以花费的输出。这样的输出可以用一个空的签名来花费，交易内部没有签名（隔离的）并不会使交易失效。然而，较新的钱包和挖矿节点会看到隔离见证输出，并期望在交易的见证数据中找到有效的见证。 隔离见证输出和交易示例 让我们来看一些示例交易，看它们将如何随着隔离见证改变。首先看一下如何使用隔离见证程序来转换Pay-to-Public-Key-Hash（P2PKH）。然后，看一下Pay-to-Script-Hash（P2SH）脚本的隔离见证等价物。最后，我们将看看如何将之前的隔离见证程序嵌入到P2SH脚本中。 Pay-to-Witness-Public-Key-Hash (P2WPKH) 在 [cup_of_coffee] 中，Alice创建了一笔交易，向Bob购买一杯咖啡。该交易创建了一个值为0.015 BTC的P2PKH输出，该输出可由Bob使用。输出的脚本如下所示： Example P2PKH output script DUP HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 EQUALVERIFY CHECKSIG 使用隔离见证，Alice将创建一个 Pay-to-Witness-Public-Key-Hash (P2WPKH) 脚本, 看起来如下: Example P2WPKH output script 0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 如你所见，隔离见证输出的锁定脚本比传统输出简单得多。它由推送到脚本计算堆栈的两个值组成。对于老的（不支持隔离见证的 nonsegwit-aware ）比特币客户端来说，这看起来像是任何人都可以花费的输出，并且不需要签名（或者更确切地说，可以使用空签名）。对于一个更新的，支持segwit的客户端，第一个数字（0）被解释为版本号（witness version），第二部分（20字节）相当于被称为 witness program 的锁定脚本。20字节的见证程序就是公钥的散列，就像在P2PKH脚本中一样。 现在，我们来看看Bob用来花费这个输出的相应的交易。对于原始脚本（nonsegwit），Bob的交易必须在交易输入中包含签名 Decoded transaction showing a P2PKH output being spent with a signature [...] “Vin” : [ \"txid\": \"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2\", \"vout\": 0, \"scriptSig\": “”, ] [...] 但是，要花费隔离见证的输出，交易在那个输入上没有签名。相反，Bob的交易包含一个空的 scriptSig 和一个在交易之外的隔离见证。 Decoded transaction showing a P2WPKH output being spent with separate witness data [...] “Vin” : [ \"txid\": \"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2\", \"vout\": 0, \"scriptSig\": “”, ] [...] “witness”: “” [...] 钱包的P2WPKH构建 注意到P2WPKH只能由收款人创建，而不能由付款人从已知公钥，P2PKH脚本或地址转换，这一点非常重要。付款人无法知道收款人的钱包是否有能力构建隔离见证交易并花费P2WPKH输出。 此外，P2WPKH输出必须由 压缩公钥的散列构造。未压缩的公钥在segwit中是非标准的，并且可能会被未来的软分支明确禁用。如果P2WPKH中使用未压缩的公钥散列，则它可能是不可靠的，你可能会失去资金。 P2WPKH输出应该由收款人的钱包通过从其私钥导出的压缩公钥来创建。 > P2WPKH应由收款人通过将压缩公钥转换为P2WPKH哈希来构造。你不应将P2PKH脚本，比特币地址或未压缩的公钥转换为P2WPKH见证脚本。 Pay-to-Witness-Script-Hash (P2WSH) 第二种见证程序对应于支付到脚本哈希（P2SH）的脚本。我们在 支付到脚本哈希 Pay-to-Script-Hash (P2SH) 中看到过这种类型的脚本。在这个例子中，Mohammed的公司使用P2SH来表示多重签名脚本。对Mohammed的公司的付款用这种锁定脚本编码： Example P2SH output script HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL 该P2SH脚本引用了 赎回脚本 redeem_script 的散列，该脚本定义了花费资金的 2-of-3 多重签名要求。为了使用这种输出，Mohammed的公司将在交易输入中提供赎回脚本（其哈希与P2SH输出中的脚本哈希匹配）以及满足赎回脚本所需的签名： Decoded transaction showing a P2SH output being spent [...] “Vin” : [ \"txid\": \"abcdef12345...\", \"vout\": 0, \"scriptSig\": “ ”, ] 现在，让我们看看整个示例如何升级到segwit。如果Mohammed的客户使用兼容segwit的钱包，他们将创建一个付款，包含一个Pay-to-Witness-Script-Hash（P2WSH）输出，看起来像这样： Example P2WSH output script 0 a9b7b38d972cabc7961dbfbcb841ad4508d133c47ba87457b4a0e8aae86dbb89 同样，与P2WPKH的例子一样，你可以看到隔离见证等效脚本更简单，并且省略了你在P2SH脚本中看到的各种脚本操作数。相反，隔离见证程序由推送到堆栈的两个值组成：见证版本（0）和赎回脚本的32字节SHA256散列。 > 虽然P2SH使用20字节 RIPEMD160( SHA256(script) ) 散列，P2WSH见证程序使用32字节 +SHA256(script)+散列。这种散列算法选择上的差异是故意的，用于区分两种类型的见证程序（P2WPKH和P2WSH）之间的哈希长度，并为P2WSH提供更强的安全性（P2WSH中的128位安全性，对比P2SH中的80位安全性）。 Mohammed的公司可以通过提供正确的赎回脚本和足够的签名来满足它，用于花费P2WSH的输出。作为见证数据的一部分，赎回脚本和签名都将作为消费交易的一部分进行隔离。在交易输入中，Mohammed的钱包会放置一个空的 scriptSig ： Decoded transaction showing a P2WSH output being spent with separate witness data [...] “Vin” : [ \"txid\": \"abcdef12345...\", \"vout\": 0, \"scriptSig\": “”, ] [...] “witness”: “ ” [...] P2WPKH 和 P2WSH 的区别 在前两节中，我们演示了两种类型的见证程序：Pay-to-Witness-Public-Key-Hash (P2WPKH) 和 Pay-to-Witness-Script-Hash (P2WSH)。两种见证程序都由一个单字节版本号和一个较长的散列组成。它们看起来非常相似，但是却有着不同的解释：一个被解释为一个公钥的哈希，它被签名满足，另一个被解释为脚本的哈希，被一个赎回脚本满足。它们之间的关键区别在于哈希的长度： P2WPKH 中公钥的哈希是 20 字节 P2WSH 中脚本的哈希是 32 字节 这是允许钱包区分两种见证程序的一个区别。通过查看散列的长度，钱包可以确定它是什么类型的见证程序，P2WPKH或P2WSH。 升级到隔离见证 从前面的例子可以看出，升级为隔离见证是一个两步的过程。首先，钱包必须创建特殊的隔离型输出。然后，这些输出可以被知道如何构建隔离见证交易的钱包花费。在这些例子中，Alice的钱包支持segwit，能够使用Segregated Witness脚本创建特殊输出。鲍勃的钱包也是支持segwit的，能够花费那些输出。从这个例子中可能不明显的是，在实践中，Alice的钱包需要知道Bob使用了一个支持segwit的钱包并可以使用这些输出。否则，如果Bob的钱包没有升级，当Alice试图向Bob进行segwit支付，那么Bob的钱包将无法检测到这些支付。 > 对于P2WPKH和P2WSH付款类型，付款人和收款人的钱包都需要升级才能使用segwit。此外，付款人的钱包需要知道收款人的钱包是否具有隔离见证功能。 隔离见证不会在整个网络中同时实施。而是向后兼容的升级，新老客户可以共存。钱包开发人员将独立升级钱包软件以添加隔离见证功能。当付款人和收款人都支持隔离见证时，可以使用P2WPKH和P2WSH付款类型。传统的P2PKH和P2SH将继续为没有升级的钱包工作。这留下了两个重要的场景，下一节将讨论这些： 付款人的钱包不支持隔离见证的，向支持隔离见证的收款人钱包付款 付款人的支持隔离见证的钱包通过地址识别和区分收款方是否支持隔离见证的能力 P2SH中嵌入的隔离见证 举个例子，假设Alice的钱包没有升级到segwit，但是Bob的钱包已升级并可以处理segwit交易。 Alice和Bob可以使用“旧”的非segwit交易。但是Bob可能想使用segwit，利用适用于隔离见证的折扣，降低交易费用。 在这种情况下，Bob的钱包可以构建一个内部包含segwit脚本的P2SH地址。Alice的钱包将其视为“正常”的P2SH地址，并且可以在不知道segwit的情况下付款。然后Bob的钱包可以通过segwit交易来花费这笔款项，充分利用segwit并降低交易费用。 两种形式的见证脚本，P2WPKH 和 P2WSH，都可以嵌入到P2SH地址中。第一个被记作P2SH（P2WPKH），第二个被记作P2SH（P2WSH）。 Pay-to-Script-Hash 中的 Pay-to-Witness-Public-Key-Hash 我们将研究的第一种见证脚本是P2SH（P2WPKH）。这是一个Pay-to-Witness-Public-Key-Hash见证程序，嵌入在Pay-to-Script-Hash脚本中，以便它可以被不知道segwit的钱包使用。 Bob的钱包用Bob的公钥构造了一个P2WPKH见证程序。这个见证程序之后被散列，并将结果编码为P2SH脚本。这个P2SH脚本转换为比特币地址，其中一个以“3”开头，正如我们在 支付到脚本哈希 Pay-to-Script-Hash (P2SH) 部分看到的那样。 Bob的钱包从我们之前看到的P2WPKH见证程序开始： Bob’s P2WPKH witness program 0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 P2WPKH见证程序由见证版本和Bob的20字节公钥散列组成。 Bob的钱包然后对之前的见证程序进行散列，首先是SHA256，然后是RIPEMD160，产生另一个20字节的哈希值。 让我们使用命令行中的 bx 命令来重现： HASH160 of the P2WPKH witness program echo \\ '0 [ab68025513c3dbd2f7b92a94e0581f5d50f654e7]'\\ | bx script-encode | bx sha256 | bx ripemd160 3e0547268b3b19288b3adef9719ec8659f4b2b0b 接着，将赎回脚本的哈希值转换为比特币地址。再次使用 bx： P2SH address echo \\ '3e0547268b3b19288b3adef9719ec8659f4b2b0b' \\ | bx address-encode -v 5 37Lx99uaGn5avKBxiW26HjedQE3LrDCZru 现在，Bob可以对客户展示这个地址，让他们为咖啡付费。Alice的钱包可以支付给 37Lx99uaGn5avKBxiW26HjedQE3LrDCZru ，就像支付给任何其他比特币地址一样。 为了向Bob付款，Alice的钱包会使用如下的P2HSH脚本锁定输出： HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL 即使Alice的钱包不支持隔离见证，这笔付款也可以被Bob使用隔离见证交易消费： Pay-to-Script-Hash 中的 Pay-to-Witness-Script-Hash 类似地，多重签名脚本或其他复杂脚本的P2WSH见证程序也可以嵌入到P2SH脚本和地址中，使任何钱包都可以进行segwit兼容的支付。 正如我们在 Pay-to-Witness-Script-Hash (P2WSH) 中看到的，Mohammed的公司正在对多重签名脚本使用隔离见证付款。为了使任何客户都能向他的公司付款（无论他们的钱包是否升级到了支持segwit的版本），Mohammed的钱包可以在一个P2SH脚本中嵌入P2WSH见证程序。 首先，Mohammed的钱包用SHA256(仅此一次)将赎回脚本进行了散列。让我们在命令行上使用 bx 来完成: Mohammed’s wallet creates a P2WSH witness program echo \\ 2 \\ [04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \\ [04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \\ [047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \\ [0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \\ [043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \\ 5 CHECKMULTISIG \\ | bx script-encode | bx sha256 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73 接下来，散列后的赎回脚本转换为P2WSH见证程序： 0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73 然后，使用SHA256和RIPEMD160对见证程序本身进行散列处理，生成一个新的20字节的哈希，就像传统的P2SH那样，我们使用 bx 实验： The HASH160 of the P2WSH witness program echo \\ '0 [9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73]'\\ | bx script-encode | bx sha256 | bx ripemd160 86762607e8fe87c0c37740cddee880988b9455b2 再然后，钱包从这个哈希值构建一个P2SH比特币地址，使用 bx 实验： P2SH bitcoin address echo \\ '86762607e8fe87c0c37740cddee880988b9455b2'\\ | bx address-encode -v 5 3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG 现在，Mohammed的客户不需要必须支持segwit就可以支付到这个地址。要向Mohammed付款，钱包将用以下P2SH脚本锁定输出: P2SH script used to lock payments to Mohammed’s multisig HASH160 86762607e8fe87c0c37740cddee880988b9455b2 EQUAL 然后，Mohammed的公司可以利用segwit的好处(包括较低的交易费用)，构建segwit交易来花费这些款项。 隔离见证地址 即使是在segwit启用后，大部分的钱包升级也需要一些时间。一开始，segwit将被嵌入P2SH，如我们在前一节中看到的那样，来方便地兼容支持segwit和不支持segwit的钱包。 然而，一旦钱包广泛支持segwit，就有必要将目击者脚本直接编码成为segwit的原生地址格式，而不是嵌入到P2SH中。 原生segwit地址格式定义在 BIP-173 中： BIP-173 Base32 address format for native v0-16 witness outputs BIP-173仅对见证脚本（P2WPKH和P2WSH）进行编码。它与非segwit P2PKH或P2SH脚本不兼容。与传统的比特币地址的Base58编码相比，BIP-173是Base32校验和编码。 BIP-173地址也称为 bech32 地址，发音为 \"beh-ch thirty two\"，暗指使用“BCH”错误检测算法和32字符编码集。 BIP-173地址使用32个小写字母的字母数字字符集，经过仔细选择以减少误读或错误输入。通过只选择小写字母集，bech32更容易阅读，朗读，并且在QR码中的编码效率提高了45％。 BCH错误检测算法比以前的校验和算法(Base58Check)有了很大的改进，它不仅检测，还能纠正错误。地址输入接口(如表单中的文本框)可以检测并突出显示在检测错误时最可能出现错误的字符。 根据BIP-173规范，这里是一些 bech32 地址的示例: Mainnet P2WPKH bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 Testnet P2WPKH tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx Mainnet P2WSH bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3 Testnet P2WSH tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7 如你所见，segwit bech32字符串长达90个字符，由三个部分组成: 人类可读的部分 \"bc\" 或 \"tb\" 标明主网（ mainnet ）还是测试网（ testnet ）。 分隔符 数字 \"1\", 不是32字符编码集的一部分，只当做分隔符出现。 数据部分 至少6个字母数字字符，校验和编码的见证脚本 此时，只有少数钱包接受或生成原生segwit bech32地址，但随着segwit的广泛使用，你将越来越多地看到这些地址。 交易标识符 Transaction identifiers 隔离见证的最大好处之一是它消除了第三方交易可锻性。 在segwit之前，交易的签名可以被第三方微妙地修改，改变它们的交易ID(散列)，而不改变任何基本属性(输入、输出、数量)。这为拒绝服务攻击和攻击编写糟糕的钱包软件创造了机会，这些钱包假定未经确认的交易的哈希是不可变的。 通过引入隔离见证，交易有了两个标识符 txid 和 wtxid。传统的交易ID txid 是序列化交易的双SHA256散列，没有见证数据。交易的 wtxid 是具有见证数据的交易的新的序列化格式的双SHA256散列。 传统的 txid 的计算方式与nonsegwit交易完全相同。但是，由于segwit交易在每个输入中都有空的 scriptSig，因此不存在可由第三方修改的交易部分。因此，在segwit交易中，即使交易未经确认，txid 也是第三方不可变的。 wtxid 就像一个“扩展”的ID，因为这个哈希还包含了见证数据。如果交易不带有见证数据传输，那么 wtxid 和 txid 是相同的。注意，由于 wtxid 包含见证数据（签名），并且由于见证数据可能具有可锻性，所以应认为 wtxid 在交易确认之前具有可锻性。只有当交易的输入都是segwit输入时，segwit 交易的 txid 才能被认为是不可变的。 > 隔离见证交易有两个ID：txid 和 wtxid。 txid 是不包含见证数据的交易的哈希，wtxid 是包含见证数据的哈希。所有输入都为 segwit 输入的交易的 txid 不易受第三方交易可锻性影响。 隔离见证的新签名算法 隔离见证修改了四种签名验证函数（CHECKSIG，CHECKSIGVERIFY，CHECKMULTISIG 和 CHECKMULTISIGVERIFY）的语义，改变了交易保证哈希的计算方式。 比特币交易中的签名应用于commitment hash，这是根据交易数据计算的，锁定数据的特定部分，表明签名者对这些值的保证。例如，在简单的 SIGHASH_ALL 类型签名中，保证哈希包括所有输入和输出。 不幸的是，计算保证哈希的方式引入了验证签名的节点可能被迫执行大量哈希计算的可能性。具体而言，散列操作相对于交易中的签名操作的数量以 O(n2) 的复杂度增长。因此，攻击者可以创建带有大量签名操作的交易，导致整个比特币网络必须执行数百或数千次散列操作才能验证交易。 Segwit提供了通过改变保证哈希计算方式来解决这个问题的机会。对于segwit版本0见证程序，使用BIP-143中规定的改进的保证哈希算法进行签名验证。 新算法实现了两个重要目标。首先，散列操作的数量随着签名操作的数量逐渐以 O(n) 增长，减少了用过于复杂的交易创建拒绝服务攻击的机会。其次，保证散列现在还将每个输入的值（金额）作为散列的一部分，这意味着签名者无需“获取”并检查输入引用的前一个交易就可以保证特定的输入值。对于离线设备（例如硬件钱包），这大大简化了主机与硬件钱包之间的通信，消除了对以前的交易进行验证的需要。硬件钱包可以接受不受信任的主机“所声明的”输入值，因为如果输入值不正确则签名无效，硬件钱包在签名输入前不需要验证该值。 隔离见证的经济效益 比特币挖掘节点和完整节点会产生用于支持比特币网络和区块链的资源的成本。随着比特币交易量的增加，资源成本（CPU，网络带宽，磁盘空间，内存）也不断增加。矿工通过收取与每次交易的大小（字节）成比例的费用来补偿这些成本。非挖矿（Nonmining）完整节点没有得到补偿，蒙受了损失，因为他们需要运行一个权威的完全验证的全索引节点，可能是因为他们使用节点来经营比特币业务。 如果没有交易费用，比特币数据的增长可能会大幅增加。费用旨在通过基于市场的价格发现机制，将比特币用户的需求与交易对网络带来的负担相匹配。 基于交易规模的费用计算将交易中的所有数据视为成本相同的。但是从完整节点和矿工的角度来看，交易的某些部分承担了更高的成本。添加到比特币网络的每笔交易都会影响节点上四种资源的消耗： 硬盘空间 每笔交易都存储在区块链中，添加到区块链的总大小上。区块链存储在磁盘上，但是可以通过“删除”旧的交易来优化存储。 CPU 每笔交易都必须被验证，这需要CPU时间。 带宽 每笔交易都在网络上至少传输一次（通过泛洪传播），如果在块传播协议中没有进行任何优化，交易将作为块的一部分再次传输，从而对网络容量的影响加倍。 内存 验证交易的节点将UTXO索引或整个UTXO集保存在内存中，以加快验证。因为内存至少比磁盘贵一个数量级，所以UTXO集的增长不成比例地增加了运行节点的成本。 从列表中可以看出，并非交易的每个部分都对运行节点的成本或比特币支持更多交易的能力产生同等影响。交易中最昂贵的部分是新创建的输出，因为它们被添加到内存中的UTXO集合中。相比之下，签名（又名见证数据）为增加了最小的网络负担和节点运行成本，因为见证数据只被验证一次，然后再也不会使用。此外，在收到新的交易并验证见证数据之后，节点立即丢弃该见证数据。如果费用是根据交易规模计算的，而不区分这两种数据，那么市场化的费用激励就不符合交易实际施加的成本。实际上，目前的费用结构实际上鼓励了相反的行为，因为见证数据是交易的最大部分。 交易在其输入中花费UTXO，并在输出中创建新的UTXO。因此，一个输入数量大于输出数量的交易将导致UTXO集的减少，而一个输出数量大于输入数量的交易将导致UTXO集的增加。让我们考虑输入和输出之间的差异，并称之为\"净增UTXO\"（\"Net-new-UTXO\"）。这是一个重要的指标，因为它告诉我们一个交易将对网络中最昂贵的资源(即内存里的UTXO集)产生什么影响。Net-new-UTXO为正的交易增加负担，Net-new-UTXO为负的交易减少负担。因此，我们希望鼓励Net-new-UTXO为负或为0的交易。 让我们看一个例子，说明在有无隔离见证的情况下，交易费用计算产生了哪些激励。我们将看两个不同的交易。交易A是有3个输入2个输出的交易，Net-new-UTXO为-1。交易B是2个输入3个输出的交易，Net-new-UTXO为1，意味着它增加了一个UTXO到UTXO集，给整个比特币网络带来了额外的成本。这两笔交易都使用多重签名（2-of-3）脚本来说明复杂脚本如何增加隔离见证对费用的影响。假设交易费为每字节30 satoshi，见证数据拥有75％的费用折扣： Without Segregated Witness Transaction A fee: 25,710 satoshiTransaction B fee: 18,990 satoshi With Segregated Witness Transaction A fee: 8,130 satoshiTransaction B fee: 12,045 satoshi 这两种交易在实施隔离见证时都较为便宜。但是比较这两笔交易的成本，我们发现在隔离见证之前，Net-new-UTXO为负的交易费用较高。在隔离见证后，交易费用与鼓励减少新的UTXO产生的激励相一致，不会无意地惩罚有许多输入的交易。 因此，隔离见证对比特币用户支付的费用有两个主要影响。首先，segwit通过见证数据折扣，和增加比特币区块链的能力，来降低交易的总体成本。其次，segwit对见证数据的折扣纠正了可能无意中导致UTXO集合中更加膨胀的激励错配。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 15:03:15 "},"10第八章.html":{"url":"10第八章.html","title":"比特币网络","keywords":"","body":"比特币网络 点对点网络架构 比特币是构建在互联网之上的点对点网络体系结构。术语点对点（P2P）意味着参与网络的计算机是彼此对等的，它们都是平等的，没有“特殊”节点，并且所有节点都分摊提供网络服务的负担。网络节点以“扁平”拓扑互连在网状网络中。网络中没有中央服务器，没有集中化服务，也没有层次结构。 P2P网络中的节点同时提供和消费服务，彼此互惠。P2P网络具有天然的弹性，去中心性和开放性。P2P网络架构的一个卓越例子就是早期的互联网本身，IP网络上的节点是平等的。如今，互联网结构更有层次，但互联网协议仍然保留了其扁平拓扑的本质。除比特币之外，P2P技术最大最成功的应用是文件共享，Napster为先锋，BitTorrent是该架构的最新演变。 比特币的P2P网络架构不只是一种拓扑选择。比特币是一种P2P设计的数字现金系统，网络架构既是该核心特征的反映，也是其基础。控制权的去中心化是一个核心设计原则，只能通过一个扁平的，去中心化的P2P共识网络来实现和维护。 术语“比特币网络”是指运行比特币P2P协议的节点的集合。除比特币P2P协议外，还有其他一些协议，如Stratum，用于采矿和轻量级或移动钱包。这些附加协议由网关路由服务器提供，网关路由服务器使用比特币P2P协议访问比特币网络，然后将该网络扩展到运行其他协议的节点。例如，Stratum服务器通过Stratum协议将Stratum挖矿节点连接到比特币主网，并将Stratum协议连接到比特币P2P协议。我们使用术语“扩展比特币网络”来指包括比特币P2P协议，矿池协议，Stratum协议以及连接比特币系统组件的任何其他相关协议的整体网络。 节点类型和角色 尽管比特币P2P网络中的节点是对等的，但根据其支持的功能不同，它们承担的角色可能不同。比特币节点是一组功能的集合：路由，区块链数据库，挖矿和钱包服务。具有全部四个功能的完整节点显示在 A bitcoin network node with all four functions: wallet, miner, full blockchain database, and network routing 中。 Figure 1. A bitcoin network node with all four functions: wallet, miner, full blockchain database, and network routing 所有节点都包含用于参与网络的路由功能，可能包含其他功能。所有节点都会验证并传播交易和区块，并发现和维护与其他节点的连接。在 A bitcoin network node with all four functions: wallet, miner, full blockchain database, and network routing 的完整节点示例中，路由功能由名为“Network Routing Node”的橙色圆圈或字母“N”表示。 一些称为完整节点的节点也保留区块链的完整和最新的副本。完整的节点可以自主和权威地验证任何交易，无需外部参考。 一些节点只维护区块链的一个子集，并使用称为 simplified payment verification 或SPV的方法验证交易，这些节点被称为SPV节点或轻量级节点。在图中的完整节点示例中，完整节点区块链数据库功能由称为“Full Blockchain”或字母“B”的圆圈表示。在 The extended bitcoin network showing various node types, gateways, and protocols 中，SPV节点被绘制时没有“B”，表明它们没有完整的区块链副本。 挖矿节点通过运行专门的硬件解决Proof-of-Work算法来竞争创建新块。一些挖矿节点也是完整节点，维护区块链的完整副本，而另一些节点是加入矿池的轻量级节点，并且依赖于池服务器维护完整节点。挖矿功能在完整节点中显示为一个称为“Miner”或字母“M”的黑色圆圈。 用户钱包可能是完整节点的一部分，通常与桌面比特币客户端情况相同。越来越多的用户钱包，尤其是那些运行在资源受限设备（如智能手机）上的用户钱包是SPV节点。钱包功能在 A bitcoin network node with all four functions: wallet, miner, full blockchain database, and network routing 中显示为称为“Wallet”或字母“W”的绿色圆圈。 除了比特币P2P协议的主要节点类型外，还有运行其他协议的服务器和节点，例如专门的矿池协议和轻量级客户端访问协议。 Different types of nodes on the extended bitcoin network 展示了扩展比特币网络中的多数普通节点类型 扩展比特币网络 运行比特币P2P协议的主要比特币网络由5000到8000个运行各种版本比特币参考客户端（Bitcoin Core）的监听节点，和几百个运行比特币P2P协议的各种其他实现的节点组成，例如Bitcoin Classic ，Bitcoin Unlimited，BitcoinJ，Libbitcoin，btcd和bcoin。比特币P2P网络中的一小部分节点也是挖矿节点，在挖矿过程中竞争，验证交易并创建新区块。各种大公司通过运行基于比特币核心客户端的全节点客户端与比特币网络进行接口，具有完整的区块链副本和网络节点，但没有挖掘或钱包功能。这些节点充当网络边缘路由器，允许将各种其他服务（交易所，钱包，区块浏览器，商家支付处理）其上构建。 扩展比特币网络包括运行比特币P2P协议的网络，以及运行特殊协议的节点。连接到主比特币P2P网络的是许多矿池服务器和连接运行其他协议的节点的协议网关。这些其他协议节点主要是矿池节点（ 请参阅 [mining] ）和轻量级钱包客户端，它们不包含区块链的完整副本。 The extended bitcoin network showing various node types, gateways, and protocols 显示了扩展比特币网络，其中包括各种类型的节点，网关服务器，边缘路由器和钱包客户端以及它们用于彼此连接的各种协议。 Figure 2. Different types of nodes on the extended bitcoin network Figure 3. The extended bitcoin network showing various node types, gateways, and protocols 比特币中继网络 虽然比特币P2P网络服务于各种节点类型的普遍需求，但它为比特币挖矿节点的特殊需求呈现出过高的网络延迟。 比特币矿工们进行时间敏感的竞争，解决工作量证明问题来扩展区块链（参见[mining]）。参加这场比赛时，比特币矿工必须尽量缩短传播获胜区块和下一轮比赛开始之间的时间。在采矿中，网络延迟与利润空间直接相关。 比特币中继网络 Bitcoin Relay Network 是旨在尽量减少矿工之间区块传输延迟的网络。最初的 Bitcoin Relay Network 由核心开发者 Matt Corallo 在 2015 年创建，使矿工之间以极小的延迟快速同步区块。该网络由几个专门的节点组成，这些节点位于世界各地的亚马逊网络服务基础设施上，用于连接大多数矿工和矿池。 最初的比特币中继网络在2016年被 Fast Internet Bitcoin Relay Engine（http://bitcoinfibre.org [FIBRE]）替代，这也是由核心开发人员Matt Corallo创建的。FIBER是一个基于UDP的中继网络，用于中继节点网络中的块。FIBER实现了 紧凑的区块 compact block 优化以进一步减少传输的数据量和网络延迟。 另一个中继网络（仍处于提案阶段）是http://www.falcon-net.org/about[*Falcon*]，是基于康奈尔大学的研究的。 Falcon使用“直通式路由”（cut-through-routing）而不是“存储转发”(store-and-forward)来减少等待时间，方法是传输部分数据块，而不是等待接收完整数据块。 中继网络并不是比特币P2P网络的替代品。相反，它们是覆盖网络，为具有特殊需求的节点之间提供附加连接。像高速公路不是农村公路的替代品，而是交通繁忙的两个点之间的捷径，你仍然需要小路连接到高速公路。 网络发现 当新节点启动时，它必须发现网络上的其他比特币节点才能加入。要启动此过程，新节点必须发现网络上至少一个现有节点并连接到该节点。地理位置不重要，比特币网络拓扑结构没有地理上的定义。因此，任何现有的比特币节点都可以被随机选择。 要连接到一个已知的节点，节点建立一个TCP连接，通常连接到端口8333（比特币通常使用的端口），或者提供一个替代端口。在建立连接后，节点将通过发送包含基本标识信息的 版本( version )消息开始“握手”（请参见 The initial handshake between peers），其中包括： nVersion 客户端使用的比特币P2P协议版本（例如, 70002） nLocalServices 一个本节点支持的本地服务列表，现在只是 NODE_NETWORK nTime 当前时间 addrYou 远程节点的IP地址 addrMe 本地节点的IP地址 subver 体现在此节点上运行的软件类型的子版本 (例如, /Satoshi:0.9.2.1/) BestHeight 本节点的区块链的区块高度 (查看 GitHub 上的 version 网络消息示例。) version 消息通常是节点发送给另一个对等节点的第一条消息。接收到 version 消息的本地节点将检查远程节点报告的 nVersion 然后决定是否兼容远程节点。如果是兼容的，本地节点将认可 version 消息并通过 verack 消息建立链接。 新节点如何查找对等节点？第一种方法是使用许多“DNS种子”来查询DNS，这些DNS服务器提供比特币节点的IP地址列表。其中一些DNS种子提供稳定的比特币侦听节点的IP地址的静态列表。一些DNS种子是BIND (Berkeley Internet Name守护进程)的自定义实现，它从一个爬虫或一个长时间运行的比特币节点收集的比特币节点地址列表中返回一个随机子集。比特币核心客户端包含五个不同DNS种子的名称。不同DNS种子的所有权和实现的多样性为初始引导过程提供了高度的可靠性。在Bitcoin Core客户端中，使用DNS种子的选项由选项开关 -dnsseed （默认设置为1，以使用DNS种子）控制。 或者，一个对网络一无所知的启动节点必须被给予至少一个比特币节点的IP地址，之后它可以通过进一步的介绍建立连接。命令行参数 -seednode 可以用于连接到一个节点，只是为了将其作为种子使用。在使用初始种子节点进行介绍之后，客户端将与其断开并使用新发现的对等节点。 Figure 4. The initial handshake between peers 一旦建立了一个或多个连接，新节点将向其邻居发送一个包含自己IP地址的 addr 消息。邻居将依次将 addr 消息转发给它们的邻居，以确保新连接的节点变得众所周知并且更好地连接。另外，新连接的节点可以向邻居发送 getaddr，要求他们返回其他对等节点的IP地址列表。这样，一个节点能找到可以连接的对等节点，并在网络上通告其存在以供其他节点找到它。 Address propagation and discovery 展示了地址发现协议。 Figure 5. Address propagation and discovery 一个节点必须连接到几个不同的对等节点，以便建立到比特币网络的不同路径。路径不是可靠的 -节点随时可以加入或离开- 所以节点必须在丢失旧链接时持续发现新节点，并在启动时帮助（通知）其他节点。启动时只需要一个连接，因为第一个节点可以向他的对等节点介绍本节点，这些节点又可以提供进一步的介绍。连接到过多的节点也是不必要和浪费网络资源的。启动之后，节点将记住其最近成功的对等连接，如果重新启动，它可以快速重新建立与其以前的对等网络的连接。如果以前的对等节点都没有响应其连接请求，则该节点可以使用种子节点重新引导。 在运行Bitcoin Core客户端的节点上，你可以使用命令 getpeerinfo 列出对等连接： $ bitcoin-cli getpeerinfo [ { \"addr\" : \"85.213.199.39:8333\", \"services\" : \"00000001\", \"lastsend\" : 1405634126, \"lastrecv\" : 1405634127, \"bytessent\" : 23487651, \"bytesrecv\" : 138679099, \"conntime\" : 1405021768, \"pingtime\" : 0.00000000, \"version\" : 70002, \"subver\" : \"/Satoshi:0.9.2.1/\", \"inbound\" : false, \"startingheight\" : 310131, \"banscore\" : 0, \"syncnode\" : true }, { \"addr\" : \"58.23.244.20:8333\", \"services\" : \"00000001\", \"lastsend\" : 1405634127, \"lastrecv\" : 1405634124, \"bytessent\" : 4460918, \"bytesrecv\" : 8903575, \"conntime\" : 1405559628, \"pingtime\" : 0.00000000, \"version\" : 70001, \"subver\" : \"/Satoshi:0.8.6/\", \"inbound\" : false, \"startingheight\" : 311074, \"banscore\" : 0, \"syncnode\" : false } ] 要覆盖对等节点的自动管理并指定IP地址列表，用户可以提供选项 -connect = 指定一个或多个IP地址。如果使用此选项，节点将只连接到选定的IP地址，而不是自动发现和维护对等连接。 如果连接上没有流量，节点将定期发送消息来维护连接。如果一个节点在连接上超过90分钟没有进行通信，则认为它断开连接并寻找新的对等节点。因此，网络可以动态适应瞬态节点和网络问题，并且可以根据需要进行有机增长和收缩，而无需任何中央控制。 完整节点 完整的节点是维护所有交易完整区块链的节点。更准确地说，应该是“完整区块链节点”。在比特币早期，所有节点都是完整节点，目前Bitcoin Core客户端是完整区块链节点。然而，在过去的两年里，产生了不能维护完整区块链的新的比特币客户端，以轻量级客户端运行。我们将在下一节详细介绍这些内容。 完整区块链节点保存完整和最新的，包含所有交易的比特币区块链副本，它们独立构建和验证，从第一个区块（创世区块）开始，构建到网络中最新的已知区块。完整区块链节点可独立并权威地验证任何交易，无需依赖任何其他节点或信息来源。完整区块链节点依靠网络接收有关交易的新区块的更新，然后验证并将其合并到本地区块链副本中。 运行完整区块链节点为你提供纯粹的比特币体验：独立验证所有交易，无需依赖或信任任何其他系统。很容易判断你是否运行完整节点，因为它需要超过100 GB的磁盘空间来存储完整的区块链。如果你需要大量磁盘并且需要两到三天才能与网络同步，则你正在运行完整节点。这是完全独立和不依赖中央权威机构的代价。 完整区块链比特币客户端有几种可选的实现，它们使用不同的编程语言和软件体系结构构建。然而，最常见的实现方式是Bitcoin Core参考实现，也称为Satoshi客户端。比特币网络上超过75％的节点运行各种版本的比特币核心。它在 version 消息中发送的子版本字符串中被标识为“Satoshi”，如我们前面看到的那样，由命令 getpeerinfo 显示，例如，/Satoshi:0.8.6/。 交换“库存” 完整节点连接到对等节点之后的第一件事就是尝试构建一个完整的区块链。如果它是一个全新的节点，并且根本没有区块链，它只会知道一个区块，创世区块，这个区块是静态嵌入到客户端软件中的。从块＃0（创世区块）开始，新节点将下载数十万个区块来与网络同步并重新建立完整的区块链。 同步区块链的过程从 version 消息开始，因为它包含 BestHeight，节点当前的区块链高度（区块数）。一个节点会看到来自对等节点的 version 消息，知道它们各自拥有多少块，与它自己的区块链中的块数进行比较。对等节点将交换 getblocks 消息，其中包含本地区块链上顶部块的散列（指纹）。另一个对等节点会识别出接收到的散列不是顶部的块，而是较旧的块，由此推断其自身的本地区块链比其对等节点更长。 具有较长区块链的对等体比另一个节点具有更多的区块，并且可以识别出另一个节点需要“赶上”哪些区块。它将识别前500个块，使用 inv（库存）消息来共享和传输哈希。缺少这些块的节点将通过发出一系列 getdata 消息来请求完整块数据并使用 inv 消息中的散列标识请求的块。 例如，假设一个节点只有创世区块。然后它会收到来自对等节点的包含链中未来500个块的散列的 inv 消息。它将开始从所有连接的对等节点请求数据块，分散负载，确保它不会用请求淹没任何对等节点。该节点记录每个对等连接“正在传输”的区块数，即它已请求但未收到的块，并检查它未超过限制（ MAX_BLOCKS_IN_TRANSIT_PER_PEER ）。这样，如果需要很多块，它只会在先前的请求得到满足后才请求新块，从而使对等节点能够控制更新的速度并且不会压倒网络。每个块被接收后，将被添加到区块链中，我们将在 [blockchain] 中看到。随着本地区块链逐渐建立，更多的区块被请求和接收，并且该过程继续，直到节点赶上网络的其余部分。 节点只要离线任意时间，就会将本地区块链与对等节点进行比较，并获取任何缺失的区块。无论节点离线几分钟，缺少几个块，或离线一个月，缺少几千个块，它都会首先发送 getblocks，获取 inv 响应，并开始下载缺失的块。 Node synchronizing the blockchain by retrieving blocks from a peer 展示了库存和区块传播协议。 Figure 6. Node synchronizing the blockchain by retrieving blocks from a peer 简单支付验证（SPV） 并非所有节点都有能力存储完整的区块链。许多比特币客户端被设计用于在空间和功耗受限的设备上运行，如智能手机，平板电脑或嵌入式系统。对于此类设备，使用 simplified payment_verification（SPV）方法可以在不存储完整区块链的情况下进行操作。这些类型的客户端称为SPV客户端或轻量级客户端。随着比特币的普及，SPV节点正成为比特币节点的最常见形式，特别是比特币钱包。 SPV节点仅下载区块头，而不下载每个块中包含的交易。由此产生的区块链，比完整区块链小1000倍。 SPV节点无法构建可用于支出的所有UTXO的完整画面，因为他们不知道网络上的所有交易。 SPV节点使用一种不同的方法验证交易，这种方法依赖对等节点按需提供区块链相关部分的部分视图。 作为一个比喻，一个完整节点就像一个配备了每条街道和每个地址的详细地图的陌生城市游客。相比之下，一个SPV节点就像是一个只知道一条主干道，随机向陌生人打听路线的陌生城市游客。尽管两位游客都可以通过访问来验证街道的存在，但没有地图的游客并不知道任何一条小街道的位置，也不知道其他街道是否存在。位于教堂街23号的前面，没有地图的旅游者无法知道该市是否有其他“教堂街23号”地址，以及这是否是正确的。没有地图的游客最好的机会是问足够多的人，并期望他们中的一些人不会殴打他。 SPV通过交易在区块链中的 深度 而不是 高度 来验证。而一个完整的区块链节点将构建一个完全验证的链，有成千上万的区块和交易，一直链接到创世区块。一个SPV节点将验证所有区块链（但不是所有交易）并将该链链接到感兴趣的交易。 例如，当检查第300,000区块中的交易时，一个将所有300,000个区块连接起来，并建立了一个完整UTXO数据库的完整节点，通过确认UTXO的未花费状态来确定交易的有效性。SPV节点无法验证UTXO是否已花费。相反，SPV节点将使用 merkle path（参见 [merkle_trees] ）在交易和包含它的块之间建立链接。然后，SPV节点等待，直到它看到在包含该交易的块的顶部的六个块300,001至300,006，并通过在块300,006至300,001之下建立的深度来验证它。事实上，网络上的其他节点接受了300,000块，做了必要的工作，并在其上生成了六块以上的块，这代理地（间接地）证明交易不是双重花费的事实。 当交易实际上不存在时，不能说服SPV节点在区块中存在交易。 SPV节点通过请求merkle路径证明，并验证区块链中的工作量证明，来建立交易存在于区块中的证明。但是，交易的存在可以从SPV节点“隐藏”。 SPV节点可以明确证明交易存在，但无法验证交易（例如同一个UTXO的双重花费）不存在，因为它没有所有交易的记录。此漏洞可用于拒绝服务攻击或针对SPV节点的双重支出攻击。为了防止这种情况发生，SPV节点需要随机地连接到多个节点，以增加与至少一个诚实节点接触的概率。这种随机连接的需要意味着SPV节点也容易遭受网络分区攻击或Sybil攻击，即它们连接到了假节点或假网络，并且无法访问诚实节点或真正的比特币网络。 对于大多数实际的目的，连接良好的SPV节点足够安全，在资源需求、实用性和安全性之间取得平衡。然而，对于绝对可靠的安全性，没有什么比运行一个完整的区块链节点更好。 > 一个完整的区块链节点通过检查其下数千个区块来验证交易，以确保UTXO没有被消耗，而SPV节点则检查块在其上方的几个块中埋藏的深度。 要获取区块头，SPV节点使用 getheaders 消息而不是 getblocks。响应端会使用一个 header 消息发送至多2000个区块头。该过程与完整节点用于检索完整块的过程相同。 SPV节点还在与对等节点的连接上设置过滤器，以过滤由对等节点发送的未来的区块和交易。任何感兴趣的交易都使用 getdata 请求来检索。对等节点生成一个包含交易的 tx 消息，作为响应。 SPV node synchronizing the block headers 展示了区块头的同步。 由于SPV节点需要检索特定交易以选择性地验证它们，因此它们也会产生隐私风险。与收集每个区块内所有交易的完整区块链节点不同，SPV节点对特定数据的请求可能会无意中泄露其钱包中的地址。例如，监控网络的第三方可以跟踪SPV节点上的钱包所请求的所有交易，并使用它们将比特币地址与该钱包的用户相关联，从而破坏用户的隐私。 Figure 7. SPV node synchronizing the block headers 在引入SPV/轻量级节点后不久，比特币开发人员添加了一项名为 布隆过滤器 布隆_filters 的功能，以解决SPV节点的隐私风险。布隆过滤器允许SPV节点通过使用概率而不是固定模式的过滤机制来接收交易子集，从而无需精确地揭示他们感兴趣的地址。 布隆过滤器 布隆 Filters 布隆过滤器是一种概率搜索过滤器，它是一种不必精确地描述所需模式的方法。布隆过滤器提供了一种有效的方式来表达搜索模式，同时保护隐私。它们被SPV节点用来向他们的对等节点询问符合特定模式的交易，而不会准确揭示他们正在搜索的地址，密钥或交易。 在我们以前的比喻中，一个没有地图的游客正在询问指向特定地址的路线，“23 Church St.”如果她向陌生人询问这条街的路线，她会无意中透露她的目的地。布隆过滤器就像是问：“这个街区有什么街道名称以R-C-H结尾？”像这样的问题揭露的目的地信息要少一些。使用这种技术，游客可以更详细地指定希望的地址，例如“以U-R-C-H结尾”或更少的细节，如“以H结尾”。通过改变搜索的精确度，游客可以显示或多或少的信息，代价是获得或多或少的具体结果。如果她提出一个不太具体的模式，她会得到更多可能的地址和更好的隐私，但是许多结果都是无关紧要的。如果她要求一个非常具体的模式，她会得到较少的结果，但会失去隐私。 布隆过滤器通过允许SPV节点指定精度或隐私程度可调整的交易搜索模式来支持此功能。更具体的布隆过滤器将产生准确的结果，但是以暴露SPV节点感兴趣的模式为代价，从而揭示用户钱包拥有的地址。一个不太具体的布隆过滤器将产生更多关于更多交易的数据，许多数据与节点无关，但将使节点保持更好的隐私。 布隆过滤器如何工作 布隆过滤器被实现为具有N个二进制数字（比特位）的可变大小数组，和可变数量的M个哈希函数的。哈希函数被设计为始终产生1到N之间的输出，对应于二进制数字的数组。哈希函数是确定性地生成的，以便任何实现布隆过滤器的节点将总是使用相同的哈希函数，并且针对特定输入获得相同的结果。通过选择不同长度（N）布隆过滤器和不同数量（M）的散列函数，可以调整布隆过滤器，从而改变准确性水平和隐私。 在 An example of a simplistic 布隆 filter, with a 16-bit field and three hash functions 中, 我们使用非常小的16位数组和三个散列函数来演示布隆过滤器如何工作。 Figure 8. An example of a simplistic 布隆 filter, with a 16-bit field and three hash functions 布隆过滤器将位数组全部初始化为零。要将模式添加到布隆过滤器，依次由每个哈希函数散列。将第一个散列函数应用于输入会产生一个介于1和N之间的数字。找到数组中的相应位（从1到N编号）并设置为 1 ，从而记录散列函数的输出。然后，下一个哈希函数被用来设置另一个位等等。应用了所有M个散列函数之后，搜索模式将在布隆过滤器中被“记录”为从 0 变为 1 的M个位。 Adding a pattern \"A\" to our simple 布隆 filter 是向 An example of a simplistic 布隆 filter, with a 16-bit field and three hash functions 中所示的简单布隆过滤器添加模式“A”的示例。 添加第二个模式与重复此过程一样简单。该模式依次由每个散列函数进行散列，并通过对应的位设置为 1 来记录结果。请注意，由于布隆过滤器填充了更多模式，因此散列函数结果可能与已设置为 1 的位重合，在这种情况下该位不会更改。本质上，随着更多模式记录重叠位，布隆过滤器开始变得饱和，更多位设置为 1 ，滤波器的准确性降低。这就是为什么过滤器是一个概率数据结构 —— 随着更多模式的添加，它变得不太准确。精确度取决于所添加的模式的数量与位阵列（N）的大小和散列函数（M）的数量。更大的位阵列和更多的散列函数可以以更高的准确度记录更多的模式。较小的位阵列或更少的散列函数将记录较少的模式并产生较低的准确性。 Figure 9. Adding a pattern \"A\" to our simple 布隆 filter Adding a second pattern \"B\" to our simple 布隆 filter 是向简单布隆过滤器添加第二个模式“B”的示例。 Figure 10. Adding a second pattern \"B\" to our simple 布隆 filter 为了测试一个模式是否是布隆过滤器的一部分，使用每个哈希函数对模式进行哈希处理，并根据比特数组测试最终的位模式。如果由散列函数索引的所有位被设置为 1，则该模式 可能 在布隆过滤器中记录。因为这些比特可能因为多重模式的重叠而被设置，所以答案不确定，而是相当可能的。简而言之，布隆 Filter正面匹配是“可能是”。 Testing the existence of pattern \"X\" in the 布隆 filter. The result is a probabilistic positive match, meaning \"Maybe.\" 是在简单布隆过滤器中测试模式“X”的存在的示例。相应的位被设置为 1 ，所以模式可能是匹配的。 Figure 11. Testing the existence of pattern \"X\" in the 布隆 filter. The result is a probabilistic positive match, meaning \"Maybe.\" 相反，如果模式针对布隆过滤器进行测试，并且任意一个比特设置为 0 ，则这证明该模式没有记录在布隆过滤器中。否定的结果不是概率，而是肯定的。简而言之，布隆过滤器上的负面匹配是“绝对不是！” Testing the existence of pattern \"Y\" in the 布隆 filter. The result is a definitive negative match, meaning \"Definitely Not!\" 是在简单布隆过滤器中测试模式“Y”的存在的一个例子。其中一个相应的位设置为 0，因此该模式绝对不匹配。 Figure 12. Testing the existence of pattern \"Y\" in the 布隆 filter. The result is a definitive negative match, meaning \"Definitely Not!\" SPV节点如何使用布隆过滤器 布隆过滤器用于过滤SPV节点从其对等节点接收的交易（以及包含它们的块），仅选择SPV节点感兴趣的交易而不透露其感兴趣的地址或密钥。 SPV节点会将布隆过滤器初始化为“空”；在该状态下，布隆过滤器将不匹配任何模式。然后，SPV节点将列出它感兴趣的所有地址，密钥和散列。它将通过从其钱包控制的任何UTXO中提取公共密钥散列和脚本散列和交易ID来完成此操作。 然后，SPV节点将这些模式中的每一个添加到布隆过滤器，如果这些模式存在于交易中，布隆过滤器将“匹配”，而不显示模式本身。 SPV节点将向对等节点发送 filterload 消息，其中包含要在连接上使用的布隆过滤器。在对等节点中，布隆过滤器将针对每个传入交易进行检查。完整节点根据布隆过滤器检查交易的多个部分，查找包含以下内容的匹配项： 交易ID 交易的每个输出（脚本中的每个密钥和散列）的锁定脚本数据部分 每个交易输入 每个输入签名数据部分（或见证脚本） 通过检查所有这些组件，布隆过滤器可用于匹配公钥哈希，脚本，OP_RETURN 值，签名中的公钥或智能合约或复杂脚本的任何未来组件。 在建立过滤器后，对等节点将用布隆过滤器测试每个交易的输出。只有匹配过滤器的交易才会发送到节点。 为响应来自节点的 getdata 消息，对等节点将发送 merkleblock 消息，其中每个匹配交易仅包含与过滤器和merkle路径匹配的区块的头部（请参见 [merkle_trees] ）。对等节点随后还会发送包含由过滤器匹配的交易的 tx 消息。 当完整节点向SPV节点发送交易时，SPV节点丢弃所有误报，并使用正确匹配的交易更新其UTXO集和钱包余额。当它更新自己的UTXO集合时，它也修改布隆过滤器以匹配任何引用它刚刚找到的UTXO的未来交易。完整的节点然后使用新的布隆过滤器来匹配新的交易并重复整个过程。 通过发送 filteradd 消息，设置布隆过滤器的节点可以交互式地向过滤器添加模式。要清空布隆过滤器，节点可以发送 filterclear 消息。由于无法从布隆过滤器中删除模式，因此如果不再需要模式，节点必须清空并重新发送新的布隆过滤器。 SPV节点的网络协议和布隆过滤器机制在 BIP-37 (Peer Services) 中定义。 SPV节点和隐私 实现SPV的节点比完整节点的隐私性更弱。一个完整节点接收所有交易，因此不会显示它是否在钱包中使用某个地址。 SPV节点接收与其钱包中的地址相关的过滤列表。因此，它降低了所有者的隐私。 布隆过滤器是一种减少隐私损失的方法。没有它们，SPV节点将不得不明确列出它感兴趣的地址，从而严重暴露隐私。然而，即使使用布隆过滤器，监控SPV客户端的流量或直接作为P2P网络中的节点连接到它的对等节点，也可以收集足够的信息来学习SPV客户端的钱包中的地址。 加密和认证的连接 大多数比特币的新用户都假定比特币节点的网络通信是加密的。事实上，比特币的原始实施完全是不加密的。虽然这不是完整节点的主要隐私问题，但对于SPV节点来说是一个大问题。 作为增加比特币P2P网络隐私和安全性的一种方法，有两种解决方案可以提供通信加密：Tor Transport（BIP-150） 和 P2P认证与加密 （BIP-151）。 Tor传输 Tor 代表 洋葱路由网络 The Onion Routing network，是一个软件项目，也是一种网络，通过具有匿名性，不可追踪性和隐私性的随机网络路径，来提供数据加密和封装。 比特币核心提供了几个配置选项，允许你运行比特币节点，通过Tor网络传输流量。此外，Bitcoin Core还可以提供Tor隐藏服务，允许其他Tor节点直接通过Tor连接到你的节点。 从Bitcoin Core 0.12开始，如果节点能够连接到本地的Tor服务，它将自动提供Tor隐藏服务。如果你安装了Tor并且Bitcoin Core进程作为具有访问Tor认证cookie权限的用户运行，则它应该自动运行。使用 debug 标志打开比特币核心的Tor服务调试，如下所示： $ bitcoind --daemon --debug=tor 你应该在日志中看到 \"tor: ADD_ONION successful\"，表明Bitcoin Core已经为Tor网络添加了隐藏服务。 你可以在Bitcoin Core文档（ docs/tor.md ）和各种在线教程中找到关于将Bitcoin Core作为Tor隐藏服务运行的更多说明。 点对点认证和加密 Peer-to-Peer Authentication and Encryption 两项比特币改进建议，BIP-150和BIP-151，增加了对比特币P2P网络中P2P认证和加密的支持。这两个BIP定义了可能由兼容的比特币节点提供的可选服务。 BIP-151为两个支持BIP-151的节点之间的所有通信启用协商加密。BIP-150提供可选的对等身份验证，允许节点使用ECDSA和私钥对彼此的身份进行身份验证。 BIP-150要求在验证之前，两个节点按照BIP-151建立了加密通信。 截至2017年1月，BIP-150和BIP-151未在Bitcoin Core中实施。这两个提案已经至少由一个名为bcoin的替代比特币客户端实施。 BIP-150和BIP-151允许用户使用加密和身份验证来运行连接到可信完整节点的SPV客户端，以保护SPV客户端的隐私。 此外，身份验证可用于创建可信的比特币节点网络并防止中间人攻击（Man-in-the-Middle attacks）。最后，如果广泛部署P2P加密，将会加强比特币对流量分析和隐私侵蚀监控的阻力，特别是在互联网使用受到严格控制和监控的极权主义国家。 标准定义在 BIP-150 (Peer Authentication) 和 BIP-151 (Peer-to-Peer Communication Encryption) 中。 交易池 几乎比特币网络上的每个节点都维护一个名为 memory pool，mempool_或_transaction pool 的未确认交易的临时列表。节点使用该池来跟踪网络已知但尚未包含在区块链中的交易。例如，钱包节点将使用交易池来追踪已经在网络上接收但尚未确认的到用户钱包的传入支付。 交易被接收和验证后，会被添加到交易池并被中继到相邻节点以在网络上传播。 一些节点实现还维护一个单独的孤儿交易池。如果交易的投入引用尚未知晓的交易，好像遗失了父母，那么孤儿交易将临时存储在孤儿池中，直至父交易到达。 将交易添加到交易池时，将检查孤儿交易池是否有任何引用此交易输出的孤儿（后续交易）。然后验证任何匹配的孤儿。如果有效，它们将从孤儿交易池中删除并添加到交易池中，从而完成从父交易开始的链。鉴于不再是孤儿的新增交易，该过程重复递归地寻找更多后代，直到找不到更多的后代。通过这个过程，父交易的到来触发了整个链条相互依赖的交易的级联重建，将孤儿与他们的父母重新整合在一起。 交易池和孤儿交易池都存储在本地内存中，不会保存在持久性存储上；而且，它们是从传入的网络消息动态填充的。当一个节点启动时，这两个池都是空的，并且会逐渐使用网络上收到的新交易填充。 比特币客户端的一些实现还维护UTXO数据库或池，这是区块链上所有未使用输出的集合。尽管名称“UTXO池”听起来与交易池相似，但它代表了一组不同的数据。与交易和孤儿交易池不同，UTXO池并未初始化为空，而是包含了追溯到创世区块的，数百万未使用的交易输出条目。UTXO池可以放置在本地内存中，也可以作为持久存储上的索引数据库表。 交易池和孤儿交易池代表单个节点的本地视角，根据节点启动或重新启动的时间不同，节点之间可能会有很大差异；UTXO池表示网络的自发共识，因此节点之间的差异很小。此外，交易池和孤儿交易池只包含未确认的交易，而UTXO池只包含确认的输出。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 15:21:58 "},"11第九章.html":{"url":"11第九章.html","title":"区块链","keywords":"","body":"区块链 简介 区块链的数据结构是有序的，向前链接的区块和交易的列表。区块链可以存储为一个扁平的文件，或者简单的数据库。Bitcoin Core客户端使用Google的LevelDB数据库存储区块链的元数据。区块向前链接，每个区块都指向它的前一个区块。区块链经常被可视化为垂直的栈，第一个区块作为栈底，其他的依次向上堆叠。彼此堆叠的区块栈形式引出了 \"height\" 的术语，来代表区块与第一个区块的距离，\"top\" 和 \"tip\" 指代最新添加的区块。 区块链中的每个区块都由一个哈希值标识，在该区块头上使用SHA256加密散列算法生成。每个块还通过块头中的 \"previous block hash\"（上一个块的哈希值）字段引用先前的块，称为 parent 块。换句话说，每个块在其自己的头部中包含其父块的哈希值。哈希值序列创建了一个链，将每个块连接到其父项，一直链接到有第一个区块，称为 创世区块 genesis block。 尽管一个块只有一个父块，但它可以暂时拥有多个子块。每个子块都指向相同的块作为它们的父块，并在 \"previous block hash\" 字段中包含相同的（父块的）散列。在区块链“分叉”期间会出现多个子块，这是一种临时情况，当不同的矿区几乎同时由不同的矿工发现时（参见 [forks]）。最终，只有一个子块成为区块链的一部分，“fork”就解决了。一个块可能有多个子块，但每个块只有一个父块。这是因为一个块只有一个引用其单亲的 \"previous block hash\" 字段。 \"previous block hash\" 字段在区块的头部，并且影响当前区块的哈希值。如果父块的标识改变，子块的标识也会改变。当父块以某种方式改变，父块的哈希值就会改变。父块变化了的哈希值要求子块的 \"previous block hash\" 也必须改变，这又会引起孙子块的改变，以此类推。这种级联效应可以确保一旦一个块在其之后有许多后代，它就不能在不强制重新计算所有后续区块的情况下进行更改。由于重新计算需要大量的计算（耗费大量的能源），长链块的存在使得区块链的历史不可更改，这是比特币安全性的一个关键特征。 看待区块链的一种方式就像地质构造中的层或冰川岩芯样本。表层可能随着季节变化，甚至在沉淀之前被吹走。但是一旦深入几英寸，地质层就变得越来越稳定。当你向下看几百英尺时，你会看到几百万年来一直没有受到干扰的过去的快照。在区块链中，如果由于分叉导致链重新计算，可能会修改最近的几个区块。前六个区块就像是几英寸的表土。一旦你深入区块链超过六个区块，区块变化的可能性就越来越小。在100个区块之前，稳定性非常高，以至于可以花费coinbase交易 - 包含新开采的比特币的交易。几千个区块（一个月），对于所有实际目的来说，区块链都已成确定的历史。虽然协议总是允许一条链被一条较长的链消除，任何块被反转的可能性总是存在的，但是这种事件的可能性会随着时间流逝而减少，直到它变得无限小。 区块的结构 区块是一个容器数据结构，用于汇总包含在公共账本（区块链）中的交易。区块有一个包含元数据的头部，后面跟着一个长长的交易列表。区块头为80字节，平均交易至少为400字节，平均每块包含超过1900个交易。一个包含所有交易的完整块因此比块头大10,000倍。 The structure of a block 描述了一个块的结构。 Table 1. The structure of a block Size Field Description 4 bytes Block Size The size of the block, in bytes, following this field 80 bytes Block Header Several fields form the block header 1——9 bytes (VarInt) Transaction Counter How many transactions follow Variable Transactions The transactions recorded in this block 区块头 区块头由三组区块元数据组成。首先，有一个对前块哈希值的引用，它将这个区块连接到区块链中的前一个块。第二组元数据，分别为 难度 difficulty，时间戳 timestamp 和 随机数 nonce，与挖矿竞赛有关，参见 [mining]。第三个元数据是merkle树根，这是一种数据结构，用于有效地汇总块中的所有交易。The structure of the block header 描述了块头的结构。 Table 2. The structure of the block header Size Field Description 4 bytes Version A version number to track software/protocol upgrades 32 bytes Previous Block Hash A reference to the hash of the previous (parent) block in the chain 32 bytes Merkle Root A hash of the root of the merkle tree of this block’s transactions 4 bytes Timestamp The approximate creation time of this block (seconds from Unix Epoch) 4 bytes Difficulty Target The Proof-of-Work algorithm difficulty target for this block 4 bytes Nonce A counter used for the Proof-of-Work algorithm 随机数，难度目标，和时间戳用于挖矿过程，在 [mining] 中有详细介绍。 区块标识符：区块头的哈希值和区块高度 区块的主要标识符是它的加密哈希值，这是一种数字指纹，通过SHA256算法将块头两次散列获得。得到的32字节哈希被称为 block hash ，更准确地说是 block header hash，因为只有区块头用于计算。例如 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 是第一个区块的哈希值， 区块的哈希值唯一而明确地标识一个块，任何节点都可以通过简单地对块头进行散列来独立地派生它。 注意，区块的哈希值实际上并不包含在区块的数据结构中，无论是在网络上传输块时，还是作为区块链的一部分存储在节点的持久性存储时。相反，当从网络接收区块时，每个节点计算区块的哈希值。区块哈希值可以作为区块元数据的一部分存储在单独的数据库表中，以方便索引并从磁盘快速检索。 另一种识别区块的方法是它在区块链中的位置，称为 区块高度 block height。第一个块位于块高度0处，与被哈希值 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 引用的块相同。块可以通过两种方式标识：通过引用块的哈希值或通过引用块高度。在第一个区块的“顶部”添加的每个后续区块在区块链中都在一个“更高”的位置，就像一个盒子叠在另一个上面一样。2017年1月1日的区块链高度约为44.6万，这意味着在2009年1月创建的第一个区块的顶部有446000个区块。 与区块哈希值不同，区块高度不是唯一标识符。尽管单个块总是具有特定且不变的块高度，但反过来并不正确 —— 区块高度并不总是标识一个块。两个或更多块可能具有相同的块高度，争夺区块链中的相同位置。这种情况将在 [forks] 一节中详细讨论。块高度也不是区块的数据结构的一部分；它不存储在区块中。当从比特币网络收到区块时，每个节点都会动态识别区块在区块链中的位置（高度）。块高度也可以作为元数据存储在索引数据库表中以加快检索速度。 > 区块的block hash总是唯一标识一个块。区块也总是有一个特定的block height。但是，特定的区块高度并不总是能够标识单个块。相反，两块或更多块可能会在区块链中争夺一个位置。 创世区块 区块链中的第一个区块被称为创世区块，于2009年创建。它是区块链中所有区块的共同祖先，这意味着如果你从任何区块开始，并随时间上向前追溯，最终将到达创世区块。 节点总是以至少一个区块的区块链开始，因为这个区块是在比特币客户端软件中静态编码的，因此它不能被改变。每个节点总是“知道”起始块的哈希和结构，它创建的固定时间，以及其中的单一交易。因此，每个节点都有区块链的起点，这是一个安全的“根”，从中可以构建受信任的区块链。 请参阅 chainparams.cpp 中 Bitcoin Core 客户端内的静态编码的genesis块。 以下哈希值标识符属于创世区块： 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 你可以在任何区块浏览器网站（例如 blockchain.info ）中搜索该区块哈希值，你将找到一个描述此块内容的页面，包含该哈希的URL： https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 在命令行中使用 Bitcoin Core 客户端： $ bitcoin-cli getblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f { \"hash\" : \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\", \"confirmations\" : 308321, \"size\" : 285, \"height\" : 0, \"version\" : 1, \"merkleroot\" : \"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\", \"tx\" : [ \"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\" ], \"time\" : 1231006505, \"nonce\" : 2083236893, \"bits\" : \"1d00ffff\", \"difficulty\" : 1.00000000, \"nextblockhash\" : \"00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048\" } 创世区块包含一个隐藏的消息。币基交易的输入包含的文字是 \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.\"。此消息旨在通过参考英国报纸 The_Times 的标题提供此区块创建的最早日期的证据。它还半开玩笑地提醒人们关注独立货币体系的重要性，比特币发行时正值前所未有的全球货币危机。比特币的创造者Satoshi Nakamoto将这个信息嵌入了第一块。 在区块链中链接区块 比特币完整节点保留了区块链从创世区块开始的本地副本。区块链的本地副本会随着新块被发现并用于扩展链而不断更新。当一个节点通过网络接收到区块时，它验证这些块，然后将它们链接到现有的区块链。为了建立链接，节点将检查传入的区块头并查找“previous block hash”。 例如，假设一个节点在区块链的本地副本中有277,314个区块。节点知道的最后一个块是块277,314，区块头的哈希值为： 00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249 然后，该节点从网络接收一个新的块，解析如下： { \"size\" : 43560, \"version\" : 2, \"previousblockhash\" : \"00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249\", \"merkleroot\" : \"5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d\", \"time\" : 1388185038, \"difficulty\" : 1180923195.25802612, \"nonce\" : 4215469401, \"tx\" : [ \"257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77\", #[... many more transactions omitted ...] \"05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634\" ] } 查看这个新块，找到 previousblockhash 字段，其中包含其父块的哈希值。它是节点所知道的哈希值，是位于链的277,314高度的最后一个块。因此，这个新块是链上最后一个块的孩子，并扩展了现有的区块链。该节点将此新块添加到链的末端，使区块链更长，新的高度为277,315。Blocks linked in a chain by reference to the previous block header hash 显示三个块的链，通过 previousblockhash 字段中的引用链接。 默克尔树 Merkle Trees 比特币区块链中的每个区块都包含一个 merkle tree ，作为所有交易的汇总。 默克尔树 merkle tree, 也叫做 二叉哈希树 binary hash tree, 是一种用于有效汇总和验证大型数据集的完整性的数据结构。 Merkle树是包含加密哈希的二叉树。术语“树”在计算机科学中被用来描述分支的数据结构，但是这些树通常是颠倒显示的，“根”在顶部，“叶子”在底部，你将在下面的例子中看到。 Figure 1. Blocks linked in a chain by reference to the previous block header hash 比特币中使用Merkle树来汇总区块中的所有交易，为整个交易集提供全面的数字指纹，提供了一个非常有效的流程来验证交易是否包含在区块中。 Merkle树是通过对节点对儿（pairs of nodes）进行递归散列构造的，直到只有一个散列，称为 root 或 merkle root。比特币的merkle树中使用的加密哈希算法是将SHA256应用两次，也称为double-SHA256。 当N个数据元素被散列并汇总到一个Merkle树中时，你可以检查树中是否包含任何一个数据元素，并且最多只需 2*log2~(N) 次计算，因此这是一个非常有效的数据结构。 Merkle树是自下而上构建的。在下面的例子中，我们从四个交易开始，A，B，C和D，它们构成了merkle树的 叶子 leaves，如 Calculating the nodes in a merkle tree 所示。交易不存储在merkle树中；相反，它们的数据被散列并且所得到的哈希值被存储在每个叶节点中，如 HA，HB，HC 和 HD： HA = SHA256(SHA256(Transaction A)) 然后将连续的叶节点对汇总到父节点中，方法是连接两个哈希值并对它们进行散列。例如，要构造父节点 HAB，将子节点的两个32字节哈希值连接起来，以创建一个64字节的字符串。然后对该字符串进行双重散列来产生父节点的哈希值： HAB = SHA256(SHA256(HA + HB)) 继续该过程，直到顶部只有一个节点，该节点被称为merkle根。该32字节哈希值存储在区块头中，汇总了四个交易中的所有数据。Calculating the nodes in a merkle tree 展示了如何通过节点的成对散列来计算根。 Figure 2. Calculating the nodes in a merkle tree 由于merkle树是二叉树，它需要偶数个叶节点。如果要汇总的交易数量为奇数，则最后一个交易的哈希值将被复制以创建偶数个叶节点，这称为 平衡的树 balanced tree。在 > 中，交易C被复制。 Figure 3. Duplicating one data element achieves an even number of data elements 使用四个交易构造树的方法可以推广到构造任意大小的树。在比特币中，通常在一个块中有几百到几千个交易，这些交易的汇总方式完全相同，仅产生单个Merkle根的32个字节的数据。在 A merkle tree summarizing many data elements 中，你将看到一棵由16个交易构成的树。请注意，尽管根看起来比图中的叶节点大，但它的大小完全相同，只有32个字节。无论块中是否有一个交易或十万个交易，merkle根总是将它们总结为32个字节。 为了证明一个块中包含一个特定的交易，一个节点只需要产生 log2~(N) 个32个字节的哈希值，构成一个认证 path 或 merkle_path，将特定的交易连接到树的根。随着交易数量的增加，这一点尤为重要，因为交易数量的基数为2的对数增长速度要慢得多。这使得比特币节点能够高效地生成10或12个哈希值（320-384字节）的路径，这可以提供兆字节大小的块中超过一千个交易中的单个交易的验证。 Figure 4. A merkle tree summarizing many data elements 在 A merkle path used to prove inclusion of a data element 中，节点可以通过产生只有四个32字节哈希长（总共128字节）的merkle路径来证明交易K包含在该块中。该路径由四个哈希值组成（ 在 > 带蓝色背景的 ），HL，HIJ，HMNOP 和 HABCDEFGH。通过提供这四个哈希值作为验证路径，任何节点都可以通过计算四个额外的哈希值来证明 HK（底部黑色背景的）包含在Merkle根中：HKL，HIJKL，HIJKLMNOP 和merkle树根（在图中用虚线表示）。 Figure 5. A merkle path used to prove inclusion of a data element Building a merkle tree 中的代码演示了如何使用libbitcoin的一些辅助函数，创建从叶节点哈希值一直到根的Merkle树。 Example 1. Building a merkle tree link:code/merkle.cpp[] Compiling and running the merkle example code 展示了编译和运行结果 Example 2. Compiling and running the merkle example code $ # Compile the merkle.cpp code $ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the merkle executable $ ./merkle Current merkle hash list: 32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d27006 30861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4 Current merkle hash list: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3 Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3 随着规模的增加，梅克尔树的效率变得越来越明显。 Merkle tree efficiency 展示了证明交易是区块的一部分锁需要的作为merkle路径交换的数据量。 Table 3. Merkle tree efficiency Number of transactions Approx. size of block Path size (hashes) Path size (bytes) 16 transactions 4 kilobytes 4 hashes 128 bytes 512 transactions 128 kilobytes 9 hashes 288 bytes 2048 transactions 512 kilobytes 11 hashes 352 bytes 65,535 transactions 16 megabytes 16 hashes 512 bytes 从表中可以看出，区块大小从16个交易的4KB快速增加到65,535个交易的16MB，证明交易存在所需的Merkle路径则增加得很慢，从128字节到只有512字节。使用merkle树，节点可以只下载区块头（每块80个字节），并且仍然能够通过从完整节点检索小型merkle路径来证实交易包含在区块中，而不存储或传输绝大量的（可能几个GB）区块链数据。不维护完整区块链的节点称为简单支付验证（SPV）节点，它使用merkle路径验证交易而无需下载完整区块。 Merkle 树和简单支付验证节点 Merkle树被SPV节点广泛使用。 SPV节点没有全部交易，并且不下载完整的块，只有区块头。为了验证块中包含交易，而不必下载块中的所有交易，它们使用验证路径（merkle路径）。 例如，考虑一个SPV节点，它对付款到它的钱包中地址的交易感兴趣。SPV节点将在其与对等节点的连接上建立一个布隆过滤器（参见 [bloom_filters] ），将接收到的交易限制为那些只包含其感兴趣地址的交易。当对等节点看到与bloom过滤器匹配的交易时，它将使用 merkleblock 消息发送该块。merkleblock 消息包含区块的头，以及将感兴趣的交易链接到区块中的merkle根的merkle路径。SPV节点可以使用此Merkle路径将交易连接到区块并验证交易是否包含在块中。 SPV节点还使用区块头将区块链接到区块链的其余部分。交易和区块之间以及区块和区块链之间的这两个链接的组合证明交易记录在区块链中。总而言之，SPV节点将接收到少于一千字节的数据块头和merkle路径，其数据量比完整块（当前大约1兆字节）少一千倍以上。 比特币的测试区块链 你可能会惊讶地发现有多个比特币区块链。 2009年1月3日由中本聪创建的“主”比特币区块链，带有我们本章研究的创世区块，被称为 主网 mainnet。还有其他用于测试的比特币区块链，现在有：testnet，segnet 和 regtest。让我们依次看下。 测试网络 —— 比特币的测试场 Testnet是用于测试目的的测试区块链，网络和货币的名称。测试网是一个全功能的活跃P2P网络，包括钱包，测试比特币（testnet硬币），挖矿以及 mainnet 的所有其他功能。实际上只有两个区别：测试网点的硬币价值很低，挖矿难度应该足够低，以便任何人都可以相对容易地开采测试网硬币。 任何拟用于比特币主网生产的软件开发应首先使用测试币在测试网上进行测试。这可以保护开发人员免受由于错误导致的资金损失，并保护网络免受由于错误导致的意外行为。 然而，保持硬币毫无价值并且容易挖掘，并不容易。尽管开发者提出了要求，但有些人使用高级采矿设备（GPU和ASIC）在测试网上进行挖掘，增加了难度，使得不可能用CPU进行挖掘，最终使其难以获得，人们开始评估它们的价值，因此它们也不是毫无价值的。因此，现在或者之后，测试网必须被废弃并从新的创世区块重新启动，重新设置难度。 当前的测试网成为 testnet3，第三代 testnet，2011年2月重启，重置了前一代测试网的难度。 请记住，testnet3是一个大型的区块链，2017年初超过了20GB。耗尽计算机资源完全同步需要一天左右的时间。不如mainnet大，但也不是“轻量级”的。运行测试网络节点的一个好的方法是作为专用于此目的的虚拟机映像（例如，VirtualBox，Docker，云服务器等）。 使用测试网 像几乎所有其他比特币软件一样，Bitcoin Core完全支持在testnet而不是mainnet上运行。比特币核心的所有功能都在测试网络上运行，包括钱包，开采测试网的币，以及同步完整的测试网节点。 要在测试网上启动 Bitcoin Core，使用 testnet 选项： $ bitcoind -testnet 在日志中，你应该看到bitcoind正在默认bitcoind目录的 testnet3 子目录中构建新的区块链： bitcoind: Using data directory /home/username/.bitcoin/testnet3 你可以使用 bitcoin-cli 命令行工具连接到bitcoind，但也必须将其切换到testnet模式： $ bitcoin-cli -testnet getblockchaininfo { \"chain\": \"test\", \"blocks\": 1088, \"headers\": 139999, \"bestblockhash\": \"0000000063d29909d475a1c4ba26da64b368e56cce5d925097bf3a2084370128\", \"difficulty\": 1, \"mediantime\": 1337966158, \"verificationprogress\": 0.001644065914099759, \"chainwork\": \"0000000000000000000000000000000000000000000000000000044104410441\", \"pruned\": false, \"softforks\": [ [...] 你还可以使用其他完整节点实现（如 btcd（用Go编写）和 bcoin（用JavaScript编写））在testnet3上运行，以便在其他编程语言和框架中进行实验和学习。 2017年初，testnet3支持了mainnet的所有功能，包括隔离见证（参见 [segwit]）。因此，testnet3也可以用来测试隔离见证功能。 Segnet —— 隔离见证测试网 2016年启动了一个特殊用途的测试网，帮助开发和测试隔离见证（又名segwit；见 [segwit]）。该测试区块链被称为 segnet，可以通过运行比特币核心的特殊版本（分支）加入。 由于segwit已添加到testnet3，因此不再需要使用segnet来测试segwit功能。 未来，我们可能会看到其他像segnet一样，专门设计用于测试单个功能或主要架构更改的testnet区块链。 Regtest —— 本地区块链 Regtest代表“回归测试”，它是一种比特币核心功能，允许你为测试目的创建本地区块链。与公共测试区块链testnet3不同，regtest区块链旨在作为封闭系统运行以进行本地测试。你从零开始启动一个regtest区块链，创建一个本地创世区块。你可以将其他节点添加到网络，或者仅使用单个节点运行它来测试比特币核心软件。 要以 regtest 模式启动 Bitcoin Core，使用 regtest 选项： $ bitcoind -regtest 与testnet一样，Bitcoin Core会在你的bitcoind默认目录的 regtest 子目录下初始化一个新的区块链： bitcoind: Using data directory /home/username/.bitcoin/regtest 要使用命令行工具，你需要指定 regtest 标志： $ bitcoin-cli -regtest getblockchaininfo { \"chain\": \"regtest\", \"blocks\": 0, \"headers\": 0, \"bestblockhash\": \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\", \"difficulty\": 4.656542373906925e-10, \"mediantime\": 1296688602, \"verificationprogress\": 1, \"chainwork\": \"0000000000000000000000000000000000000000000000000000000000000002\", \"pruned\": false, [...] 如你所见，现在还没有区块。让我们挖掘一些（500块）并获得奖励： $ bitcoin-cli -regtest generate 500 [ \"7afed70259f22c2bf11e406cb12ed5c0657b6e16a6477a9f8b28e2046b5ba1ca\", \"1aca2f154a80a9863a9aac4c72047a6d3f385c4eec5441a4aafa6acaa1dada14\", \"4334ecf6fb022f30fbd764c3ee778fabbd53b4a4d1950eae8a91f1f5158ed2d1\", \"5f951d34065efeaf64e54e91d00b260294fcdfc7f05dbb5599aec84b957a7766\", \"43744b5e77c1dfece9d05ab5f0e6796ebe627303163547e69e27f55d0f2b9353\", [...] \"6c31585a48d4fc2b3fd25521f4515b18aefb59d0def82bd9c2185c4ecb754327\" ] 只需要几秒钟的时间来挖掘所有这些块，这使得测试很容易。如果你检查你的钱包余额，你会看到你获得了前400个区块的奖励（coinbase奖励必须达到在100个区块后才可以消费）： $ bitcoin-cli -regtest getbalance 12462.50000000 使用测试区块链进行开发 比特币的各种区块链（ regtest，segnet，testnet3，mainnet）为比特币开发提供了一系列测试环境。无论你是为Bitcoin Core开发还是另一个完整节点共识客户端，都可以使用测试区块链。应用程序，如钱包，交换，电子商务网站；甚至开发新颖的智能合约和复杂的脚本。 你可以使用测试区块链建立开发管道。开发时，在 regtest 上本地测试你的代码。一旦准备好在公共网络上尝试它，切换到 testnet 以将代码暴露于有多种的代码和应用的，更具动态性的环境中。最后，一旦你确信自己的代码能够按预期工作，请切换到 mainnet 以在生产环境中进行部署。当你进行更改，改进，错误修复等时，请再次启动管道，首先是 regtest，然后是 testnet，最后部署到生产环境中。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 15:28:01 "},"12第十章.html":{"url":"12第十章.html","title":"挖矿和共识","keywords":"","body":"挖矿和共识 概述 \"挖矿\"一词是有一些误导性的。通过类比贵金属的提取，它将我们的注意力集中在挖矿的奖励上，这是每个区块创建的新比特币。尽管这种奖励激励了挖矿，但挖矿的主要目的不是奖励或生成新的硬币。如果你仅将挖矿看作是创建比特币的过程，那么你就错误地将手段（激励）当成了过程的目标。挖矿是支撑去中心化清算所的机制，使交易得到验证和清算。挖矿是使比特币特别的发明，是一种去中心化的安全机制，是P2P数字现金的基础。 新铸造的硬币和交易费用奖励是一种激励计划，它将矿工的行为与网络的安全保持一致，同时实施货币供应。 > 挖矿的目的不是创造新的比特币。这是激励机制。挖矿是使比特币的 安全性 security 去中心化 decentralized的机制。 矿工确认新的交易并将其记录在全球总账中。包含自上一个区块以来发生的交易的新区块，平均每10分钟被\"挖掘\"，从而将这些交易添加到区块链中。成为区块的一部分并添加到区块链中的交易被认为是“确认”的，这允许比特币的新的所有者花费他们在这些交易中收到的比特币。 为矿工获得两种类型的奖励以换取挖矿提供的安全性：每个新块创建的新币以及该块中包含的所有交易的交易费用。为了获得这种奖励，矿工们竞相解决基于密码散列算法的数学难题。这个难题的解决方案被称为工作证明（Proof-of-Work），它被包含在新的区块中，作为矿工大量计算工作的证据。解决PoW算法赢得奖励以及在区块链上记录交易的权利的竞争是比特币安全模型的基础。 这个过程称为采矿，因为奖励（新硬币的产生）旨在模拟像开采贵金属一样的收益递减。比特币的货币供应是通过采矿创造的，类似于央行通过打印钞票发行新货币的方式。大约每四年（或正好每210,000块），一个矿工可以添加到区块的最大新增比特币数量减少一半。2009年1月开始每个区块50比特币，2012年11月每个区块减半到25比特币，2016年7月再次减少到12.5比特币。基于这个公式，比特币挖矿奖励指数级下降，到2140年左右，所有的比特币（21千万）将发行完毕。2140年以后，不会有新的比特币发行。 比特币矿工也从交易中赚取费用。每笔交易都可能包含一笔交易费用，费用以交易的输入与输出之间的盈余形式体现。获胜的比特币矿工可以对包含在获奖块中的交易“零钱”。今天，这笔费用占比特币矿工收入的0.5％或更少，绝大多数来自新铸造的比特币。然而，奖励随着时间推移而减少，每个区块的交易数量逐渐增加，比特币开采收入的更大比例将来自费用。逐渐地，采矿奖励将由交易费取代，成为矿工的主要动机。2140年以后，每个区块的新比特币数量将降至零，比特币开采将仅通过交易费用获得激励。 在本章中，我们首先将挖矿视为货币供应机制进行研究，然后研究挖矿最重要的功能：支持比特币安全性的分散式共识机制。 要理解挖矿和共识，我们会跟踪Alice的交易，它被Jing的挖矿设备接收并添加到一个区块。然后我们将跟踪这个区块，它被挖掘并添加到区块链，然后通过自发共识（emergent consensus）的过程被比特币网络接受。 比特币经济学和货币创造 比特币在创建每个区块时以固定和递减的速度被“铸造”。平均每10分钟产生一个包含全新的比特币的区块，凭空产生。每隔21万个区块，或大约每四年，货币发行速率就会下降50％。在网络运转的前四年，每个区块包含50个新的比特币。 2012年11月，比特币发行速率降至每块25比特币。2016年7月，再次下降到每块12.5比特币。它将在630,000块区块再次减半至6.25比特币，这将是2020年的某个时间。新硬币的比率将按照指数规律进行32次“减半”，直到6,720,000块（大约在2137年开采），达到最低货币单位，1 satoshi。大约2140年之后，将有690万个区块，发行近2,099,999,997,690,000个satoshis，即将近2100万比特币。此后，区块将不包含新的比特币，矿工将仅通过交易费获得奖励。 Supply of bitcoin currency over time based on a geometrically decreasing issuance rate 展示了随时间推移流通的比特币总量，货币发行量下降。 Figure 1. Supply of bitcoin currency over time based on a geometrically decreasing issuance rate > 开采的最大硬币数量是比特币可能的挖矿奖励的上限。实际上，矿工可能会故意挖掘一个获得的奖励少于全部奖励的区块。已经有这样的区块，之后可能更多，这将导致货币供应量的减少。 在 A script for calculating how much total bitcoin will be issued 的示例代码中，我们计算比特币的发行总量。 Example 1. A script for calculating how much total bitcoin will be issued link:code/max_money.py[] Running the max_money.py script 展示了运行脚本的结果 Example 2. Running the max_money.py script $ python max_money.py Total BTC to ever be created: 2099999997690000 Satoshis 有限和递减的发行，保证了固定的货币供应量，可以抵制通货膨胀。不同于法定货币中央银行的无限印钱，比特币永远不会因印钱而膨胀。 通货紧缩的货币 固定和递减的货币发行的最重要的和有争议的后果是，货币倾向于内在地 通货紧缩。通货紧缩是由于供求失衡导致货币价值（和汇率）升值的现象。与通货膨胀相反，价格通缩意味着这些资金随着时间的推移具有更多的购买力。 许多经济学家认为，通货紧缩的经济是一场应该不惜一切代价避免的灾难。这是因为在通货紧缩时期，人们倾向于囤积钱而不是花钱，希望价格会下跌。日本“失去的十年”期间，这种现象就显现出来了，当时需求的彻底崩溃将货币推向通缩螺旋。 比特币专家认为，通货紧缩本身并不糟糕。当然，通货紧缩与需求崩溃有关，因为这是我们必须研究的唯一的通缩的例子。在可以无限印刷的法定货币下，进入通货紧缩螺旋是非常困难的，除非需求完全崩溃并且政府不愿印钞。比特币的通货紧缩不是由需求崩溃引起的，而是由可预见的供应紧张造成的。 通货紧缩的积极方面当然与通货膨胀相反。通货膨胀导致货币缓慢但不可避免的贬值，导致一种隐藏的税收形式，为拯救债务人（包括最大的债务人，政府本身）而对储户进行惩罚。政府控制下的货币受到轻易发行债券的道德风险的影响，后者可以通过贬值而以牺牲储蓄者为代价来消除。 当通货紧缩不是经济快速收缩带来的问题时，通货紧缩是有问题的还是有优势的，还有待观察，因为防止通货膨胀和贬值的远比通货紧缩的风险重要。 去中心化共识（Decentralized Consensus） 在上一章中，我们考察了区块链，即所有交易的全球公共账本（列表），比特币网络中的每个人都认可它作为所有权的权威记录。 但是，网络中的每个人怎么能够就一个普遍的“真相”达成一致：谁拥有什么，而不必相信任何人呢？所有传统的支付系统都依赖于信托模式，该模式具有提供清算所服务的中央机构，验证和清算所有交易。比特币没有中央权威机构，但每个完整的节点都有一个可以信任的权威记录的公共账本的完整副本。区块链不是由中央机构创建的，而是由网络中的每个节点独立组装。而且，网络中的每个节点都会根据通过不安全的网络连接传输的信息，得出相同的结论，并与其他人一样收集相同的公共账本。本章将探讨比特币网络在没有中央权威机构的情况下达成全球共识的过程。 中本聪的主要发明是 自发共识 的去中心化机制。自发，是因为共识不是明确地达成的，达成共识时没有选举或固定的时刻。相反，共识是数千个遵循简单规则的独立节点，异步交互的自发性产物。 比特币的所有属性，包括货币，交易，支付，以及不依赖中央机构或信任的安全模型，都源自于这项发明。 比特币的去中心化共识来自四个独立于网络节点的过程的相互作用： 每笔交易由完整节点独立验证，基于一份全面的标准清单 通过挖矿节点将交易独立地聚合到新的区块中，并通过PoW算法证明计算。 每个节点独立验证新的区块，并组装到区块链中 通过工作流程证明，每个节点独立选择具有最多累积计算量证明的链 在接下来的几节中，我们将研究这些流程以及它们如何相互作用创建网络共识的自发性，以允许任何比特币节点组装自己的权威的、信任的、公共的全局账本的副本。 独立交易验证 在 [transactions] 中, 我们看到了钱包软件如何通过收集UTXO创建交易，提供适当的解锁脚本，然后构建分配给新所有者的新输出。然后将产生的交易发送到比特币网络中的相邻节点，以便它可以在整个比特币网络上传播。 但是，在向邻居转发交易之前，接收交易的每个比特币节点都将首先验证交易。确保只有有效的交易通过网络传播，无效的交易会被遇到它们的第一个节点丢弃。 每个节点根据一个很长的标准检查清单验证每笔交易： 交易的语法和数据结构必须正确 输入和输出列表都不为空 所有交易的字节大小小于 MAX_BLOCK_SIZE. 每个输出值，和总的输出值，都必须在允许的范围区间（小于2100万比特币，大于 dust 阈值） 任何输入的hash不等于0，N不等于-1 (币基交易不应该被传播） nLocktime 等于 INT_MAX, 或者 nLocktime 和 nSequence 的值满足 MedianTimePast 的要求 每笔交易的字节大小大于或等于 100 交易中包含的签名操作（SIGOPS) 小于签名操作限制 解锁脚本( scriptSig ）只能向栈中压入数值, 锁定脚本 (scriptPubkey) 必须匹配 IsStandard 格式 (拒绝非标准的交易). 交易池或主分支的一个区块中必须存在这笔交易 对于每个输入，如果引用的输出存在于池中的任意一笔其他交易中，则这笔交易被拒绝 对于每个输入，查找主分支和交易池以找到引用的输出的交易。如果任何输入的输出交易丢失，这将成为一笔孤儿交易。如果匹配的交易没在池中，添加它到孤儿交易池 对于每个输入，如果引用的交易是币基输出，它必须有至少 COINBASE_MATURITY (100) 次确认 对于每个输入，引用的输出必须存在且未被花费 使用引用的输出交易来获得输入值，检查每个输入值，以及总和，在允许的范围中（大于0，小于2100万). 如果输入值的总和小于输出值的总和，拒绝 如果交易费太低（ minRelayTxFee ），拒绝 每个输入的解锁脚本必须与对应的输出的锁定脚本匹配 这些条件的详情可以在 Bitcoin Core 中的 AcceptToMemoryPool, CheckTransaction, 和 CheckInputs 中看到。注意，条件是随时间改变的，以应对新的拒绝服务攻击类型，或者放松规则以包含更多类型的交易。 通过在交易到达后，向外传播前，独立验证，每个节点都简历了一个有效（但未确认）的交易池，称为 transaction pool，memory pool 或 mempool。 挖矿节点 Jing，上海的计算机工程学生，是一个比特币矿工。Jing通过运营一个“钻井平台”来获得比特币，这是针对比特币设计的专业计算机硬件系统。Jing的这套专业系统连接到一个完整比特币节点服务器。和 Jing 的做法不同，一些矿工在没有完整节点的情况下挖矿，我们将在 矿池 中看到。和每个完整节点一样，Jing的节点在比特币网络上接收和传播未确认的交易，也将这些交易聚合到新的区块中。 Jing的节点和所有节点一样，监听在比特币网络上传播的新块。但是，新块的出现对挖矿节点有特殊的意义。矿工之间的竞争实际上以一个新的区块的传播而结束，这个区块的作用是宣布一个赢家。对矿工来说，得到一个有效的新区块意味着其他人赢得了竞争，而他们输了。然而，一轮比赛的结束也是下一轮比赛的开始。新的区块不只是一个方格旗，标志着比赛的结束；它也是下一个区块竞赛的发令枪。 将交易聚合到区块中 在验证交易之后，比特币节点将把它们添加到 memory pool 或 transaction pool 中，在那里等待交易被包含(挖掘)到一个块中。Jing的节点收集、验证和转发新的交易，就像其他节点一样。然而，与其他节点不同的是，Jing的节点将这些交易聚合到 candidate block 中。 我们来看看Alice在Bob’s Cafe买咖啡时创建的区块(见 [cup_of_coffee] )。Alice的交易包含在277,316块中。为了演示本章的概念，让我们假设该区块是由Jing的采矿系统挖掘的，并跟踪Alice的交易，是如何成为这个新块的一部分的。 Jing的挖矿节点维护区块链的本地副本。当Alice买咖啡的时候，Jing的节点已经装配了一个链到277,314。Jing的节点监听交易，试图挖掘一个新块，也监听其他节点发现的块。当Jing的节点在挖掘时，它通过比特币网络接收到区块 277315。这个区块的到来标志着第277315区块竞赛的结束，以及第277316区块竞赛的开始。 在之前的10分钟里，Jing的节点搜索277,315块的解决方案时，它也在收集交易，并为下一个块做准备。到目前为止，它已经在内存池中收集了几百个交易。在接收到第277315块并进行验证之后，Jing的节点还将它与内存池中的所有交易进行比较，并删除第277315块中包含的任何交易。留在内存池中的交易都是未确认的，并等待在新的块中记录。 Jing的节点立即构造一个新的空块，作为277,316块的候选。这个块被称为 candidate block ，因为它还不是一个有效的块，不包含有效的工作证明。只有当矿机成功找到PoW的解决方案时，该块才有效。 当Jing的节点将内存池中的所有交易汇总时，新的候选块有418笔交易，总交易费用为0.09094928比特币。你可以使用Bitcoin Core客户端命令行接口在区块链中看到这个块，如 Using the command line to retrieve block 277,316 所示。 Example 3. Using the command line to retrieve block 277,316 $ bitcoin-cli getblockhash 277316 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d9\\ 44a9b31b2cc7bdc4 { \"hash\" : \"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4\", \"confirmations\" : 35561, \"size\" : 218629, \"height\" : 277316, \"version\" : 2, \"merkleroot\" : \"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e\", \"tx\" : [ \"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f\", \"b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe\", ... 417 more transactions ... ], \"time\" : 1388185914, \"nonce\" : 924591752, \"bits\" : \"1903a30c\", \"difficulty\" : 1180923195.25802612, \"chainwork\" : \"000000000000000000000000000000000000000000000934695e92aaf53afa1a\", \"previousblockhash\" : \"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569\" } 币基交易 区块中的第一笔交易是一笔特殊的交易，叫做 币基交易 coinbase transaction。这笔交易是 Jing 的节点创建的，包含对他的挖矿努力的奖励。 > 当区块 277,316 被挖出时，奖励是每个区块25比特币。在其之后，一个“减半”周期已经过去。区块奖励在2016年7月变为12.5比特币。2020年，到达210000块时，将再次减半。 Jing的节点创建了coinbase交易，对自己钱包的支付：“支付给Jing的地址25.09094928比特币”。Jing开采一个区块所收取的奖励总额是币基奖励(25个新比特币)和该区块所有交易的费用（0.09094928）之和，如 Coinbase transaction 所示。 Example 4. Coinbase transaction $ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1 { \"hex\" : \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000\", \"txid\" : \"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f\", \"version\" : 1, \"locktime\" : 0, \"vin\" : [ { \"coinbase\" : \"03443b0403858402062f503253482f\", \"sequence\" : 4294967295 } ], \"vout\" : [ { \"value\" : 25.09094928, \"n\" : 0, \"scriptPubKey\" : { \"asm\" : \"02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG\", \"hex\" : \"2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac\", \"reqSigs\" : 1, \"type\" : \"pubkey\", \"addresses\" : [ \"1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N\" ] } } ] } 与一般交易不同，币基交易不消耗（花费）UTXO作为输入。它只有一个输入，叫做 coinbase 币基，从无创造比特币。币基交易有一笔输出，可支付给矿工自己的比特币地址。币基交易的输出将 25.09094928 比特币发送到矿工的比特币地址；在这个例子中，是：1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N. 币基奖励和费用 为了创建币基交易，Jing的节点首先通过累计418笔交易的输入和输出计算所有交易费用。计算方式如下： Total Fees = Sum(Inputs) - Sum(Outputs) 在区块 277,316 中，总的交易费用为 0.09094928 比特币。 接下来，Jing的节点计算新块的正确奖励。奖励是根据块的高度来计算的，从每块50比特币开始，每21万个块减少一半。因为这个方块的高度是277,316，正确的奖励是25比特币。 在 Bitcoin Core 客户端的 GetBlockSubsidy 方法中可以看到，如 Calculating the block reward —— Function GetBlockSubsidy, Bitcoin Core Client, main.cpp 所示： Example 5. Calculating the block reward —— Function GetBlockSubsidy, Bitcoin Core Client, main.cpp CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams) { int halvings = nHeight / consensusParams.nSubsidyHalvingInterval; // Force block reward to zero when right shift is undefined. if (halvings >= 64) return 0; CAmount nSubsidy = 50 * COIN; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy >>= halvings; return nSubsidy; } 最初的奖励以 聪（satoshis）为单位，通过50乘以 COIN 常数（100,000,000聪）。这将初始奖励设置为 50亿 satoshis。 然后，方法计算 halvings （减半）的次数，当前块高度除减半区间（ SubsidyHalvingInterval ），在这个例子中，是 277,316 / 210,000，结果为1。 最大的减半次数为 64，所以如果超过 64 次减半，代码返回 0 （只奖励费用）奖励。 接下来，该函数使用二进制右移运算符将奖励（ nSubsidy ）分为两半。在277,316区块的情况下，对50亿 satoshis 的奖励进行二元右移（一次减半），结果为 25亿 satoshis 或25个比特币。使用二进制右移运算符是因为它比多次除法更有效率。为了避免潜在的错误，位移操作在63次减半后跳过，补贴设置为0。 最后，币基奖励 (nSubsidy) 被加到交易费上 (nFees), 返回总和。 > 如果Jing的挖矿节点写出了coinbase交易，那么Jing是不是可以“奖励”他自己的100或1000比特币？答案是，错误的奖励会导致该块被其他人认为是无效的，从而浪费了Jing用于工作证明的电力。只有该块被大家接受，Jing才能花费奖励。 币基交易的结构 通过这些计算，Jing的节点通过支付其自己 25.09094928 比特币构建币基交易。 如你在 Coinbase transaction 中看到, 币基交易有特殊的格式。不同于指定一个要花费的之前的UTXO的交易输入，它有一个 \"coinbase\" 输入。我们在 [tx_in_stracture] 中检查交易输入。让我们比较一下普通交易输入和币基交易输入。The structure of a \"normal\" transaction input 展示了普通交易输入的结构，The structure of a coinbase transaction input 展示了币基交易输入的结构。 Table 1. The structure of a \"normal\" transaction input Size Field Description 32 bytes 交易的Hash 指向包含要花费的UTXO的交易的指针 4 bytes 输出的索引 要花费的UTXO的索引号，第一个从0开始 1-9 bytes (VarInt) 解锁脚本大小 接下来的解锁脚本的长度（字节） Variable 解锁脚本 满足UTXO锁定脚本条件的脚本 4 bytes 序列号 目前禁用的 Tx-replacement 功能, 设置为 0xFFFFFFFF Table 2. The structure of a coinbase transaction input Size Field Description 32 bytes 交易的Hash 所有位都是0：没有要引用的交易 4 bytes 输出的索引 所有位都是1: 0xFFFFFFFF 1-9 bytes (VarInt) 币基数据大小 币基数据的长度，2 到 100 字节 Variable 币基数据 用于额外随机数和采矿标签的任意数据。在v2块中，必须从块高开始 4 bytes 序列号 设为 0xFFFFFFFF 在币基交易中，前两个字段被设置为不引用UTXO的值。不同于“交易的Hash”，第一个字段填充32个字节，全部设置为零。 “输出索引” 填充4个字节，全部设置为0xFF（十进制255）。“解锁脚本”（ scriptSig ）被币基数据（Coinbase Data）取代，这是矿工使用的数据字段，我们将在下面看到。 币基数据 Coinbase Data 币基交易没有解锁脚本（ scriptSig ）字段。这个字段被 coinbase data 替代，该字段必须包含 2-100 个字节。除了前几个字节，其他的可由矿工填充任意数据。 例如，中本聪在创世区块的 coinbase data 中加入了文本 \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\", 将它作为日期的证明，并传达了一个信息. 现在，矿工使用 coinbase data 存放额外的随机值，和识别矿池的字符串。 币基的前几个字节以前是随机的，但现在不是了。根据BIP-34，version-2区块（版本号为2）必须在币基交易字段的开头包含区块高度作为脚本 push 操作。 在区块 211,316 中我们看到的币基（ 参见 Coinbase transaction ），位于交易输入的解锁脚本或 scriptSig 字段，包含十六进制值 03443b0403858402062f503253482f。让我们解码它。 第一个字节 03 指示脚本执行引擎将接下来的三个字节压入脚本堆栈(参见 [tx_script_ops_table_pushdata] )。接下来的三个字节，0x443b04，是用小端序编码的块高度(倒序，低位字节优先)。反转字节的顺序，结果是 0x043b44 ，十进制是277,316。 接下来的几个十六进制数据（0385840206），编码了额外的随机数（参见 额外随机数解决方案），用于找到PoW的解决方案。 币基数据的最后部分（ 2f503253482f ）是ASCII编码的字符串 /P2SH/，表明挖到这个区块的节点支持 BIP-16 中定义的 P2SH 交易。P2SH 能力的引入要求矿工认可BIP-16或BIP-17。支持BIP-16的人将在他们的coinbase数据中包含 /P2SH/。支持P2SH的BIP-17实现的人将字符串 p2sh/CHV 包含在他们的coinbase数据中。BIP-16胜出，许多矿工继续在他们的coinbase中包含字符串 /P2SH/ ，以表示对该特性的支持。 Extract the coinbase data from the genesis block 使用 [alt_libraries] 中介绍的 libbitcoin 库从创世区块中提取币基数据，展示中本聪的信息。注意，libbitcoin 库包含一份创世区块的静态副本，所以示例代码可以直接从库中检索到创世区块。 Example 6. Extract the coinbase data from the genesis block link:code/satoshi-words.cpp[] 我们使用 GNU C++ 编译器编译和运行： Example 7. Compiling and running the satoshi-words example code $ # Compile the code $ g++ -o satoshi-words satoshi-words.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the executable $ ./satoshi-words The Times 03/Jan/2009 Chancellor on brink of second bailout for banks 构建区块头 要构建区块头，挖矿节点需要填充6个字段，在 The structure of the block header 列出： Table 3. The structure of the block header Size Field Description 4 bytes Version 最终软件/协议更新的版本号 32 bytes Previous Block Hash 引用链中上一个块（父块）的哈希值 32 bytes Merkle Root 该区块中交易的merkle树的根Hash 4 bytes Timestamp 区块的大概创建时间（ Unix 纪元以来的秒数 ) 4 bytes Target 该区块的 PoW 算法目标 4 bytes Nonce PoW 算法使用的计数器 在 277,316 区块被挖掘时，区块结构的版本号是2，以小端序编码为四字节是 0x02000000. 接下来，挖矿节点需要添加 \"Previous Block Hash\" ( 称为 prevHash )。这是 277,315 区块的哈希值，是 Jing 的节点从网络收到并接受的作为候选区块 277,316 的父区块。277,315 区块的哈希值是： 0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569 > 通过选择特定的父块(由候选块头中的 Previous Block Hash 字段所指示)，Jing将其挖掘能力用于扩展以该特定块结束的链。从本质上说，这就是 Jing 使用他的挖矿力量为最长难度的有效链“投票”。 下一步是使用merkle树汇总所有交易，以便将merkle根添加到块头中。coinbase交易被列为块中的第一个交易。然后，在它之后又添加了418个交易，总共在块中添加了419个交易。如我们在 [merkle_trees] 中看到的，树中必须有偶数个“叶子”节点，因此最后一个交易被复制，创建420个节点，每个节点都包含一个交易的散列。然后将交易散列成对地组合在一起，创建树的每一级，直到将所有交易汇总为树的“根”节点。merkle树的根将所有交易汇总为单个32字节的值，你可以看到 Using the command line to retrieve block 277,316 中列出的“merkle root”: c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e Jing 的挖矿节点然后将添加 4字节的时间戳，编码为 Unix 纪元时间戳，表示从 UTC/GMT时间 1970年1月1日 零点 以来的秒数，1388185914 等于 Friday, 27 Dec 2013, 23:11:54 UTC/GMT。 然后 Jing 的节点填充 目标（target）字段，定义了使其成为一个有效区块所需的PoW。target 在区块中以 \"target bits\" 矩阵存储，这是目标的 尾数-指数（mantissa-exponent）编码。编码有1字节的指数，紧接3字节的尾数（系数）。例如，在区块 277,316 中，target bits 的值是 0x1903a30c。第一部分 0x19 是一个十六进制指数，后面的部分，0x03a30c，是系数。target 的概念和 target bits 的表示分别在 重新设定目标调整难度 和 目标（Target）的表示 中说明。 最后一个字段是随机数（nonce），初始化为0。 随着所有其他字段被填充，区块头现在已经完成，挖矿过程开始。目标是找到一个随机数的值，使区块头的哈希值小于 target。在找到合适的随机值前，挖矿节点可能需要尝试数十亿，或数万亿次。 挖掘区块 用最简单的术语来说，挖矿是重复散列区块头的过程，不断更改参数，直到生成的哈希值与特定目标相匹配。散列函数的结果不能预先确定，也不能创建产生特定哈希值的模式。散列函数的这种特性意味着产生匹配特定目标的散列结果的唯一方法是反复尝试，随机修改输入，直到偶然出现所需的结果。 工作量证明算法 Proof-of-Work Algorithm 密码散列算法的关键特征是，在计算上不可能找到产生相同指纹的两个不同输入（称为 碰撞 collision）。作为推论，除了尝试随机输入之外，通过选择输入以产生期望的指纹的方式实际上也是不可能的。 使用SHA256，无论输入是什么，输出总是256位的。在 SHA256 example 中，我们使用Python解释器计算 \"I am Satoshi Nakamoto.\" 的SHA256哈希值。 Example 8. SHA256 example $ python Python 2.7.1 >>> import hashlib >>> print hashlib.sha256(\"I am Satoshi Nakamoto\").hexdigest() 5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e SHA256 example 展示了 \"I am Satoshi Nakamoto\" 的哈希结果：5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e. 这个 256位的数字是这句话的 哈希 hash 或 摘要 digest，基于这句话的每部分。添加一个字母、标点符号，或其他任何字符都将产生不一样的哈希值。 现在，如果我们改变语句，会会看到完全不同的哈希值。让我们使用 SHA256 script for generating many hashes by iterating on a nonce 中简单的Python脚本尝试在尾部添加数组。 Example 9. SHA256 script for generating many hashes by iterating on a nonce link:code/hash_example.py[] 运行它将产生几个短语的散列，通过在文本末尾添加一个数字来使其不同。通过增加数字，我们可以得到不同的散列，如 SHA256 output of a script for generating many hashes by iterating on a nonce 所示。 Example 10. SHA256 output of a script for generating many hashes by iterating on a nonce $ python hash_example.py I am Satoshi Nakamoto0 => a80a81401765c8eddee25df36728d732... I am Satoshi Nakamoto1 => f7bc9a6304a4647bb41241a677b5345f... I am Satoshi Nakamoto2 => ea758a8134b115298a1583ffb80ae629... I am Satoshi Nakamoto3 => bfa9779618ff072c903d773de30c99bd... I am Satoshi Nakamoto4 => bce8564de9a83c18c31944a66bde992f... I am Satoshi Nakamoto5 => eb362c3cf3479be0a97a20163589038e... I am Satoshi Nakamoto6 => 4a2fd48e3be420d0d28e202360cfbaba... I am Satoshi Nakamoto7 => 790b5a1349a5f2b909bf74d0d166b17a... I am Satoshi Nakamoto8 => 702c45e5b15aa54b625d68dd947f1597... I am Satoshi Nakamoto9 => 7007cf7dd40f5e933cd89fff5b791ff0... I am Satoshi Nakamoto10 => c2f38c81992f4614206a21537bd634a... I am Satoshi Nakamoto11 => 7045da6ed8a914690f087690e1e8d66... I am Satoshi Nakamoto12 => 60f01db30c1a0d4cbce2b4b22e88b9b... I am Satoshi Nakamoto13 => 0ebc56d59a34f5082aaef3d66b37a66... I am Satoshi Nakamoto14 => 27ead1ca85da66981fd9da01a8c6816... I am Satoshi Nakamoto15 => 394809fb809c5f83ce97ab554a2812c... I am Satoshi Nakamoto16 => 8fa4992219df33f50834465d3047429... I am Satoshi Nakamoto17 => dca9b8b4f8d8e1521fa4eaa46f4f0cd... I am Satoshi Nakamoto18 => 9989a401b2a3a318b01e9ca9a22b0f3... I am Satoshi Nakamoto19 => cda56022ecb5b67b2bc93a2d764e75f... 每个短语产生一个完全不同的散列结果。它们看起来完全是随机的，但是你可以在使用Python的任何计算机上再次生成这个示例中的结果，并看到相同的哈希。 在这种场景中用作变量的数字称为nonce。nonce用于改变加密函数的输出，在本例中，是为了改变短语的SHA256指纹。 要对这个算法提出挑战，我们来设置一个目标:找到一个短语，它生成一个以0开头的十六进制散列。幸运的是,这并不难! [sha256_example_generator_generator_output ] 显示：\"I’m Satoshi Nakamoto13\" 这个短语产生的是一个符合我们的标准的哈希值：0ebc56d59a34f5082aaef3d661696c2b618e6243272169531041a5。花了13次才找到它。在概率方面,如果哈希函数的输出是均匀分布的，我们可以期望每16次找到一个以0开头的结果（16个十六进制数字0到F中的一个）。在数值方面，这就意味着找到一个散列值,小于 0 x1000000000000000000000000000000000000000000000000000000000000000。我们将这个阈值称为target，目标是找到一个在数值上小于目标的哈希值。如果我们减少目标，查找小于目标的哈希值的任务将变得越来越困难。 打个简单的比方，想象这样一个游戏：玩家不断地掷一副骰子，试图掷得比指定的目标少。在第一轮，目标是12个。除非你掷双六，否则你就能赢。下一轮的目标是11。玩家必须投出10或更少的数值才能获胜。这同样是一项简单的任务，假设几轮之后，目标是5。现在，超过一半的结果将超过目标而无效。随着目标降低，要想赢得胜利，掷骰子的次数要成倍增加。最终，当目标是2（可能的最小值）时，每36次投掷中只有一次，或其中的2%，会产生一个胜利的结果。 从一个知道骰子游戏的目标是2的观察者的角度来看，如果有人成功地投出了一个成功的结果，那么可以假设他们平均尝试了36次。换句话说，一个人可以从目标设定的难度中估计成功所需要的工作量。当算法是基于确定性函数（如SHA256）时，输入本身就构成了 证明 proof，证明做了一定量的 工作 work 才产生低于目标的结果。所以称为, Proof-of-Work。 > 即使每次尝试都会产生随机结果，任何可能结果的概率都可以提前计算。因此，特定难度的结果构成特定工作量的证明。 在 SHA256 output of a script for generating many hashes by iterating on a nonce 中, 获胜的“nonce”是13，这个结果可以被任何人独立的验证。任何人都可以在短语“我是中本聪”后面加上数字13，然后计算哈希，验证它是否小于目标。成功的结果也是工作的证明，因为它证明我们做了工作去发现那一次。虽然只需要一次哈希计算就可以验证，但我们需要13次哈希计算才能找到一个有效的nonce。如果我们有一个更低的目标(更高的难度)，那么需要更多的哈希计算才能找到一个合适的nonce，但是对于任何人来说，只有一个哈希计算需要验证。此外，通过了解目标，任何人都可以使用统计数据来估计困难程度，从而知道需要做多少工作才能找到这样一个nonce。 > PoW必须生成一个小于目标的哈希值。更高的目标意味着找到低于目标的哈希值要容易得多。较低的目标意味着更难在目标以下找到哈希值。目标和难度是反比的。 比特币的PoW与 SHA256 output of a script for generating many hashes by iterating on a nonce 所展示的挑战非常相似。矿机构造一个充满交易的候选块。接下来，挖矿程序计算这个块头的散列，看看它是否小于当前的 target。如果哈希值不小于目标，那么矿机将修改nonce(通常只将其递增1次)，并再次尝试。在比特币网络目前的难度下，矿工必须尝试千万亿次，才能找到一个能产生足够低的区块头哈希的nonce。 一个非常简单的PoW在 Simplified Proof-of-Work implementation 中以Python实现 Example 11. Simplified Proof-of-Work implementation link:code/proof-of-work-example.py[] 运行这段代码，你可以设置所需的难度(以位为单位，有多少位前导位必须为零)，并查看计算机需要多长时间才能找到解决方案。在 [pow_example_output] 中，你可以看到它在普通的笔记本上是如何工作的。 Example 12. Running the Proof-of-Work example for various difficulties $ python proof-of-work-example.py* Difficulty: 1 (0 bits) [...] Difficulty: 8 (3 bits) Starting search... Success with nonce 9 Hash is 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1 Elapsed Time: 0.0004 seconds Hashing Power: 25065 hashes per second Difficulty: 16 (4 bits) Starting search... Success with nonce 25 Hash is 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148 Elapsed Time: 0.0005 seconds Hashing Power: 52507 hashes per second Difficulty: 32 (5 bits) Starting search... Success with nonce 36 Hash is 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903 Elapsed Time: 0.0006 seconds Hashing Power: 58164 hashes per second [...] Difficulty: 4194304 (22 bits) Starting search... Success with nonce 1759164 Hash is 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3 Elapsed Time: 13.3201 seconds Hashing Power: 132068 hashes per second Difficulty: 8388608 (23 bits) Starting search... Success with nonce 14214729 Hash is 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3 Elapsed Time: 110.1507 seconds Hashing Power: 129048 hashes per second Difficulty: 16777216 (24 bits) Starting search... Success with nonce 24586379 Hash is 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95 Elapsed Time: 195.2991 seconds Hashing Power: 125890 hashes per second [...] Difficulty: 67108864 (26 bits) Starting search... Success with nonce 84561291 Hash is 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a Elapsed Time: 665.0949 seconds Hashing Power: 127141 hashes per second 如你所见，将难度增加1位会使找到解决方案所需的时间增加一倍。如果考虑整个256位的数字空间，每次将多一个位限制为0，搜索空间就减少了一半。在 [pow_example_output ] 中，需要8400万次哈希才能找到一个nonce，它产生的哈希有26个前导位为零。即使以每秒超过12万次哈希的速度，在笔记本上也需要10分钟才能找到这个解决方案。 在编写本文时，网络正在尝试查找一个小于以下值的区块头哈希： 0000000000000000029AB9000000000000000000000000000000000000000000 如你所见，目标的开头有很多0，这意味着可以接受的散列范围要小得多，很难找到一个有效的哈希值。网络要发现下一个区块，平均每秒需要超过1.8 zeta-hashes(thousand billion billion hashes)。这似乎是一项不可能完成的任务，但幸运的是，网络有每秒产生3个exa-hashes(EH/sec)的处理能力，平均10分钟就能找到一个block。 目标（Target）的表示 在 Using the command line to retrieve block 277,316 中，我们看到这个块包含了目标，以一个称为“target bits”或只是“bits”，在块277,316中的值为 0x1903a30c。该表示法将工作量证明的验证目标表示为系数/指数格式，前两个十六进制数字是指数，后六个十六进制数字是系数。因此，在这个区块中，指数为 0x19，系数为 0x03a30c。 这种表达方式下计算难度目标的公式是： target = coefficient 2(8(exponent–3)) 使用这个公式，和难度bits值 0x1903a30c，可以得到： target = 0x03a30c 20x08(0x19-0x03) => target = 0x03a30c 2(0x080x16) => target = 0x03a30c * 20xB0 十进制就是： => target = 238,348 * 2176 => target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328 转换为十六进制： => target = 0x0000000000000003A30C00000000000000000000000000000000000000000000 这意味着高度为277,316的有效块是区块头的哈希值小于目标的块。在二进制中，该数字必须有超过60个前导位设置为零。有了这样的难度，一个矿工每秒处理1万亿次哈希，平均只能每8,496个块或每59天寻找到一次解决方案。 重新设定目标调整难度 正如我们所看到的，目标确定了难度，因此影响了找到工作证明算法的解决方案所需的时间。这就引出了一个明显的问题：为什么困难是可以调整的，由谁来调整，以及如何调整? 比特币的区块平均每10分钟生成一次。这是比特币的心跳，支撑着货币发行的频率和交易结算的速度。它必须保持不变，不仅是短期的，而是持续几十年。在这段时间里，预计计算机的能力将继续快速增长。此外，参与挖矿的人和计算机的数目也不断变化。为了保持10分钟的生成时间，必须考虑这些变化调整挖掘的难度。事实上，工作证明的目标是一个动态参数，它定期调整以满足10分钟的区块间隔目标。简单地说，可以设置目标值，使当前的挖矿能力导致10分钟的区块间隔。 那么，这种调整是如何在一个完全分散的网络中进行的呢？重新设定目标是独立地在每个节点上自动进行的。每产生2016个区块，所有节点都重新设定PoW目标。重新设定目标的公式衡量了找到最后2016个区块所需的时间，并与预期的20160分钟(2016个区块乘以期望的10分钟区块间隔)进行了比较。计算实际时间间隔和期望时间间隔的比例，并对目标按比例进行调整(向上或向下)。简单地说：如果网络发现区块的速度比每10分钟快，难度就会增加(目标范围缩小)。如果区块发现速度比预期的要慢，那么难度就会降低(目标范围增加)。 公式如下： New Target = Old Target * (Actual Time of Last 2016 Blocks / 20160 minutes) Retargeting the Proof-of-Work —— CalculateNextWorkRequired() in pow.cpp 展示了 Bitcoin Core 客户端使用的代码。 Example 13. Retargeting the Proof-of-Work —— CalculateNextWorkRequired() in pow.cpp // Limit adjustment step int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime; LogPrintf(\" nActualTimespan = %d before bounds\\n\", nActualTimespan); if (nActualTimespan params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; arith_uint256 bnOld; bnNew.SetCompact(pindexLast->nBits); bnOld = bnNew; bnNew *= nActualTimespan; bnNew /= params.nPowTargetTimespan; if (bnNew > bnPowLimit) bnNew = bnPowLimit; > 目标值的校准每2,016个区块发生一次，由于原始的比特币核心客户端中出现了一个差一的错误，它是基于之前的2,015个块（而不是应该的2,016块）的总时间，导致重新设定的目标倾向于难度增加0.05%。 Interval (2,016 个区块) 和 TargetTimespan (两周时间，1,209,600 seconds) 两个参数在 chainparams.cpp 中定义. 为了避免难度的极端波动，重新设定目标的调整必须小于每个周期4倍。如果所需的目标调整大于4倍，则调整为4倍而不是更多。任何进一步的调整都将在下一个重新设定目标期间完成，因为这种不平衡将持续到下一个2016个区块。因此，哈希算力和难度之间的巨大差异可能需要几个2,016区块周期来平衡。 挖掘比特币区块的难度大约需要整个网络“处理10分钟”，根据挖掘前2,016个区块所花费的时间，每2,016个区块进行一次调整。通过降低或提高目标来实现。 请注意，目标与交易的数量或价值无关。这意味着哈希的算力以及用于保障比特币安全锁消耗的电量也完全独立于交易数量。比特币可以扩大规模，实现更广泛的应用，并保持安全，而不需要增加目前的哈希算力水平。随着新矿工进入市场竞争奖励，哈希算力的增加代表市场的力量。只要足够的哈希算力在矿工诚实追求奖励的控制下进行，就足以防止“接管”攻击，因此足以保证比特币的安全。 挖矿的难度与电力成本相关，以及比特币与用于支付电力的货币的汇率。高性能的挖矿系统在当前硅片制造方面尽可能地高效，将电力尽可能高地转化为哈希算力。对挖矿市场的主要影响是1千瓦小时的比特币电价，因为这决定了挖矿的盈利能力，因此影响了进入或退出挖矿市场的选择。 成功挖到区块 如我们之前看到的，Jing的节点构建了一个候选区块，并准备挖掘它。Jing有几台硬件挖掘设备和特定于应用的集成电路，其中几十万个集成电路以惊人的速度并行运行SHA256算法。这些定制的机器通过USB或局域网连接到他的挖矿节点。接下来，在Jing的桌面上运行的挖矿节点将区块头发送到他的挖矿硬件，开始每秒尝试数万亿随机数。因为随机数只有32位，当遍历完所有可能时（大概40亿），挖矿硬件改变区块头（调整币基的随机数或时间戳）并重新测试随机数，和新的组合。 开始挖掘区块277,316后的大概11分钟，一个硬件社保发现了结果，并将其发送回挖矿节点。 当插入到区块头后，随机数 924,591,752 产生了以下区块哈希值： 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 小于目标值： 0000000000000003A30C00000000000000000000000000000000000000000000 Jing的挖矿节点立即将这个区块发送到它的对等节点。它们接收，验证，并传播这个新的区块。随着这个区块在网络上涟漪般传播，每个节点都将其添加到自己的区块链上，将区块链的高度扩展到 277,316 个区块。挖矿节点接收并验证区块，放弃自己尝试挖掘相同区块的努力，并立即开始计算链上的下一个区块，将Jing的区块作为“父块”。通过在Jing新发现的区块之上构建，其他的矿工实质上使用它们的算力“投票”，认可Jing的区块和它扩展的区块。 在下一节，我们将看下每个节点验证和选择最长链的过程，从而创建了形成去中心化区块链的共识。 验证新的区块 比特币共识机制的第三步是网络中每个节点对每个新块进行独立验证。随着新解决的块在整个网络中移动，每个节点在传播给对等节点之前执行一系列测试来验证它。这确保了只有有效的块在网络上传播。独立验证还可以确保那些诚实行动的矿工将自己的区块整合到区块链中，从而获得回报。那些不诚实行事的矿工被拒绝，不仅失去了奖励，而且浪费了寻找工作证明解决方案的努力，导致电力成本没有补偿。 当一个节点收到一个新的区块时，它将通过一长串检查清单验证它必须符合的条件；否则，拒绝该区块。这些条件可以在 Bitcoin Core 客户端的方法 CheckBlock 和 CheckBlockHeader 中看到： 区块的数据结构语法正确 区块头的哈希值小于目标值 区块的时间戳小于未来2小时（允许时间错误） 区块的大小在可接受的限制范围内 第一笔（且只有第一笔）交易是币基交易 区块中的所有交易是有效的，可以通过 独立交易验证 中的验证 网络上每个节点对每个新块的独立验证确保矿工不会作弊。在之前的章节中，我们看到矿工如何写出一笔交易，在该区块内创建新的比特币并获得交易费用。为什么矿工不会自己写一千个比特币的交易，而不是正确的奖励呢？因为每个节点都根据相同的规则验证块。无效的币基交易会使整个块无效，导致该块被拒绝，因此该交易永远不会成为分类账的一部分。矿工必须根据所有节点遵循的共同规则构建一个完美的区块，并通过正确的PoW解决方案来挖掘它。为此，他们在挖矿中耗费大量的电力，如果他们作弊，所有的电力和精力都被浪费掉了。这就是为什么独立验证是去中心化共识的一个关键组成部分。 组装和选择区块的链 区块链去中心化共识机制的最后一个步骤是将区块组装到链中，并选择最多Proof-of-Work的链。当一个节点验证了一个新的区块后，它将尝试通过将区块链接到现有的区块链，来组装链。 节点维护三组区块：连接到主区块链的区块，形成主区块链分支的（次级区块链），最后，在已知的链中没有父块的区块（孤块）。无效的区块一旦不满足验证条件即被拒绝，因此它们不包含在任何链中。 任何时候，“主链”都是无效链块中与其相关的最多累积工作量证明。在大多数情况下，这也是其中最多块的链条，除非有两条等长链和一条有更多的工作量证明。主链也将有分支，这些分支是与主链上的块“兄弟姐妹”。这些块是有效的，但不是主链的一部分。他们被保留以供将来参考，以防其中一个连锁店的业务延伸超过主链。在下一部分（ 区块链分叉 ）中，我们将看到由于在同一高度上几乎同时开采块体而出现次级链。 “主链”在任何时候都是有着最多的累计Proof-of-Work的区块组成的 有效 链。大多数情况下，这也是拥有最多区块的链，除非有两个高度相同的链，其中一个有更多的Proof-of-Work。主链会有分支，分支上的区块时主链上区块的“兄弟姐妹”。这些区块是有效的但不是主链的一部分。它们留作将来引用，以防这些链被扩展而超过主链。在下一节 区块链分叉 中，我们将看到相同高度的区块同时被挖掘而形成的次链。 当接收到一个新块时，节点将尝试将其插入到现有的区块链中。节点将查看块的“previous block hash”字段，该字段是对父块的引用。然后，节点将尝试在现有的区块链中找到父节点。大多数时候，父类将是主链的“顶部”，意味着这个新块扩展了主链。例如，新块277,316具有对其父块277,315的哈希值的引用。大多数接收277,316的节点都已经有了277,315块作为主链的顶部，因此将连接新的块并扩展该链。 有时，正如我们在 [fork] 中看到的，新的块扩展了非主链的链。在这种情况下，节点将把新区块附加到它所扩展的次级链上，然后将次级链的 工作量 与主链进行比较。如果次级链的累积工作量大于主链，则节点将在次级链上 重新聚合，意味着它将选择次级链作为其新的主链，使旧主链成为次级链。如果节点是一个矿工，那么它现在将构造一个块来扩展这个新的、更长的链。 如果一个有效的区块到达了，但没有在已有的链中找到其父块，则这个区块被认为是“孤儿”。孤块保存在孤块池中，直到父块到达。一旦父块到达并连接到已有的链上，孤块就会被取出，并连接到父块上，成为链的一部分。孤块通常在两个区块在一段很短的时间内被挖掘，但反序到达时发生（子块在父块之前到达）。 通过选择最大累积工作量的有效链，所有节点最终都能实现网络范围内的一致。随着工作量的增加，链之间的暂时差异最终得到解决，从而扩展可能链中的一条。挖矿节点通过挖掘下一个块来选择扩展哪个链，使用它们的挖矿能力“投票”。当他们挖掘一个新的块并扩展链时，新的块本身就代表了他们的选票。 在下一节中，我们将讨论竞争链(分叉)之间的差异是如何通过 最大累积工作量 的链的独立选择来解决的。 区块链分叉 因为区块链是一个去中心化的数据结构，所以它的不同副本并不总是一致的。块可能在不同的时间到达不同的节点，导致节点具有不同的区块链的视图。为了解决这个问题，每个节点总是选择并尝试扩展表示最大工作量证明的块的链，也称为最长链或最大累计工作量链。通过将记录在链中的每个块中的工作量相加，节点可以计算创建链所花费的总工作量。只要所有节点都选择最大累积工作量的链，全球比特币网络最终就会收敛到一致的状态。分叉作为区块链版本之间的临时不一致而出现，随着其中一个分叉添加更多块时，将最终重新聚合并解决。 > 本节中描述的区块链分叉由于全局网络中的传输延迟而自然发生。我们还将在本章后面讨论故意诱导的分叉。 下面的几张图，我们跟踪网络一个“分叉”事件。这些图是简化的比特币网络表示。为方便说明，不同的区块以不同的形状表示。网络中的每个节点表示为圆圈。 每个节点都有自己的全局区块链视角。每个节点从邻居节点接收区块，更新自己的区块链副本，选择最大累计工作量的链。为方便说明，每个节点包含一个代表当前主链的顶部的形状。所以，你在节点中看到的星形，表示它是主链的顶部。 在第一张图 Before the fork —— all nodes have the same perspective 中，网络对区块链有统一的视角，星形（star）区块代表主链的顶部。 Figure 2. Before the fork —— all nodes have the same perspective 当有两个候选区块争夺形成最长链时，发生“分叉”。这通常在两个矿工在相近的时间段内同时解决了Proof-of-Work算法。两个区块发现它们的候选区块的解决方案后，立即广播它们的“获胜的”区块给邻居节点，以使它们在网络上传播。每个收到有效区块的节点都将其整合进区块链，将其扩展一个区块。如果节点之后收到扩展相同父块的区块，则将其视为次级链上的候选区块。结果是，一些节点先看到第一个候选区块，另一些则先看到第二个，这就形成了区块链的两个竞争版本。 在 Visualization of a blockchain fork event: two blocks found simultaneously 中，我们看到两个矿工（ 节点X 和 节点Y ）几乎同时挖掘了两个不同的区块。这两个区块都是星形区块的子块，在其之上扩展区块链。为了便于我们追踪，节点X 产生的标记为三角形（triangle），节点Y产生的标记为倒三角（upside-down triangle）。 Figure 3. Visualization of a blockchain fork event: two blocks found simultaneously 例如，我们假设节点X为一个扩展区块链的块 “triangle” 找到了一个PoW解决方案，构建在父块 “star” 之上。几乎与此同时，同样从“star”扩展链的节点Y找到了块 “upside-down triangle” 的解决方案，这是它的候选块。两个块都是有效的，两个块都包含一个有效的工作证明解决方案，并且两个块都扩展了相同的父块(块“star”)。这两个块可能包含大部分相同的交易，交易的顺序可能只有很少的差异。 当两个块传播时，一些节点首先接收块到“triangle”，一些节点首先接收块“upside-down triangle”。如 Visualization of a blockchain fork event: two blocks propagate, splitting the network ，网络分割为区块链的两种不同视角：一边是 triangle，另一边是 upside-down triangle 。 Figure 4. Visualization of a blockchain fork event: two blocks propagate, splitting the network 在图中，一个随机选择的“节点X”首先接收到triangle块，并用它扩展star链。节点X选择有“triangle”块的链作为主链。之后，节点X也接收到“upside-down triangle”块。由于它是第二名，被认为已经“输掉”了比赛。然而，“upside-down triangle” 块并没有被丢弃。它与“star”块父链相连，形成一个次级链。虽然节点X假设它已经正确地选择了获胜链，但它保留了“失败的”链，这样它就有必要的信息，如果“失败的”链最终“获胜”，则需要重新聚合。 在网络的另一端，节点Y基于自己对事件序列的看法构建区块链。它首先接受了“upside-down triangle”，并选择了那个链条作为“赢家”。当它后来接收到 “triangle” 块时，它将它作为一个次级链连接到“star”父块。 哪一边都不是“正确的”，或者“错误的”。两个都是有效的区块链视角。之后只有一个会胜出，这取决于这两个相互竞争的链如何被后续的工作量扩展。 挖矿视角类似于节点X的节点将立即开始挖掘一个候选块，该块以“triangle”作为其顶端扩展链。通过将“triangle”链接为候选块的父元素，它们使用哈希算力投票。他们的投票支持了他们选出来的主链。 挖矿视角类似于节点Y的节点都将开始以“upside-down triangle”为父节点构建候选节点，扩展他们认为是主链的链。所以，比赛又开始了。 分叉几乎总是在一个块中解决。虽然网络哈希算力的一部分在“triangle”的顶部构建，而另一部分在“upside-down triangle”的顶部构建。即使哈希算力几乎是平均分配的，也很有可能在一组矿工找到任何解决方案之前，另一组矿工可能已经找到解决方案并传播它。例如，假设在 “triangle” 顶部建造的矿工找到了一个新的块“rhombus”（菱形），它扩展了链（例如，star-triangle-rhombus）。它们立即传播这个新块，整个网络将其视为有效的解决方案，如 Visualization of a blockchain fork event: a new block extends one fork, reconverging the network 所示。 所有在前一轮中选择“triangle”作为获胜者的节点，只需将链再延长一个block。然而，选择“upside-down triangle”作为获胜者的节点现在将看到两条链：star-triangle-rhombus 和 star-upside-down-triangle。star-triangle-rhombus 链现在比其他链长(累积工作量更多)。因此，这些节点将 star-triangle-rhombus 链作为主链，将 star-upside-down-triangle 链转化为二级链，如 Visualization of a blockchain fork event: the network reconverges on a new longest chain 所示。这是一个链的重新收敛，因为这些节点被迫修改他们对区块链的看法，以纳入更长的链的新证据。任何致力于将链基于 upside-down triangle 进行扩展的矿工现在都会停止工作，因为他们的候选块是一个“孤儿”，因为它的父块“upside-down triangle”不再是最长的链。不属于“triangle”的“upside-down triangle”内的交易被重新插入到mempool中，以便在下一个块中包含，从而成为主链的一部分。整个网络在一个区块链 star-triangle-rhombus 上重新收敛，“rhombus”是链中的最后一个块。所有的矿工立即开始在以 “rhombus” 作为父块的候选块上工作，以扩展 star-triangle-rhombus。 Figure 5. Visualization of a blockchain fork event: a new block extends one fork, reconverging the network Figure 6. Visualization of a blockchain fork event: the network reconverges on a new longest chain 理论上，如果矿工在前一个分叉的相对面上几乎同时发现了两个区块，那么这个分叉可能延伸到两个块。然而，发生这种情况的可能性很小。而一个块的fork可能每天都出现，而两个块的fork则最多每隔几周出现一次。 比特币区块的10分钟间隔是快速确认时间（交易结算）和分叉概率之间的设计折中。更快的区块时间会使交易清除更快，但会导致更频繁的区块链分叉，而较慢的区块时间会减少分叉数量，但会降低交易速度。 挖矿和哈希竞赛 Mining and the Hashing Race 比特币开采是一个极具竞争力的行业，比特币存在以来哈希算力每年都会成倍地增加。有些年份的增长反映了技术的完全变化，例如2010年和2011年，当时许多矿工从使用CPU采矿转向GPU和现场可编程门阵列（FPGA）。 2013年，通过将SHA256功能直接应用于专门用于采矿的硅芯片，ASIC采矿的引入带来了采矿能力的又一次巨大飞跃。首批这样的芯片可以提供比2010年整个比特币网络更多的采矿能力。 以下列表显示了比特币网络在前8年的运行总哈希算力： 2009 0.5 MH/sec–8 MH/sec (16× growth) 2010 8 MH/sec–116 GH/sec (14,500× growth) 2011 116 GH/sec–9 TH/sec (78× growth) 2012 9 TH/sec–23 TH/sec (2.5× growth) 2013 23 TH/sec–10 PH/sec (450× growth) 2014 10 PH/sec–300 PH/sec (30× growth) 2015 300 PH/sec-800 PH/sec (2.66× growth) 2016 800 PH/sec-2.5 EH/sec (3.12× growth) 在 Total hashing power, terahashes per second (TH/sec) 的图表中，我们可以看到比特币网络的哈希算力在过去两年中有所增加。如你所见，矿工之间的竞争和比特币的增长导致哈希算力（网络中每秒的总哈希计算数量）呈指数级增长。 Figure 7. Total hashing power, terahashes per second (TH/sec) 随着比特币挖矿的哈希算力大幅增加，难度也随之增加。在 Bitcoin’s mining difficulty metric 显示的图表中的难度以当前难度相对于最小难度（第一块的难度）的比率来衡量。 Figure 8. Bitcoin’s mining difficulty metric 在过去的两年中，ASIC采矿芯片变得越来越密集，接近硅片制造的极限，功能尺寸（分辨率）为16纳米（nm）。目前，ASIC制造商的目标是超越通用CPU芯片制造商，设计14纳米功能尺寸的芯片，因为挖矿的盈利能力比通用计算更快地推动这个行业的发展。比特币矿业没有更大的飞跃了，因为该行业已经达到摩尔定律的边缘，该定律指出计算密度大约每18个月翻一番。尽管如此，随着高密度芯片的竞赛与可以部署数千个芯片的高密度数据中心的竞赛相匹配，网络的挖掘能力仍然以指数级的速度增长。现在不再关心一块芯片可以挖多少矿，而是可以将多少芯片装入一个设备中，依然可以散热并提供足够的算力。 额外随机数解决方案 自2012年以来，比特币挖掘已经发展到解决块头结构的根本性限制。在比特币的早期，矿工可以通过遍历nonce来找到一个块，直到产生的散列值低于目标值。随着困难的增加，矿工经常循环遍历所有40亿个临时值，而没有发现块。但是，通过更新块时间戳以考虑已用时间，这很容易解决。由于时间戳是标题的一部分，所以更改将允许矿工重新遍历随机数的值，并获得不同的结果。但是，一旦采矿硬件超过 4GH/秒，这种方法变得越来越困难，因为nonce值在不到一秒钟内就被耗尽了。随着ASIC采矿设备开始推进并超过TH /秒哈希算力，挖掘软件需要更多的空间来存储nonce值，以便找到有效的块。时间戳可能会稍微延长，但将其变为将来的值会导致该块无效。块头中需要新的“更改”来源。解决方案是使用币基交易作为额外的随机值的来源。因为币基脚本可以存储2到100个字节的数据，所以矿工开始使用这个空间作为额外的nonce空间，允许他们探索更大范围的块标题值以找到有效的块。币基交易包含在merkle树中，这意味着币基脚本中的任何更改都会导致merkle根发生更改。八个字节的额外随机数加上4个字节的“标准”随机数允许矿工在不必修改时间戳的情况下总共探索 296（一个8，后接28个0）个可能性。如果将来，矿工可以运行所有这些可能性，他们可以修改时间戳。 币基脚本中还有更多空间用于将来扩展额外的随机数空间。 矿池 在这个竞争激烈的环境中，独自工作的矿工（也被称为独立矿工）没有机会。他们发现一个区块来抵消他们的电力和硬件成本的可能性非常低，所以它代表着赌博，就像玩彩票一样。即使是最快的ASIC采矿系统也无法跟上在水力发电附近的巨型仓库中堆叠数以万计这些芯片的商业系统。矿工们现在合作形成采矿池，汇集他们的算力，在数千名参与者中分享奖励。通过参与矿池，矿工获得的整体奖励份额较小，但通常每天都会得到奖励，从而减少不确定性。 我们来看一个具体的例子。假定矿工已经购买了具有 14,000千兆位/秒（GH/s）或 14TH/s 的哈希算力的采矿硬件。 2017年，这台设备的成本约为2,500美元。硬件在运行时耗电 1375瓦（1.3千瓦），每天耗电33千瓦时，电费非常低，每天花费1美元到2美元。在目前的比特币难度下，矿工大概每隔4年可以独自开矿1次。我们如何计算出这个概率？它基于 3EH/sec（2017年）的网络哈希算力和这个矿工的 14TH/sec 算力： P = (14 1012 / 3 1018) * 210240 = 0.98 …其中 21240 是每4年的区块数量。矿工每4年找到一个区块的概率为98%，基于当时的全球哈希算力。 如果矿工在该时间段内确实找到一个区块，则可获得12.5比特币（每比特币约1,000美元），一次性收入12,500美元，约7,000美元的净利润。但是，在4年内发现区块的概率取决于矿工的运气。他可能会在4年内找到两个区块并赚取巨额利润。或者他可能在5年内找不到一个区块并遭受更大的经济损失。更糟糕的是，在当前哈希算力增长率下，比特币工作量证明算法的难度可能会显着增加，这意味着矿工在硬件过时，必须被更强大的采矿硬件取代之前最多只有一年的时间。如果这位矿工参加矿池，而不是等待四年一度的12,500美元的暴利，他将能够每周赚取大约50美元至60美元。来自矿池的定期收入将帮助他分摊硬件和电力的成本，而不会承担巨大的风险。硬件在一两年后仍会过时，风险仍然很高，但在这段时间内收入至少是稳定可靠的。在经济上，这只有在非常低的电力成本（每千瓦小时不到1美分）和非常大的规模时才有意义。 矿池通过专门的矿池采矿协议协调成百上千的矿工。在创建了池中的帐户后，各个矿工将他们的采矿设备配置为连接到池服务器。他们的采矿硬件在采矿时仍与池服务器连接，与其他矿工同步工作。因此，矿池矿工共同努力挖掘一块，然后分享奖励。 成功的区块支付到矿池的比特币地址，而不是单独的矿工。池服务器将定期向矿工的比特币地址付款，当他们的奖励份额达到一定的阈值时。通常，池服务器为提供池采矿服务收取奖励的百分比的费用。 加入矿池的矿工将寻找候选区块解决方案的工作拆分，根据他们的挖矿贡献赢得“分成”。矿池为获得股份设定了更广的目标（较低的难度），通常比比特币网络的目标要容易1000倍以上。当矿池中的某人成功地开采了一个区块时，奖励将由矿池赚取，然后与所有参与努力的矿工按比例分成。 矿池开放给任何矿工，无论大小，专业或业余。因此，一个矿池将有一些参与者拥有一台小型采矿机，而其他人则拥有一个装满高端采矿硬件的车库。一些将采用几十千瓦的电力进行采矿，另一些将运行耗用兆瓦级电力的数据中心。矿池如何衡量个人的贡献，以公平分配奖励，而不会有作弊的可能性？答案是使用比特币的Proof-of-Work算法来衡量每个矿池矿工的贡献，但设置的难度较小，因此即使是最小的矿池矿工也能够频繁赢得一些份额，以便为矿池做出贡献。通过设定较低的赚取份额的难度，该池衡量每个矿工完成的工作量。每当一名矿池矿工发现一个区块头哈希值小于池目标时，她就证明她已完成散列工作找到了结果。更重要的是，寻求份额的工作以统计上可测量的方式贡献于总体努力，以找到比比特币网络的目标更低的哈希值。成千上万试图寻找小哈希值的矿工最终会找到一个足以满足比特币网络目标的矿工。 让我们回到骰子游戏的比喻。如果骰子玩家投掷骰子的目标是投掷出少于4（整体网络难度）的值，则游戏池将设定更容易的目标，计算游戏池玩家投掷结果小于8的次数。当选手掷出少于8（池目标）的值时，他们将获得份额，但是他们没有赢得比赛，因为他们没有达到比赛目标（少于4）。池玩家可以更频繁地获得更容易的池目标，即使他们没有实现赢得比赛的更难的目标，也可以非常经常地赢得他们的份额。无论何时，其中一名球员将掷出少于4的值，并且赢得比赛。然后，收入可以根据他们获得的份额分配给池玩家。尽管8或更少的目标没有获胜，但这是测量玩家掷骰子的公平方法，偶尔会产生少于4的投掷。 类似地，矿池将设置（更高和更容易）的池目标，以确保个体池矿工能够找到经常低于池目标的区块头哈希值，从而获得份额。每隔一段时间，这些尝试中的一个会产生一个比比特币网络目标小的区块头哈希值，使其成为一个有效的块，并且整个池都会赢。 管理型矿池 大多数矿池都是“被管理”的，这意味着有一个公司或个人运行池服务器。池服务器的所有者称为 矿池运营者 pool operator ，他向池中矿工收取收入的一定比例费用。 池服务器运行专门的软件和池采矿协议来协调池内矿工的活动。池服务器还连接到一个或多个完整的比特币节点，并可直接访问区块链数据库的完整副本。这允许池服务器代表池矿工验证块和交易，从而减轻他们运行完整节点的负担。对于池矿工而言，这是一个重要的考虑因素，因为完整节点需要具有至少100至150 GB持久性存储（磁盘）和至少2至4GB内存（RAM）的专用计算机。此外，运行在完整节点上的比特币软件需要经常进行监控，维护和升级。由于缺乏维护或缺乏资源而导致的任何停机都会损害矿工的盈利能力。对于许多矿工而言，可以在不运行完整节点的情况下进行挖掘是加入托管池的另一大好处。 池矿工使用采矿协议（如Stratum（STM）或GetBlockTemplate（GBT））连接到池服务器。自2012年年底以来，名为GetWork（GWK）的较旧标准大多已经过时，因为它不能轻易支持以 4GH/s 以上的散列速率进行挖掘。STM和GBT协议都创建了包含候选区块头模板的区块 模板。池服务器通过聚合交易构建候选块，添加币基交易（带有额外的nonce空间），计算merkle根，并链接到前一个块的哈希值。然后将候选区块的头作为模板发送给每个泳池矿工。然后每个矿池矿工使用区块模板进行开采，目标比比特币网络的目标更广，并将任何成功的结果发送回池服务器以赚取份额。 对等矿池 (P2Pool) 被管理的池可能会导致池运营者作弊，他可能会指使矿池努力进行双重支付交易或使区块无效（请参阅 共识攻击 ）。此外，集中池服务器代表单点故障。如果池服务器关闭或由于拒绝服务攻击而放慢速度，池中的矿工将无法开采。 2011年，为解决这些集中化问题，提出并实施了一种新的池式挖掘方法：P2Pool，一个没有中央运营商的对等矿池。 P2Pool通过分散池服务器的功能工作，实现了称为 股份链 share_chain 的并行的类似区块链的系统。股份链是比比特币区块链难度更低的区块链。股份链允许矿池矿工通过以每30秒一个块的速度挖掘链上的份额，在去中心化的池中进行合作。股份链上的每个区块都会为参与工作的池矿工记录相应的股份回报，并将股份从前一个股份块中向前移动。当其中一个股份区块也实现比特币网络目标时，它会被传播并包含在比特币区块链中，奖励所有为获胜股份区块之前的所有股份作出贡献的矿池矿工。本质上，与池服务器跟踪池矿工的股份和奖励不同，股份链允许所有池矿工使用类似比特币的区块链共识机制的去中心化共识机制来跟踪所有股份。 P2Pool挖掘比池挖掘更复杂，因为它要求池矿工运行具有足够磁盘空间，内存和互联网带宽的专用计算机，以支持完整的比特币节点和P2Pool节点软件。 P2Pool矿工将他们的采矿硬件连接到他们的本地P2Pool节点，该节点通过向采矿硬件发送区块来模拟池服务器的功能。在P2Pool上，个人池矿工构建他们自己的候选区块，像独立矿工一样聚集交易，然后在股份链上进行协作。 P2Pool是一种混合型方法，与单独挖矿相比，具有更精细的支出优势，也不会像管理型矿池那样给池操作员太多控制权。 尽管P2Pool降低了矿池运营商的权力集中度，但可以想象，股份链本身有51％攻击的可能性。 P2Pool的广泛采用并不能解决比特币本身的51％攻击问题。相反，P2Pool使比特币整体更加强大，作为多元化挖矿生态系统的一部分。 共识攻击 至少从理论上讲，比特币的共识机制很容易受到矿工(或矿池)的攻击，因为他们试图利用他们的“哈希”算力，来实施不诚实或破坏性的目的。如我们所看到的，共识机制取决于大多数矿工出于自身利益诚实行事。然而，如果一名矿工或一群矿工能够获得相当大的哈希算力份额，他们就可以攻击共识机制，从而破坏比特币网络的安全性和可用性。 重要的是要注意到，共识攻击只能影响未来的共识，或者至多影响最近的过去(几十个块)。随着时间的流逝，比特币的账本变得越来越不可改变。虽然在理论上，分叉可以在任何深度上实现，但在实践中，强制执行一个非常深的分叉所需的计算能力是巨大的，这使得旧的块实际上是不可变的。共识攻击也不影响私钥和签名算法(ECDSA)的安全性。共识攻击不能窃取比特币，不能在没有签名的情况下使用比特币，不能改变比特币的方向，也不能改变过去的交易或所有权记录。共识攻击只能影响最近的块，并在创建未来块时导致拒绝服务中断。 针对共识机制的攻击场景称为“51%攻击”。在这种情况下，一群控制着整个网络的哈希算力(51%)的矿工勾结起来攻击比特币。有了挖掘大部分块的能力，攻击的挖矿人员可以在区块链和双重支付交易中引起有意的“分叉”，或者对特定的交易或地址执行拒绝服务攻击。fork/double-spend攻击是指攻击者通过在其下方分叉并在另一个链上重新聚合而导致先前确认的块无效的攻击。有了足够的能力，攻击者可以使一行中的六个或多个块失效，从而导致被认为不可变的交易(六个确认)失效。注意，双重支付只能在攻击者自己的交易上执行，攻击者可以为此生成有效的签名。如果通过使交易无效，攻击者可以获得不可逆的兑换付款或产品，而无需为此付费，那么重复使用自己的交易就是有利可图的。 让我们来看一个51%攻击的实际例子。在第一章中，我们看了Alice和Bob之间的一笔交易，即一杯咖啡。咖啡馆老板Bob愿意接受咖啡的付款，而不需要等待确认(在一个区块内开采)，因为与快速客户服务的便利性相比，两次消费一杯咖啡的风险较低。这类似于咖啡店的做法，即接受低于25美元的信用卡支付而无需签名，因为信用卡退款的风险较低，而延迟交易获得签名的成本相对较大。相比之下，以比特币卖出一件更昂贵的商品，就会有双重支付攻击的风险，即买家广播一项相互竞争的交易，该交易使用相同的输入(UTXO)，并取消支付给商家的款项。双重支付攻击可以以两种方式发生：要么在确认交易之前，要么在攻击者利用区块链fork撤消多个块之前。51%攻击允许攻击者在新链中重复使用自己的交易，从而取消旧链中的相应交易。 在我们的例子中，恶意攻击者Mallory来到Carol的画廊，购买了一幅美丽的三联画，将中本聪描绘为普罗米修斯。Carol以25万美元的价格将《The Great Fire》的画作卖给了Mallory。Carol没有在交易中等待6个或更多的确认，而是在只有一次确认后将画作交给了Mallory。Mallory与一个共犯Paul一起工作，Paul经营着一个大的矿池。一旦Mallory的交易被包含在一个区块内，共犯就会发起51%攻击。Paul指导矿池重新挖掘与包含Mallory交易的块高度相同的块，将Mallory对Carol的付款替换为使用相同输入的双重支付交易。这种双重支付交易消耗了相同的UTXO，并将其归还给Mallory的钱包，而不是支付给Carol，实质上是让Mallory保留比特币。然后，Paul引导矿池挖掘一个额外的块，从而使包含双重支付交易的链比原来的链长(在包含Mallory交易的块下产生一个fork)。当区块链分叉被解决为支持新的(更长的)链时，重复使用的交易将替换为Carol的原始付款。Carol现在丢失了画作，也没有收到比特币付款。在所有这些活动中，Paul的矿池参与者可能不知道重复支付的尝试，因为他们使用自动的矿工进行挖掘，不能监视每个交易或区块。 为了防止这种攻击，出售大价值商品的商人必须至少等待6次确认才能将产品交给买方。或者，商户应该使用托管多签名帐户，在托管帐户得到资金后再等待几个确认。确认越长，就越难以执行51%攻击使交易无效。对于高价值的物品，即使买家需要等待24小时才能交货，用比特币付款仍然是方便和有效的，这相当于大约144个确认。 除了双重支付攻击之外，共识攻击的另一个场景是拒绝向特定的比特币参与者(具体的比特币地址)提供服务。拥有大部分挖矿能力的攻击者可以简单地忽略特定的交易。如果它们包含在由另一个矿机挖掘的块中，攻击者可以故意对该块进行fork和重新挖掘，再次排除特定的交易。这种类型的攻击可以导致对特定地址或地址集的持续拒绝服务，只要攻击者控制了大部分挖掘能力即可。 尽管名字为51%攻击，实际上并不需要51%的哈希算力。事实上，这样的攻击可以尝试使用较小比例的哈希算力。51%仅仅是这种攻击几乎可以保证成功的水平。达成共识的攻击本质上是挖掘下一个区块的集团间的拔河，“更强大”的集团更有可能获胜。使用较少的哈希算力，成功的可能性就会降低，因为其他矿工用他们“诚实”的采矿力量控制某些区块的生成。可以这样看，攻击者的哈希算力越强，他故意创建的分叉越长，他在最近的一段时间内可以使更多的块失效，或者在未来可以控制更多的块。安全研究小组使用统计建模来宣称，只要30%的哈希算力，各种类型的共识攻击都是可能的。 可以说，比特币的哈希算力大幅增加，使得它不会受到任何一个矿工的攻击。对于一个单独的矿工来说，不可能控制超过总开采能力的一小部分。然而，由矿池引起的集中控制带来了矿池运营商进行盈利性攻击的风险。托管池中的池运营商控制候选块的构造，并控制包含哪些交易。这使池运营商能够排除交易或引入双重支付交易。如果这种滥用权力的行为是以一种有限而微妙的方式进行的，那么池运营商可以在不被注意的情况下从共识攻击中获利。 然而，并非所有的攻击者都是受利润驱动的。一个潜在的攻击场景是，攻击者打算破坏比特币网络，而不可能从这种破坏中获利。破坏比特币的恶意攻击将需要巨额投资和秘密计划，可以想象，攻击者可能是资金充裕、最有可能是政府支持的攻击者。另外，资金充裕的攻击者可以通过同时收集挖掘硬件、勾结池运营商、以及拒绝服务攻击其他池来攻击比特币的共识。所有这些设想在理论上都是可能的，但随着比特币网络的总体哈希能力继续呈指数级增长，它们越来越不切实际。 毫无疑问，一场严重的共识攻击将在短期内削弱人们对比特币的信心，可能导致比特币价格大幅下跌。然而，比特币网络和软件一直在不断发展，因此，比特币社区会立即应对舆论攻击，使比特币更加稳健。 共识规则的改变 共识规则决定了交易和区块的有效性。这些规则是所有比特币节点之间协作的基础，并负责将所有本地视图汇聚到整个网络的一个一致的区块链中。 虽然共识规则在短期内是不变的，并且必须在所有节点之间保持一致，但是从长期来看，它们并不是不变的。为了进化和发展比特币系统，规则必须不时变化，以适应新的特性、改进或bug修复。然而，与传统的软件开发不同，对共识系统的升级要困难得多，需要所有参与者之间的协调。 硬分叉 在 [fork] 中，我们研究了比特币网络可能会有短暂的分歧，在短时间内，在区块链的两个不同分支的网络中有两个部分。我们看到这个过程是如何自然地发生的，作为网络正常运行的一部分，以及在挖掘一个或多个块之后，网络如何在公共区块链上重新收敛。 在另一种情况下，网络可能会分化成以下两个链：共识规则的改变。这种类型的分叉称为 硬分叉 hard fork，因为在分叉之后，网络不会重新聚合到单个链上。相反，这两条链是独立进化的。当网络的一部分在一组不同于网络其他部分的共识规则下运行时，就会出现硬分叉。这可能是由于错误或共识规则执行过程中故意更改而导致的。 硬分叉可以用来改变共识规则，但是它们需要系统中所有参与者之间的协作。任何不升级到新的共识规则的节点都不能参与共识机制，并在硬分叉时被迫进入一个单独的链。因此，硬分叉引入的更改可以被认为是“向前兼容”的，因为在非升级的系统中不能再处理新的共识规则。 让我们通过一个例子来查看硬分叉的结构。 [blockchainwithfork] 展示了区块链和两个分叉，在块高度为4的地方，出现一个单块分叉。这是我们在 [fork] 中看到的自发性分叉类型。在第5块的挖掘中，网络在一个链上重新聚合，分叉被解决。 Figure 9. A blockchain with forks 然而，稍后，在块高6处，出现硬分叉。让我们假设客户端的新实现随共识规则的更改而释放。从块高度7开始，运行这个新实现的矿工将接受一种新的数字签名类型，我们称之为“Smores”签名，它不是基于ECDSA的。紧接着，运行新实现的节点将创建一个包含Smores签名的交易，并运行最新软件的矿工，挖掘包含该交易的区块7b。 任何没有升级软件以验证Smores签名的节点或矿工现在都无法处理第7b块。从他们的角度来看，包含Smores签名的交易和包含该交易的block 7b都是无效的，因为它们是基于旧的共识规则进行评估的。这些节点将拒绝交易和块，不会传播它们。任何使用旧规则的挖掘人员都不会接受第7b块，并将继续挖掘父块为第6块的候选块。事实上，如果使用旧规则的矿工连接到的所有节点都遵守旧规则，因此不传播该块，那么他们甚至可能不会接收到block 7b。最终，他们将能够挖掘第7a块，该块在旧规则下是有效的，不包含任何带有Smores签名的交易。 这两条链从这一点开始继续偏离。“b”链上的矿工将继续接受和挖掘包含Smores签名的交易，而“a”链上的矿工将继续忽略这些交易。即使block 8b不包含任何经过Smores签名的交易，“a”链上的矿工也不能处理它。对他们来说，它似乎是一个孤立的块，因为它的父“7b”不被认为是一个有效的块。 硬分叉：软件，网络，挖矿，和链 对于软件开发人员来说，“fork” 这个词还有另外一个含义，给 “hard fork” 这个词增加了混淆。在开放源码软件中，当一组开发人员选择遵循不同的软件路线图并启动一个开放源码项目的竞争性实现时，就会出现一个fork。我们已经讨论了导致硬分叉的两种情况:共识规则中的错误和共识规则的故意修改。在故意改变共识规则的情况下，软分叉优先于硬分叉。然而，对于这种类型的硬分叉，必须开发、采用和启动共识规则的新软件实现。 试图改变共识规则的软件分叉的例子包括Bitcoin XT、Bitcoin Classic，以及最近的Bitcoin Unlimited。然而，这些软件的分叉都没有带来一个硬的叉。虽然软件fork是一个必要的先决条件，但它本身并不足以出现硬fork。要实现一个硬的fork，必须采用竞争的实现，以及由矿商、钱包和中间节点激活的新规则。相反，有许多Bitcoin Core的替代实现，甚至是软件分支，它们不会改变共识规则，也不会排除bug，它们可以在网络上共存并互操作，而不会造成硬分叉。 共识规则在交易或块的验证中可能以明显和明确的方式存在差异。这些规则还可能在更微妙的方面有所不同，比如在适用于比特币脚本或数字签名等密码基元的共识规则的实现上。最后，由于系统限制或实现细节所造成的隐式共识约束，共识规则可能会因未预期的方式而有所不同。在将比特币核心0.7升级到0.8的过程中，在意料之外的硬分叉中可以看到后者的一个例子，这是由于用于存储块的Berkley DB实现的限制造成的。 从概念上讲，我们可以把硬分叉看作是分四个阶段发展的：软件分叉、网络分叉、挖矿分叉和链分叉。 当开发人员创建修改了共识规则的客户端替代实现时，流程就开始了。 当这个分叉实现部署到网络中时，一定比例的矿工、钱包用户和中间节点可以采用并运行这个实现。产生的分叉将取决于新的共识规则是否适用于块、交易或系统的其他方面。如果新的共识规则与交易相关，那么在新规则下创建交易的钱包可能会生成一个网络分叉，然后当交易被挖掘到一个块时，会出现一个硬分叉。如果新规则涉及到块，那么当在新规则下挖掘块时，硬分叉过程将开始。 首先，网络将会分叉。基于共识规则的原始实现的节点将拒绝在新规则下创建的任何交易和块。此外，遵循原始共识规则的节点将临时禁止并断开与发送这些无效交易和块的任何节点的连接。因此，网络将被划分为两个部分：旧节点只会继续连接旧节点，新节点只会连接到新节点。基于新规则的单个交易或块将在网络中产生连锁反应，并导致分成两个网络。 一旦一名矿工使用新规则开采一个区块，开采算力和链也将分叉。新矿工将在新区块的顶部采矿，而老矿工将在旧规则的基础上开采一个单独的链条。分割后的网络将使在独立的共识规则下操作的矿工不可能接收到彼此的区块，因为他们连接到两个独立的网络。 分叉的矿工和难度 当矿工们分别开采两个不同的链条时，它们的哈希算力就会被分割开来。在这两个链之间，可以按任何比例分割采矿算力。新规则可能只会被少数人遵守，或者被绝大多数算力的矿工遵守。 例如，我们假设 80% —— 20% 分割，大多数挖矿算力使用新的共识规则。假设分叉在重新设定目标的阶段后立即开始。 这两个链将从重新设定目标阶段继承难度。新的共识规则将有80%的先前的算力委托给他们。从这条链的角度来看，与前一时期相比，挖矿算力突然下降了20%。平均每12.5分钟就会发现一些区块，这代表了延伸这条链的挖矿算力下降了20%。这种区块发行速度将持续下去（除非哈希功率发生变化），直到2016年区块被开采，这将需要大约25,200分钟（每区块12.5分钟），或17.5天。17.5天后，重新设定目标，难度调整（减少20%），基于该链中哈希算力的减少，再次生成10分钟的块。 在旧规则下，只有20%的哈希算力，将面临更加困难的任务。在这条链条上，现在平均每50分钟开采一块。接下来2016块矿的难度将不会调整，这将需要100,800分钟，或者大约10周。假设每个块有固定的容量，这也将导致交易容量减少5倍，因为每小时记录交易的块更少。 有争议的硬分叉 这是共识软件开发的曙光。正如开源开发改变了软件的方法和产品，并随之创造了新的方法、新的工具和新的社区，共识软件开发也代表了计算机科学的一个新的前沿。从比特币发展路线图的辩论、实验和磨难中，我们将看到新的开发工具、实践、方法和社区出现。 硬分叉被认为是有风险的，因为它们迫使少数人要么升级，要么留在少数人的链条上。许多人认为，将整个系统分割成两个相互竞争的系统的风险是不可接受的。因此，许多开发人员不愿意使用硬分叉机制来实现对共识规则的升级，除非整个网络几乎一致支持。任何没有得到一致支持的硬分叉提议都被认为太“有争议”，不可能在不危及系统分割的情况下尝试。 硬分叉的问题在比特币开发界引起了极大的争议，尤其是当它涉及对控制最大块大小限制的共识规则的任何拟议更改时。一些开发人员反对任何形式的硬分叉，认为这样做风险太大。另一些人认为，硬分叉机制是升级共识规则的重要工具，以避免“技术债务”，并与过去彻底决裂。最后，一些开发人员认为硬分叉是一种应该很少使用的机制，需要进行大量的预先规划，而且只有在达成几乎一致的意见下才能使用。 我们已经看到了解决“硬分叉”风险的新方法的出现。在下一节中，我们将讨论软分叉，以及BIP-34和BIP-9方法，用于通知和激活共识的修改。 软分叉 并非所有共识规则的改变都会导致硬分叉。只有共识的变更是向前不兼容的，才会产生一个分叉。如果更改的实现方式使得未修改的客户端仍然认为交易或块在以前的规则下是有效的，那么更改可以在没有分叉的情况下发生。 引入soft fork这一术语，将这种升级方法与“硬分叉”区分开来。实际上，软分叉根本不是分叉。软分是对共识规则的向前兼容更改，允许未升级的客户端继续与新规则一致地运行。 软分叉的一个方面并不明显，即软分叉升级只能用于约束共识，而不能扩展它们。为了向前兼容，在新规则下创建的交易和块也必须在旧规则下有效，反之亦然。新规则只能限制什么是有效的；否则，在旧规则下被拒绝时，它们将触发硬分叉。 软分叉可以通过多种方式实现 —— 这个术语不指定特定的方法，而是一组方法，它们都有一个共同点：不需要所有节点进行升级，也不需要强制不升级的节点退出共识。 软分叉重定义的 NOP 操作码 基于对NOP操作码的重新解释，比特币已经实现了许多软分叉。比特币脚本中有10个操作码，从NOP1到NOP10。根据共识规则，在脚本中存在这些操作码被解释为无效的操作符，这意味着它们没有效果。执行在NOP操作码之后继续，就好像它不在那里一样。 因此，软fork可以修改NOP代码的语义，从而赋予它新的含义。例如，BIP-65 ( CHECKLOCKTIMEVERIFY ) 重新解释了NOP2操作码。实现BIP-65的客户端将NOP2解释为 OP_CHECKLOCKTIMEVERIFY，并对UTXO强加一个绝对锁时间共识规则，在他们的锁定脚本中包含这个操作码。这种更改是一个软分叉，因为在BIP-65下有效的交易对于任何不实现(不知道)BIP-65的客户端也是有效的。对于旧的客户端，该脚本包含一个NOP代码，该代码将被忽略。 软分叉升级的其他方法 对NOP操作码的重新解释是有计划的，也是共识升级的明显机制。然而，最近又引入了另一种软分叉机制，它不依赖于NOP操作码进行非常特定的共识更改。这在 [segwit] 中有更详细的讨论。Segwit是对交易结构的架构更改，它将解锁脚本（见证）从交易内部移动到外部数据结构（隔离它）。Segwit最初被设想为硬分叉升级，因为它修改了基本结构（交易）。2015年11月，一位致力于Bitcoin Core的开发人员提出了一种机制，可以将segwit作为一种软分叉引入。用于此的机制是对在segwit规则下创建的UTXO的锁定脚本的修改，这样未修改的客户端就可以通过任何解锁脚本赎回锁定脚本。因此，可以引入segwit，而不需要每个节点升级或从链上拆分：这是一个软分叉。 很有可能还有其他的，但有待发现的机制，通过这些机制，升级可以以一种向前兼容的方式作为软分叉。 针对软分叉的批评 基于NOP操作码的软分叉相对来说是没有争议的。NOP操作码放在比特币脚本中，明确的目标是允许非破坏性升级。 然而，许多开发人员担心其他的软分叉升级方法会导致不可接受的折衷。对软分叉变化的常见批评包括： 技术债务 Technical debt 因为软分叉比硬分叉升级更复杂，他们引入了 technical debt ，这个术语指的是由于过去的设计权衡而增加了未来的代码维护成本。代码的复杂性反过来又增加了错误和安全漏洞的可能性。 验证放松 Validation relaxation 未修改的客户端认为交易是有效的，而不评估修改后的共识规则。实际上，未修改的客户端不使用所有共识规则进行验证，因为它们对新规则视而不见。这适用于基于NOP的升级，以及其他软分叉升级。 不可逆的更新 Irreversible upgrades 因为软分叉创建具有附加共识约束的交易，它们在实践中成为不可逆转的升级。如果一个软分叉升级在激活后被撤销，根据新规则创建的任何交易都可能导致旧规则下的资金损失。例如，如果CLTV交易是在旧规则下计算的，则没有timelock约束，可以在任何时候使用它。因此，批评人士认为，由于错误而不得不取消的失败软分叉几乎肯定会导致资金损失。 使用区块版本的软分叉信号 由于软分叉允许未修改的客户端继续在共识范围内运行，因此“激活”软分叉的机制是通过矿工发出准备就绪的信号：大多数矿商必须同意他们已经准备好并愿意执行新的共识规则。为了协调他们的行动，有一个信号机制允许他们表示对共识规则变更的支持。该机制于2013年3月引入BIP-34激活，2016年7月被BIP-9激活取代。 BIP-34 信号和激活 在BIP-34中，第一个使用了区块版本号字段的实现，允许矿工发出信号，表示已经准备好进行特定的共识规则更改。在BIP-34之前，区块版本号根据约定设置为“1”，不以共识执行。 BIP-34定义了一个共识规则变更，要求币基交易的coinbase字段（输入）包含块高度。在BIP-34之前，这个字段可以包含任意数据。激活BIP-34之后，有效的块必须在coinbase的起始处包含特定的块高度，并用大于或等于“2”的版本号进行标识。 为了表明BIP-34的变化和激活，矿工将块版本设置为“2”而不是“1”。这并没有立即使版本“1”块无效。一旦激活，版本“1”块将变得无效，并且所有版本“2”块将被要求在coinbase字段中包含块高度才有效。 BIP-34基于1000区块的滚动窗口定义了两步激活的机制。矿工将通过构建具有“2”作为版本号的块来表示他或她对BIP-34的个人准备状态。严格地说，这些区块并不需要遵守在币基交易中包含区块高度的新共识规则，因为共识规则尚未激活。共识规则分两步启动： 如果75％（最近1000个区块中的750个）标有版本“2”，则版本“2”区块必须在币基交易中包含区块高度，否则它们将被视为无效。版本“1”块仍然被网络接受，并且不需要包含块高度。新旧共识规则在此期间共存。 当95％（最近1000个块中的950个）为版本“2”时，版本“1”块不再被视为有效。版本“2”块只有在币基中包含块高时（按照之前的阈值）才有效。此后，所有块必须符合新的共识规则，并且所有有效块必须包含在币基交易中的块高度。 在BIP-34规则下成功发送信号和激活后，该机制被再次使用两次以激活软分叉： BIP-66 严格的签名DER编码通过BIP-34类型的发信号以块版本“3”激活并且使版本“2”的区块无效。 BIP-65 CHECKLOCKTIMEVERIFY +被BIP-34风格的信号激活，区块版本为“4”，并使版本“3”的区块失效。 在激活BIP-65后，BIP-34的信号传导和激活机制退役并被接下来描述的BIP-9信号传导机制取代。 标准定义在 BIP-34 (Block v2, Height in Coinbase) 中。 BIP-9 信号和激活 BIP-34，BIP-66和BIP-65使用的机制成功地激活了三个软分叉。但是，它被替换了，因为它有几个限制： 通过使用块版本的整数值，一次只能激活一个软分叉，因此需要软分叉建议之间的协调，并就其优先级和排序达成一致。 此外，由于块版本增加，该机制没有提供直接的方式来拒绝更改，然后提出不同的更改。如果老客户端仍在运行，他们可能会错误地将信号发送给新的更改，作为先前拒绝的更改的信号。 每次新的更改不可避免地减少了未来更改的可用块版本。 BIP-9 被提出以克服这些挑战，提高实施未来变革的速度和容易度。 BIP-9 将块版本解释为位域而不是整数。由于块版本最初被用作整数使用，版本号1至4，因此有29位可用的位，可用于独立同时发出29个不同提案的准备就绪信号。 BIP-9 还设置信号和激活的最长时间。这样，矿工不需要永远发出信号。如果提案在 TIMEOUT 期限内（在提案中定义）未激活，则提议被视为被拒。该建议可能会重新提交以用不同的位进行信号传输，从而更新激活期。 此外，在超过 TIMEOUT 并且某个功能被激活或拒绝之后，信号位可以被重新用于其他功能而不会造成混淆。因此，多达29个变化可以并行发送，TIMEOUT 之后可以“循环”以提出新的更改。 > 虽然信号位可以重复使用或循环使用，但只要投票期不重叠，BIP-9的作者建议只有在必要时才能重新使用位；由于旧软件中的错误而可能发生意外行为。总之，我们不应该期望看到重用，直到所有29位被使用过一次。 建议的更改由包含以下字段的数据结构标识： name 用于区分提案的简短说明。大多数情况下，描述该建议的BIP为“bipN”，其中N是BIP编号。 bit 0 到 28, 矿工用来表示批准该提案的区块版本中的位。 starttime 信号开始的时间（基于过去中值时间，MTP），在此之后，该位的值被解释为该提议的信号准备就绪。 endtime 如果更改未达到激活阈值，则认为拒绝的时间点（基于MTP）。 与BIP-34不同，BIP-9基于2016个区块的难度重新设定目标阶段计算整个区间的激活信号。对于每个重新定位周期，如果支持提案的信号的块的总数超过95％（2016块中1916块），则该提议将在下一个重新设定目标阶段内激活。 BIP-9 提供了一个提案状态图，以说明提案的各个阶段和状态转换，如 BIP-9 state transition diagram 中所示。 一旦参数在比特币软件中已知（定义），提案就以 DEFINED 状态开始。对于MTP在开始时间之后的块，提案状态将转换为 STARTED。如果在重新设定目标周期内超过投票阈值并且没有超时，则提案状态转换为 LOCKED_IN。一个重新设定目标周期后，提案变为 ACTIVE 。一旦它们达到该状态，建议一直保持 ACTIVE 状态。如果在达到投票阈值之前超时，提案状态更改为 FAILED，表示被拒绝的提案。 FAILED 提案永远处于该状态。 Figure 10. BIP-9 state transition diagram BIP-9 首先用于激活 CHECKSEQUENCEVERIFY 和相关的 BIP（68,112,113）。名为“csv”的提案已于2016年7月成功启用。 标准定义在 BIP-9 (Version bits with timeout and delay) 中. 共识软件开发 共识软件不断发展，关于改变共识规则的各种机制的讨论很多。就其本质而言，比特币在协调和共识变化方面设置了非常高的标准。作为一个分散的系统，它没有“权威”，可以将其意志强加给网络的参与者。权力分散在矿工，核心开发人员，钱包开发人员，交易所，商户和最终用户等多个选区之间。任何这些选区都不能单方面做出决定。例如，尽管矿工理论上可以通过简单的大多数（51％）改变规则，但他们受到其他选区同意的限制。如果他们单方面行事，其他参与者可能会拒绝跟随他们，从而使经济活动停留在少数链中。如果没有经济活动（交易，商人，钱包，交易所），矿工们将会挖到毫无价值的硬币。权力的分散意味着所有的参与者必须协调，否则就不能做出改变。现状是这个系统的稳定状态，如果大多数人达成共识，则系统处于只有很少变化的稳定状态。软分叉的95％阈值反映了这一现实。 认识到共识的发展没有完美的解决方案是很重要的。硬分叉和软分叉都涉及权衡。对于某些类型的变化，软分叉可能是更好的选择；对于其他人来说，硬分叉可能是更好的选择。没有完美的选择；都有风险。共识软件开发的一个不变特征是变革难度大，共识强制妥协。 一些人认为这是共识体系的弱点。随着时间的推移，你可能会像我一样，认为它是这个系统最强大的力量。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 15:45:03 "},"13第十一章.html":{"url":"13第十一章.html","title":"比特币的安全","keywords":"","body":"比特币的安全 确保比特币安全具有挑战性，因为比特币不是抽象的价值参考，就像银行账户的余额。比特币非常像数字现金或黄金。你可能听到过这样的表达：“占有是法律的十分之九”。那么，在比特币中，占有是法律的十分之一。拥有解锁比特币的密钥相当于拥有现金或贵重金属。你可能会失去它，放错位置，被盗，或者不小心把错误的数字给别人。在每一种情况下，用户都没有追索权，就好像他们在公共人行道上放弃了现金一样。 但是，比特币具有现金，黄金和银行账户不具备的能力。包含您的密钥的比特币钱包可以像任何文件一样备份。它可以存储在多个副本中，甚至可以打印在纸张上进行硬拷贝备份。您不能“备份”现金，黄金或银行账户。比特币与之前的任何东西都不相同，我们需要以一种新颖的方式来思考比特币安全。 安全原则 比特币的核心原则是去中心化，它对安全性有重要影响。传统的银行或支付网络等集中模式依赖于访问控制和审查，以防止不良行为者。相比之下，像比特币这样的分散系统将责任和控制交给了用户。由于网络的安全性基于工作量证明，而不是访问控制，因此网络可以公开，并且比特币流量不需要加密。 在诸如信用卡系统的传统支付网络中，支付是开放式的，因为它包含用户的私人标识符（信用卡号码）。在初始收费后，任何可以使用该标识符的人都可以“拉取”资金并一次又一次地向拥有者收费。因此，支付网络必须通过加密进行端对端的安全保护，必须确保没有窃听者或中间人可以危害付款流量，包括传输中或存储时（静止时）。如果一个不良行为者获得了访问系统的权限，他可以危害当前的交易，以及 可用于创建新交易的支付令牌。更糟糕的是，当客户数据遭到破坏时，客户面临身份盗用的风险，必须采取措施防止被盗账户的欺诈性使用。 比特币有很大的不同。比特币交易仅向特定收件人授予特定的价值，不能伪造或修改。它不会透露任何隐私信息，例如当事人的身份，也不能用于授权额外付款。因此，比特币支付网络不需要加密或防止窃听。事实上，您可以通过开放的公共频道（例如不安全的WiFi或蓝牙）来广播比特币交易，同时不会降低安全性。 比特币的去中心化安全模式将大量权力交给用户。有了这个权力就有责任对密钥进行保密。对于大多数用户来说，这并不容易，特别是在通用计算设备上，例如连接互联网的智能手机或笔记本电脑。虽然比特币的去中心化模式可以防止向信用卡那样出现大规模危机，但许多用户无法充分保护他们的密钥，并一个接一个地被黑客入侵。 安全地开发比特币系统 比特币开发者最重要的原则是去中心化。大多数开发人员都熟悉集中式安全模型，并可能试图将这些模型应用到他们的比特币应用程序中，从而带来灾难性后果。 比特币的安全性依赖于对密钥的去中心化控制以及矿工的独立交易验证。如果你想利用比特币的安全性，你需要确保你保持在比特币安全模型中。简而言之：不要将密钥从用户手中接管，也不要将交易从区块链中移除。 例如，许多早期的比特币交易所将所有用户资金集中在单个“热”钱包中，密钥存储在单个服务器上。这种设计消除了用户的控制权，并集中控制单个系统中的密钥。许多此类系统已被黑客入侵，对客户造成灾难性后果。 另一个常见的错误是，为了减少交易费用或加速交易处理，错误地将交易“脱离区块链”。一个“离线的区块链”系统将在内部的集中式账本上记录交易，并且偶尔将它们同步到比特币区块链上。这种做法再次以专有和集中的方式取代了去中心化的比特币安全性。当交易离开区块链时，安全措施不当的集中账本可能被伪造，导致资金流失和储备枯竭，而不被人注意到。 除非您准备在运营安全，多层访问控制和审计（如传统银行所做的那样）上投入大量资金，否则在将资金用于比特币的去中心化环境外之前，应该仔细考虑。即使你有足够的资金和规则来实施强大的安全模式，这样的设计也只是复制了传统金融网络的脆弱模式，这种模式受到身份盗用，腐败和贪污的困扰。为了利用比特币独特的去中心化安全模式，您必须避免可能会感到熟悉但最终颠覆比特币安全性的集中式体系结构的诱惑。 信任根 Root of Trust 传统的安全体系结构基于一个称为 信任根 root of trust 的概念，它是一个可信的核心，用作整个系统或应用程序安全的基础。安全架构是围绕信任根发展起来的，是一系列同心圆，如洋葱中的层，从中心向外扩展信任。每层使用访问控制，数字签名，加密和其他安全基元构建更可信的内层。随着软件系统变得越来越复杂，它们更容易包含错误，这使得它们容易受到安全危害。结果，软件系统越复杂，就越难保证安全。信任根的概念可以确保大多数信任被放置在系统中最不复杂的部分，系统中最不易受影响的部分，更复杂的软件则围绕着它。这种安全体系结构在不同规模上重复出现，首先在单个系统的硬件中建立信任根，然后通过操作系统将信任根扩展到更高级的系统服务，最后跨越多个服务器减少信任。 比特币安全架构不同。在比特币中，共识系统创建了一个完全分散的可信公共账本。经过正确验证的区块链使用创世区块作为信任根，建立一个直至当前区块的信任链。比特币系统可以也应该使用区块链作为他们的信任根。在设计由许多不同系统上的服务组成的复杂比特币应用程序时，您应仔细检查安全架构，以确定信任的位置。最终，唯一应该明确信任的是完全验证的区块链。如果您的应用程序明确或隐含地信任除区块链之外的任何其他信息，那么应该引起关注，因为它会引入漏洞。评估应用程序的安全体系结构的一个好方法是考虑每个单独的组件并评估一个假想的场景，其中该组件完全受到攻击并处于恶意行为者的控制之下。依次评估应用程序的每个组件受到危害时对整体安全性的影响。如果您的应用程序在组件受损时不再安全，则表明您错误地信任这些组件。一个没有漏洞的比特币应用程序应该只会损害比特币共识机制，这意味着它的信任根源是比特币安全架构中最强大的部分。 众多被黑客入侵的比特币交易所的例子有助于强调这一点，因为即使在最偶然的审查下，其安全架构和设计也会失败。这些集中式实施已经将信任明确地投入到比特币区块链以外的众多组件中，比如热钱包，集中化账本数据库，易受攻击的加密密钥以及类似的模式。 用户安全最佳实践 人类已经使用了数千年的物理安全控制。相比之下，我们在数字安全方面的经验还不到50年。现代通用操作系统并不是非常安全，并不适合存储数字货币。我们的电脑通过永远在线的互联网连接不断暴露于外部威胁下。他们运行数百个作者的数千个软件组件，通常无限制地访问用户的文件。在您的计算机上安装的数千个软件中，一个流氓软件，可能会危及您的键盘和文件，窃取存储在钱包应用程序中的任何比特币。保持计算机无病毒和无木马所需的计算机维护技能超出了大多数计算机用户的水平。 尽管有数十年来信息安全方面的研究和进步，但数字资产仍然很容易受到坚定的对手的攻击。即使是在金融服务公司，情报机构和国防承包商中受到高度保护和限制的系统也经常遭到侵犯。比特币创造的数字资产具有内在价值，可以被盗取，并立即不可撤销地转移给新的所有者。这为黑客创造了一个巨大的诱因。到目前为止，黑客在入侵之后不得不将身份信息或账户令牌（如信用卡和银行账户）转换为价值。尽管销赃和洗钱很困难，但我们发现盗窃案日益增多。比特币升级了这个问题，因为它不需要被销赃或洗钱；这是数字资产的内在价值。 幸运的是，比特币也创造了提高计算机安全性的动力。之前计算机被入侵的风险是模糊和间接的，比特币使这些风险变得清晰明了。在计算机上持有比特币有助于将用户的注意力集中在提高计算机安全性的需求上。作为比特币和其他数字货币的激增和采用的直接结果，我们看到了黑客技术和安全解决方案的升级。简而言之，黑客现在有了一个非常肥美的目标，而用户也有了明确的动机来保护自己。 在过去的三年中，作为比特币应用的直接结果，我们看到了以硬件加密，密钥存储和硬件钱包，多重签名技术以及数字托管等形式在信息安全领域的巨大创新。在下面的章节中，我们将研究实际用户安全的各种最佳实践。 物理比特币存储 让比特币离线称为 cold storage ，它是最有效的安全技术之一。冷存储系统是在离线系统（从未连接到互联网）上生成密钥并在纸上或数字媒体（如USB记忆棒）上离线存储的系统。 硬件钱包 从长远来看，比特币安全越来越多地采取硬件防篡改钱包的形式。与智能手机或台式电脑不同，比特币硬件钱包只有一个目的：安全地持有比特币。没有通用软件的危害并且接口有限，硬件钱包可以为非专业用户提供几乎万无一失的安全级别。我期望看到硬件钱包成为比特币存储的主要方法。有关这种硬件钱包的示例，请参阅 Trezor。 平衡风险 虽然大多数用户都对比特币失窃有正确的担忧，但风险更大。数据文件一直在丢失。如果他们包含比特币，损失会更加痛苦。为了保证他们的比特币钱包的安全，用户必须非常小心，不要太过分，而最终会失去比特币。2011年7月，一个众所周知的比特币意识和教育项目损失了近7,000比特币。为了防止盗窃，拥有者们实施了一系列复杂的加密备份。最后，他们意外地丢失了加密密钥，使得备份毫无价值并且失去了一笔财富。就像把钱埋在沙漠中一样，如果你过于仔细地保护你的比特币，你可能无法再找到它。 分散风险 你会把你的全部资产以现金形式放入你的钱包吗？大多数人会认为鲁莽，但比特币用户经常把所有的比特币放在一个钱包里。相反，用户应该将风险分散到多种多样的比特币钱包中。谨慎的用户将比特币的一小部分，或许不到5％的比特币保留在在线或移动钱包中作为“零钱”。剩下的应该分成几种不同的机制存储，比如桌面钱包和离线（冷存储）。 多重签名和治理 每当公司或个人存储大量比特币时，他们应该考虑使用多重签名比特币地址。多重签名通过要求多个签名进行付款来解决资金安全问题。签名密钥应存储在多个不同位置，并由不同人员控制。例如，在公司环境中，密钥应该由多个公司管理人员独立生成并保存，以确保任何人都不会损害资金。多重签名地址也可以提供冗余，即一个人拥有多个存储在不同位置的密钥。 生存性 经常被忽视的一个重要的安全因素是可用性，特别是在密钥持有者无能力或死亡的情况下。比特币用户被告知使用复杂的密码，并保证他们的密钥安全和私密，而不与任何人分享。不幸的是，如果用户无法解锁，那么这种做法几乎不可能让用户的家人恢复任何资金。事实上，在大多数情况下，比特币用户的家族可能完全不知道比特币资金的存在。 如果你有很多比特币，你应该考虑与受信任的亲戚或律师分享访问细节。可以通过专门的称为“数字资产执行者”的律师，使用多重签名访问和资产规划设立更复杂的生存性计划。 总结 比特币是一种全新的，前所未有的复杂技术。随着时间的推移，我们将开发更好的安全工具和实践，使非专业人员更容易使用。目前，比特币用户可以使用这里讨论的许多技巧来享受安全且无故障的比特币体验。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 15:46:03 "},"14第十二章.html":{"url":"14第十二章.html","title":"区块链应用","keywords":"","body":"区块链应用 现在让我们通过将其视为 应用平台 application platform 来构建我们对比特币的理解。如今，许多人使用术语“区块链”来指任何共享比特币设计原则的应用平台。这个术语经常被滥用，并且被应用于许多未能交付比特币区块链提供的主要功能的东西。 在本章中，我们将看看比特币区块链作为应用程序平台提供的功能。我们将考虑应用程序构建 原语 primitives，构成了区块链应用程序的构建模块。我们将看看使用这些原语的几个重要应用程序，例如彩色币（Colored coins），支付（状态）通道和路由支付通道（闪电网络 Lightning Network）。 简介 比特币系统被设计成一个去中心化的货币和支付系统。然而，它的大部分功能都来源于更低层次的构造，可用于更广泛的应用程序。比特币不是由诸如账户，用户，余额和支付等组件构建的。相反，它使用具有低级加密函数的交易脚本语言，就像我们在 [transactions] 中看到的那样。正如帐户，余额和支付的更高级概念可以从这些基本原语中派生出来一样，许多其他复杂的应用程序也是如此。因此，比特币区块链可以成为一个应用平台，为智能合约等应用提供信托服务，远超数字货币和支付的原始目的。 构建模块（原语） 长期正确运行时，比特币系统提供了一定的保证，可用作构建模块来创建应用程序。这些包括： 无双重支付 No Double-Spend 比特币去中心化共识算法的最基本的保证，确保UTXO不会花费两次。 不变性 Immutability 一旦交易记录在区块链中，并且后续的区块已经添加了足够的工作量，交易的数据就变得不可变。不变性由能源保证，因为重写区块链需要耗费能源来生产工作量证明。所需的能量以及不变程度随着包含交易的区块顶部的工作量而增加。 中立性 Neutrality 去中心化比特币网络传播有效交易，无论这些交易的来源或内容如何。这意味着任何人都可以创建一个有足够费用和信任的有效交易，他们可以随时传输该交易并将其包含在区块链中。 安全时间戳 Secure Timestamping 共识规则拒绝任何有离得太远的过去或未来的时间戳的块。这确保块上的时间戳可以被信任。块上的时间戳意味着对所有包含的交易的输入的未使用保证。 授权 Authorization 数字签名经过去中心化网络验证，可提供授权保证。包含数字签名要求的脚本不能在脚本中隐含的私钥持有者未经授权的情况下执行。 可审计性 Auditability 所有交易都是公开的，可以进行审计。所有的交易和区块都可以链接到创世区块。 会计 Accounting 在任何交易中（除了coinbase交易），输入的价值等于输出加上费用的价值。在交易中创建或销毁比特币值是不可能的。输出不能超过输入。 不过期 Nonexpiration 有效的交易不会过期。如果它今天有效，只要输入没有被消耗并且共识规则没有改变，它将在不久的将来也有效。 完整性 Integrity 使用 SIGHASH_ALL 签署的比特币交易或由另一种 SIGHASH 类型签署的交易的部分不能在未使签名无效的情况下进行修改，修改将导致交易本身无效。 交易原子性 Transaction Atomicity:: 比特币交易是原子的。它们要么是有效并被确认的（挖掘），要么不是。不完整的交易不能开采，交易没有临时状态。在任何时候，交易都是开采或不开采。 离散（不可分）单位的价值 Discrete (Indivisible) Units of Value 交易的输出是离散的和不可分割的价值单位。它们可以全部用完或不使用，不能分开或部分使用。 控制法定人数 Quorum of Control 脚本中的多重签名限制了多重签名方法中预定义的法定权限。 M-N要求由共识规则强制执行。 时间锁/老化 Timelock/Aging 包含相对或绝对时间锁的任何脚本语句只能在其年龄超过指定时间后才能执行。 复制 Replication 区块链的分散存储确保了在交易开始时，经过充分的确认后，它可以在整个网络中进行复制，是持久化的，并且对断电，数据丢失等具有恢复能力。 防伪 Forgery Protection 交易只能花费现有的已验证输出。不可能创造或伪造价值。 一致性 Consistency 在没有矿工分区的情况下，记录在区块链中的区块会根据它们被记录的深度而受到重组或不一致的可能性呈指数下降。一旦深刻记录，改变所需的计算和能量使得改变几乎不可行。 记录外部状态 Recording External State 交易可以通过 OP_RETURN 提交一个数据值，表示一个外部状态机器中的状态转换。 可预见的发行 Predictable Issuance 不到2100万比特币将以可预测的速度发行。 构建模块的列表并不完整，会随每一项引入到比特币的新功能而增加。 构建模块的应用 比特币提供的构建模块是可用于构成应用程序的信任平台的组成部分。以下是当前存在的应用程序示例以及它们使用的构建块： 存在性证明（数字公证） Proof-of-Existence (Digital Notary) 不变性+时间戳+持久化。数字指纹可以通过交易提交给区块链，证明文件在记录时存在（时间戳）。指纹不能在事后修改（不可变性），并且证明将被永久保存（持久化）。 众筹平台（闪电网络） Kickstarter (Lighthouse) 一致性+原子性+完整性。如果你签署一项输入和一项众筹交易的输出（完整性），其他人可以为筹款捐款，但直到目标（输出价值）达到（一致性）后才能支付（原子性）。 支付通道 Payment Channels 控制法定人数+时间锁定+无双重支付+不过期+审查阻力+授权。具有时间锁定（时间锁定）作为支付通道的“结算”交易的多重签名2-of-2（控制法定人数）可以由任何一方（授权）在任何时间（审查阻力）持有（不过期）。然后，双方可以创建承诺交易，在较短的时间间隔（Timelock）上双重支付花费（无双重支付，双重支付可使之前的交易无效）\"结算\"。 彩色币 我们将要讨论的第一个区块链应用是 彩色币 colored coins。 彩色币是指使用比特币交易记录比特币以外的资产的创建，所有权和转让的一组类似技术。所谓“外部”，我们指的不是直接存储在比特币区块链中的资产，不是比特币本身，这是区块链固有的资产。 彩色币用于追踪数字资产以及第三方持有的有形资产，并通过彩色币进行所有权交易。数字资产彩色币可以代表无形资产，如股票证书，许可证，虚拟财产（游戏物品）或大多数任何形式的许可知识产权（商标，版权等）。有形资产的彩色币可以代表商品（金，银，油），土地所有权，汽车，船只，飞机等的所有权证书。 这个术语来源于“着色”或标记比特币的名义数量的想法，例如单一的satoshi，代表比特币价值本身以外的其他东西。作为一个类比，考虑在1美元钞票上加上一个信息，说明“这是ACME的股票证书” 或 “这张钞票可以兑换1盎司白银”，然后交易1美元钞票作为其他资产所有者的证书。第一个彩色币的实现，名为 Enhanced Padded-Order-Based Coloring 或 EPOBC，将外部资产分配到1-satoshi输出。通过这种方式，这是一个真正的“彩色币”，因为每个资产都被添加为一个单独的属性（颜色）。 最近的彩色币实现使用 OP_RETURN 脚本操作码在交易中存储元数据，与将元数据关联到特定资产的外部数据存储一起使用。 如今两个最出色的彩色币实现是 Open Assets 和 Colored Coins by Colu. 这两个系统使用不同的方法来处理彩色币，且不兼容。在一个系统中创建的彩色币不能在另一个系统中看到或使用。 使用彩色币 彩色币通常在特殊钱包中创建，转移和查看，这些币可以解释附加到比特币交易的彩色币协议元数据。必须特别注意避免在常规比特币钱包中使用与彩色币相关的密钥，因为常规钱包可能会破坏元数据。同样，不应将彩色币发送到由常规钱包管理的地址，只能发送给由可识别彩色币的钱包管理的地址。Colu和Open Assets系统都使用特殊的彩色币地址来降低这种风险，并确保彩色硬币不会发送给未知的钱包。 对于大多数通用区块链浏览器来说，彩色币也是不可见的。相反，你必须使用彩色币资源管理器来解析彩色币交易的元数据。 可以在 coinprism 找到与 Open Assets 兼容的钱包应用程序和区块链浏览器。 Colu彩色币兼容的钱包应用程序和区块链浏览器可以在这里找到： Blockchain Explorer. Colored Coins Copay Addon 是一个 Copay 钱包插件。 发行彩色币 每个彩色币的实现都有不同的创建彩色币的方式，但它们都提供了类似的功能。创建彩色币资产的过程称为 发行 issuance。初始交易，issuance transaction 将资产注册在比特币区块链中，并创建一个用于引用资产的 asset ID。一旦发布，可以使用 transfer transactions 在地址之间转移资产。 作为彩色币发行的资产可以有多个属性。它们可以是 divisible 或 indivisible，意味着传输中资产的数量可以是整数（例如5）或小数（例如4.321）。资产也可以有 fixed issuance，也就是说一定金额只发行一次，或者 reissued，意味着资产的新单位可以在初始发行后由原发行人发行。 最后，一些彩色币支持dividends，允许将比特币付款按所有权比例分配给着色货币资产的所有者。 彩色币交易 给彩色币交易赋予意义的元数据通常使用 OP_RETURN 操作码存储在其中一个输出中。不同的彩色币协议对 OP_RETURN 数据的内容使用不同的编码。包含 OP_RETURN 的输出称为 标记输出 marker output。 输出的顺序和标记输出的位置在彩色硬币协议中可能有特殊含义。例如，在 Open Assets 中，标记输出之前的任何输出均表示资产发放，之后的任何输出都代表资产转移。标记输出通过引用交易中的顺序来为其他输出分配特定的值和颜色。 作为对比，在 Colu 中, 标记输出对决定元数据解释方式的操作码进行编码。操作码0x01至0x0F指示发行交易。发行操作码通常后面跟着一个资产ID或其他标识符，可用于从外部来源（例如，bittorrent）检索资产信息。操作码0x10到0x1F表示转移交易。转移交易元数据包含简单的脚本，通过参考其索引，将特定数量的资产从输入转移到输出。输入和输出的排序对于脚本的解释非常重要。 如果元数据太长以至于无法放入 OP_RETURN，彩色币协议可能会使用其他“技巧”在交易中存储元数据。示例包括将元数据放入赎回脚本中，然后加上 OP_DROP 操作码以确保脚本忽略元数据。另一种使用的机制是1-of-N 多重签名脚本，其中只有第一个公钥是真正的公钥，可以花费输出，随后的“密钥”被编码的元数据替代。 为了正确解释彩色硬币交易中的元数据，你必须使用兼容的钱包或区块浏览器。否则，交易看起来像是一个带有 OP_RETURN 输出的“普通”比特币交易。 作为一个例子，我使用彩色币创建并发布了MasterBTC资产。 MasterBTC资产代表本书免费副本的代金券。这些优惠券可以使用彩色币兼容的钱包进行转让，交易和兑换。 对于这个特定的例子，我使用了 https://coinprism.info 上的钱包和浏览器，它使用Open Assets彩色币协议。 The issuance transaction as viewed on coinprism.info 使用Coinprism区块浏览器展示了发行交易： https://www.coinprism.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec) Figure 1. The issuance transaction as viewed on coinprism.info 如你所见，coinprism展示了20个“Mastering Bitcoin比特币的免费副本”MasterBTC资产发布到一个特殊的彩色币地址： akTnsDt5uzpioRST76VFRQM8q8sBFnQiwcx > 发送到此地址的任何资金或有色资产将永远丢失。不要将价值发送到这个示例地址！ 发行交易的交易ID是“正常”的比特币交易ID。The issuance transaction on a block explorer that doesn’t decode colored coins 在不能解析彩色币的区块浏览器中显示相同的交易。我们将使用blockchain.info： https://blockchain.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec Figure 2. The issuance transaction on a block explorer that doesn’t decode colored coins 如你所见，blockchain.info不会将其识别为彩色币交易。实际上，它用红色字母标记第二个输出为“无法解码输出地址”。 如果你选择 \"Show scripts & coinbase\" , 你会看到交易的更多信息 (The scripts in the issuance transaction). Figure 3. The scripts in the issuance transaction blockchain.info 还是不理解第二个输出。它用红色字母中的“Strange”标记。但是，我们可以看到标记输出中的一些元数据是人类可读的 OP_RETURN 4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559 (decoded) \"OA____u=https://cpr.sm/FoykwrH6UY 让我们使用 bitcoin-cli 检索交易： $ bitcoin-cli decoderawtransaction `bitcoin-cli getrawtransaction 10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec` 剔除交易的其他部分，第二个输出如下所示： { \"value\": 0.00000000, \"n\": 1, \"scriptPubKey\": \"OP_RETURN 4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559\" } 前缀 4F41 表示字母 \"OA\"，表示 \"Open Assets\"，帮我们通过Open Assets协议识别接下来的元数据。下面的ASCII编码字符串是资产定义的链接： u=https://cpr.sm/FoykwrH6UY 如果我们检索这个URL，我们得到一个JSON编码的资产定义，如下所示： { \"asset_ids\": [ \"AcuRVsoa81hoLHmVTNXrRD8KpTqUXeqwgH\" ], \"contract_url\": null, \"name_short\": \"MasterBTC\", \"name\": \"Free copy of \\\"Mastering Bitcoin\\\"\", \"issuer\": \"Andreas M. Antonopoulos\", \"description\": \"This token is redeemable for a free copy of the book \\\"Mastering Bitcoin\\\"\", \"description_mime\": \"text/x-markdown; charset=UTF-8\", \"type\": \"Other\", \"divisibility\": 0, \"link_to_website\": false, \"icon_url\": null, \"image_url\": null, \"version\": \"1.0\" } 合约币 Counterparty 合约币（Counterparty）是一个建立在比特币之上的协议层。合约币协议类似于彩色币，可以创建和交易虚拟资产和代币。另外，合约币提供资产的去中心化交易所。合约币也正在实施基于以太坊虚拟机（EVM）的智能合约。 像彩色硬币协议一样，Counterparty在比特币交易中嵌入元数据，使用 OP_RETURN 操作码或1-of-N多重签名地址在公钥的位置对元数据进行编码。使用这些机制，Counterparty实现了一个以比特币交易编码的协议层。附加协议层可以被支持合约币的应用程序解释，例如钱包和区块链浏览器，或者使用Counterparty库构建的任何应用程序。 合约币可以用作其他应用程序和服务的平台。例如，Tokenly是一个基于Counterparty构建的平台，它允许内容创作者，艺术家和公司发布表示数字所有权的标记，并可用于租用，访问，交易或购买内容，产品和服务。利用合约币的其他应用包括游戏（创世纪法术）和网格计算项目（折叠硬币）。 Counterparty 的更多信息可以在 https://counterparty.io 找到，开源项目位于 https://github.com/CounterpartyXCP. 支付通道和状态通道 Payment Channels and State Channels 支付通道 Payment channels 是在比特币区块链之外，双方交换比特币交易的去信任机制。这些交易如果在比特币区块链上结算，将变为有效的，而不是作为最终批量结算的普通票据。由于交易没有结算，因此可以在没有通常的结算等待时间的情况下进行交换，从而实现极高的交易吞吐量，低（亚毫秒级）的延迟以及精细的（satoshi水平）粒度。 其实，channel这个词是一个比喻。状态通道是虚拟结构，由区块链之外的两方之间的状态交换来表示。本身没有“通道”，底层的数据传输机制不是通道。我们使用术语\"通道\"来代表区块链之外的双方之间的关系和共享状态。 为了进一步解释这个概念，考虑一个TCP流。从更高级协议的角度来看，它是连接互联网上的两个应用程序的“套接字”。但是如果你查看网络流量，TCP流只是IP数据包上的虚拟通道。 TCP流的每个端点序列化并组装IP包以创建字节流的幻觉。在下面，它是所有断开的数据包。同样，支付通道只是一系列交易。如果排序正确并且连接良好，即使你不信任通道的另一端，他们也会创建可信任的可兑换义务。 在本节中，我们将看看各种支付通道。首先，我们将研究用于构建计量微支付服务（例如视频流）的单向（单向）支付通道的机制。然后，我们将扩大这种机制，并引入双向支付通道。最后，我们将研究如何在路由网络中点对点连接双向通道以形成多跳通道，首先以 Lightning Network 的名字提出。 支付通道是状态通道更广泛概念的一部分，代表了状态的脱链改变，并通过区块链中的最终结算来保证。支付通道是一种状态通道，其中被更改的状态是虚拟货币的余额。 状态通道 —— 基本概念和术语 通过在区块链上锁定共享状态的交易，双方建立状态通道。这被称为 存款交易 funding transaction 或 锚点交易 anchor transaction。这笔交易必须传输到网络并开采以建立通道。在支付通道的示例中，锁定状态是通道的初始余额（以货币计）。 然后双方交换签名的交易，称为 承诺交易 commitment transactions，它改变了初始状态。这些交易是有效的交易，因为它们可以提交给任何一方进行结算，但是在通道关闭之前，它们会被各方关闭。状态更新可以创建得尽可能快，因为每个参与方都可以创建，签署和传输交易给另一方。实际上，这意味着每秒可以交换数千笔交易。 在交换承诺交易时，双方也会使以前的状态无效，以便最新的承诺交易永远是唯一可以兑换的承诺交易。这样可以防止任何一方通过单方面关闭通道并以过期的先前状态作为对当前状态更有利的通道进行作弊。我们将研究在本章其余部分中可用于使先前状态无效的各种机制。 在通道的整个生命周期内，只有两笔交易需要提交区块链进行挖矿：存款和结算交易。在这两个状态之间，双方可以交换任何其他人从未见过的承诺交易，也不会提交区块链。 A payment channel between Bob and Alice, showing the funding, commitment, and settlement transactions 说明了Bob和Alice之间的支付通道，显示了存款，承诺和结算交易。 Figure 4. A payment channel between Bob and Alice, showing the funding, commitment, and settlement transactions 简单支付通道示例 为了解释状态通道，我们从一个非常简单的例子开始。我们展示了一个单向通道，意味着价值只在一个方向流动。我们也将从天真的假设开始，即没有人试图欺骗，保持简单。一旦我们解释了基本的通道想法，我们就会看看如何让它变得去信任的，使得任何一方都不会作弊，即使他们想要作弊。 对于这个例子，我们将假设两个参与者：Emma和Fabian。 Fabian提供了一个视频流媒体服务，使用微型支付通道按秒收费。 Fabian每秒视频收费0.01毫比特币（0.00001 BTC），相当于每小时视频36毫比特币（0.036 BTC）。 Emma是从Fabian购买此流视频服务的用户。 Emma purchases streaming video from Fabian with a payment channel, paying for each second of video 显示了Emma使用支付通道从Fabian购买视频流媒体服务。 Figure 5. Emma purchases streaming video from Fabian with a payment channel, paying for each second of video 在这个例子中，Fabian和Emma正在使用特殊的软件来处理支付通道和视频流。 Emma在浏览器中运行该软件，Fabian在服务器上运行该软件。该软件包括基本的比特币钱包功能，并可以创建和签署比特币交易。这个概念和术语“支付通道”对用户来说都是完全隐藏的。他们看到的是按秒付费的视频。 为了建立支付通道，Emma和Fabian建立了一个2-of-2多重签名地址，每个地址都有一个密钥。从Emma的角度来看，她浏览器中的软件提供了一个带有P2SH地址的QR码（以“3”开头），并要求她提交长达1小时视频的“存款”，地址由Emma进行存款。支付给多重签名地址的Emma的交易是支付通道的存款或锚定交易。 对于这个例子，假设Emma建立了36毫比特币（0.036 BTC）的通道。这将允许Emma使用流式视频1小时以上。在这种情况下，存款交易可通过channel capacity 设置在此通道中传输的最大金额。 资金交易消耗Emma钱包的一个或多个输入，来创建存款。它为Emma和Fabian之间联合控制的多重签名2地址创建了一个36毫比特币的输出。可能会有找零的输出返回Emma的钱包。 一旦存款交易得到确认，Emma可以开始观看流式视频了。Emma的软件创建并签署了一项承诺交易，该交易将通道余额改为给Fabian地址0.01mBTC，并退还给Emma 35.99mBTC。 Emma签署的交易消耗了资金交易产生的36mBTC输出，并产生两个输出：一个用于她的退款，另一个用于Fabian的付款。交易只是部分签署 - 它需要两个签名（2个2），但只有艾玛的签名。当Fabian的服务器接收到这个交易时，它会添加第二个签名（用于2的2输入）并将其返回给Emma以及1秒的视频。现在双方都有完全签署的承诺交易，可以兑换，代表通道正确的最新余额。任何一方都不会将此交易广播到网络。 在下一轮中，Emma的软件创建并签署了另一个承诺交易（承诺＃2），该交易消耗了资金交易中的2-of-2输出。第二个承诺交易为Fabian的地址分配一个0.02毫比的输出和一个35.98毫比的输出返回Emma的地址。这项新的交易是视频累计秒数的付款。Fabian的软件签署并返回第二个承诺交易，再加上另一秒视频。 通过这种方式，Emma的软件继续将承诺交易发送给Fabian的服务器以换取流式视频。随着Emma消费更多的视频，通道的余额逐渐积累，以支付Fabian。假设Emma观看视频600秒（10分钟），创建和签署了600个承诺交易。最后一次承诺交易（＃600）将有两个输出，将通道的余额，6 mBTC分给Fabian，30 mBTC 给Emma。 最后，Emma点击“Stop”停止视频流。 Fabian或Emma现在可以传输最终状态交易以进行结算。最后一笔交易是结算交易，并向Fabian支付所有Emma消费的视频费用，将剩余的资金交易退还给Emma。 Emma’s payment channel with Fabian, showing the commitment transactions that update the balance of the channel 显示Emma和Fabian之间的通道以及更新通道余额的承诺交易。 最终，在区块链上只记录两笔交易：建立通道的存款交易和在两个参与者之间正确分配最终余额的结算交易。 Figure 6. Emma’s payment channel with Fabian, showing the commitment transactions that update the balance of the channel 建立无需信任的通道 我们刚才描述的通道是有效的，但只有双方合作，没有任何失败或欺骗企图。我们来看看一些破坏这个通道的情景，看看需要什么来解决这些问题： 一旦存款交易发生，Emma需要Fabian的签名才能获得任何退款。如果Fabian消失，艾玛的资金被锁定在2-of-2交易中，并且实际上已经丢失了。如果其中一方在至少有一个由双方签署的承诺交易之前断开连接，则此通道的存款会丢失。 在通道运行的同时，Emma可以接受Fabian已经签署的任何承诺交易，并将其中一个交易给区块链。为什么要支付600秒的视频，如果她可以传输承诺交易＃1并且只支付1秒的视频费用？该通道失败，因为Emma可以通过播出对她有利的事先承诺而作弊。 这两个问题都可以通过timelocks来解决，我们来看看如何使用交易级时间锁（nLocktime）。 除非有退款保障，否则Emma不能冒险支付2-of-2的多重签名交易。为了解决这个问题，Emma同时构建存款和退款交易。她签署了存款交易，但并未将其转交给任何人。 Emma只将退款交易转交给Fabian并获得他的签名。 退款交易作为第一笔承诺交易，其时间锁确定了通道的生命上限。在这种情况下，Emma可以将 nLocktime 设置为未来30天或4320个块。所有后续承诺交易的时间锁必须更短，以便在退款交易前兑换。 现在Emma已经完全签署了退款交易，她可以自信地传输已签署的资金交易，因为她知道她可以最终在时限到期后即使Fabian消失也可以赎回退款交易。 在通道生命周期中，各方交换的每一笔承诺交易将被锁定在未来。但是对于每个承诺来说，延迟时间会略短，所以最近的承诺可以在其无效的先前承诺前赎回。由于 nLockTime，双方都无法成功传播任何承诺交易，直到其时间锁到期。如果一切顺利，他们将通过结算交易优雅地合作和关闭通道，从而不必传输中间承诺交易。否则，可以传播最近的承诺交易以结算账户并使所有之前的承诺交易无效。 例如，如果承诺交易＃1被时间锁定到将来的第4320个块，承诺交易＃2时间锁定到将来的4319个块。在承诺交易＃1有效之前的600个块时，承诺交易＃600可以花费。 Each commitment sets a shorter timelock, allowing it to be spent before the previous commitments become valid 展示了每个承诺交易设置一个更短的时间段，允许它在先前的承诺变得有效之前花费。 Figure 7. Each commitment sets a shorter timelock, allowing it to be spent before the previous commitments become valid 每个后续承诺交易都必须具有较短的时间锁，以便可以在其前任和退款交易之前进行广播。先前广播承诺的能力确保它能够花费资金输出并阻止任何其他承诺交易通过花费输出。比特币区块链提供的担保，防止双重支付和强制执行时间锁，有效地允许每笔承诺交易使其前任者失效。 状态通道使用时间锁来实施跨时间维度的智能合约。在这个例子中，我们看到时间维度如何保证最近的承诺交易在任何先前的承诺之前变得有效。因此，可以传输最近的承诺交易，花费输入并使先前的承诺交易无效。具有绝对时间锁保护的智能合约的执行可防止一方当事人作弊。这个实现只需要绝对的交易级时间锁（ nLocktime）。接下来，我们将看到如何使用脚本级时间锁 CHECKLOCKTIMEVERIFY 和 CHECKSEQUENCEVERIFY 来构建更灵活，更实用，更复杂的状态通道。 单向支付通道的第一种形式在2015年由阿根廷开发团队演示为视频流应用原型。你可以在 streamium.io. 看到。 时间锁不是使先前承诺交易无效的唯一方法。在接下来的部分中，我们将看到如何使用撤销密钥来实现相同的结果。时间锁是有效的，但它们有两个明显的缺点。通过首次打开通道时建立最大时间锁，它们会限制通道的使用寿命。更糟糕的是，他们强迫通道的实现在允许长期通道和迫使其中一个参与者在过早关闭的情况下等待很长的退款时间之间取得余额。例如，如果你允许通道保持开放30天，通过将退款时间锁定为30天，如果其中一方立即消失，另一方必须等待30天才能退款。终点越远，退款越远。 第二个问题是，由于每个后续承诺交易都必须减少时间间隔，因此对双方之间可以交换的承诺交易数量有明确的限制。例如，一个30天的通道，在未来设置一个4320块的时间段，在它必须关闭之前，只能容纳4320个中间承诺交易。将时间锁承诺交易的间隔设置为1个块存在危险。通过将承诺交易之间的时间间隔设置为1个块，开发人员为通道参与者创造了非常高的负担，这些参与者必须保持警惕，保持在线和观看，并随时准备好传输正确的承诺交易。 现在我们理解了如何使用时间锁定来使先前的承诺失效，我们可以看到通过合作关闭通道和通过广播承诺交易单方面关闭通道的区别。所有承诺交易都是时间锁定的，因此广播承诺交易总是需要等待，直到时间锁已过。但是，如果双方就最终余额达成一致并知道它们都持有承诺交易并最终实现这一余额，那么它们可以在没有时间锁表示同样余额的情况下构建结算交易。在合作关系中，任何一方都采取最近的承诺交易，并建立一个结算交易，除了省略时间锁之外，交易在每个方面都是相同的。双方都可以签署这笔结算交易，因为他们知道没有办法作弊并获得更有利的余额。通过合作签署和转交结算交易，他们可以关闭通道并立即赎回余额。最差的情况下，其中一方可能会小心谨慎，拒绝合作，并强迫对方单方面使用最近的承诺交易关闭。但如果他们这样做，他们也必须等待他们的资金。 不对称可撤销承诺 Asymmetric Revocable Commitments 处理先前承诺状态的更好方法是明确撤销它们。但这并不容易实现。比特币的一个关键特征是，一旦交易有效，它保持有效状态且不会过期。取消交易的唯一方法是在开采之前将其输入与其他交易双重支付。这就是为什么我们在上面的简单支付通道示例中使用时间锁的原因，确保在较早的承诺有效之前可以花费最近的承诺。但是，按时间排列承诺产生了一些限制，使支付通道难以使用。 即使交易无法取消，也能以不希望使用它的方式构建交易。方法是给每一方一个 撤销密钥 revocation key ，如果他们试图欺骗，可以用来惩罚对方。这种撤销先前承诺交易的机制最初是作为闪电网络（Lightning Network）的一部分提出的。 为了解释撤销钥匙，我们将在Hitesh和Irene运营的两个交易所之间构建一个更复杂的支付通道。Hitesh和Irene分别在印度和美国经营比特币交易所。 Hitesh印度交易所的客户经常向Irene的美国交易所的客户支付款项，反之亦然。目前，这些交易发生在比特币区块链上，但这意味着要支付费用并等待几个区块进行确认。在交易所之间建立支付通道将显著降低成本并加快交易流程。 Hitesh和Irene通过合作构建存款交易来启动通道，每一方都向通道支付5比特币资金。 最初的余额是Hitesh的5比特币和Irene的5比特币。资金交易将通道状态锁定为2-of-2的多重签名，就像简单通道的例子一样。 存款交易可能有来自Hitesh的一个或多个输入（加起来5比特币或更多），以及来自Irene的一个或多个输入（加起来5比特币或更多）。输入必须略高于通道容量才能支付交易费用。该交易有一个输出，将10比特币锁定为由Hitesh和Irene控制的2-of-2多重签名地址。交易也可能有一个或多个产出，如果他们的输入超过了他们预期的通道贡献，则会向Hitesh和Irene返回零钱。这是由双方提供并签署输入的单一交易。它必须由各方合作建立并由各方签字，然后才能传送。 现在，Hitesh和Irene不创建双方签署的单一承诺交易，而是创建两个 不对等 asymmetric 的承诺交易 Hitesh有两项输出的承诺交易。第一个输出 立即 支付Irene她5比特币。第二个输出向Hitesh支付5比特币，但是在1000块的时间锁之后。交易输出如下所示： Input: 2-of-2 funding output, signed by Irene Output 0 : CHECKSIG Output 1 : CHECKSEQUENCEVERIFY DROP CHECKSIG Irene有两个输出的不同承诺交易。第一个输出立即向Hitesh支付他5比特币。第二个输出支付Irene她5比特币，但是在1000块的时间段之后。 Irene持有的承诺交易（由Hitesh签名）如下所示： Input: 2-of-2 funding output, signed by Hitesh Output 0 : CHECKSIG Output 1 : CHECKSEQUENCEVERIFY DROP CHECKSIG 通过这种方式，每一方都有承诺交易，花费2-of-2的存款交易的输出。该输入由 另一方 签名。在任何时候拥有交易的一方也可以签署（完成2-of-2）和广播。但是，如果他们广播承诺交易，会立即付款给对方，而他们不得不等待一个短的时间锁。通过延迟其中一项输出的赎回，我们使各方在选择单方面广播承诺交易时处于轻微劣势。但仅有延时的话就不足以鼓励公平行为。 Two asymmetric commitment transactions with delayed payment for the party holding the transaction 展示了两个不对称承诺交易，其中支付给承诺持有人的输出被延迟。 Figure 8. Two asymmetric commitment transactions with delayed payment for the party holding the transaction 现在我们介绍这个方案的最后一个元素：一个可以防止作弊者广播过期承诺的撤销密钥。撤销密钥允许受骗方通过占用整个通道的余额来惩罚作弊者。 撤销密钥由两个密钥组成，每个密钥由每个通道参与者独立生成。它类似于一个2-of-2多重签名，但是使用椭圆曲线算法构造，双方都知道撤销公钥，但是每一方只知道撤销私钥的一半。 在每一轮中，双方向对方公开其一半的撤销密钥，从而如果此次撤销的交易被广播，可以给予另一方（现在拥有两半）用于要求罚款输出的手段。 每个承诺交易都有一个“延迟的”输出。该输出的兑换脚本允许一方在1000个区块之后兑换它，或者如果拥有撤销密钥，另一方可以赎回它，从而惩罚已撤销承诺的传输。 因此，当Hitesh创建一笔让Irene签署的承诺交易时，他将第二个输出在第1000个区块之后支付给自己，或者支付给撤销公钥（其中他只知道一半的密钥）。 Hitesh构造了这个交易。只有当他准备转移到新的通道状态并想要撤销这一承诺时，他才会向Irene展示他这一半的撤销密钥。 第二个支出的脚本如下: Output 0 : CHECKSIG Output 1 : IF # Revocation penalty output ELSE CHECKSEQUENCEVERIFY DROP ENDIF CHECKSIG Irene可以自信地签署这笔交易，因为如果这笔交易被传送，它会立即向她支付她应得的东西。 Hitesh持有该交易，但如果他通过单方面通道关闭传输，他将不得不等待1000个区块才能获得报酬。 当通道进入下一个状态时，Hitesh必须在Irene同意签署下一个承诺交易前撤销此承诺交易。要做到这一点，他所要做的就是将他的一半 revocation key 发给Irene。一旦Irene拥有将这项承诺的两半密钥，她就可以自信地签署下一个承诺。因为她知道如果Hitesh试图通过公布先前的承诺来作弊，她可以使用撤销钥匙来赎回Hitesh的延迟输出。如果Hitesh作弊，Irene会得到两个输出。同时，Hitesh只有该撤销公钥的一半撤销密钥，在后续1000块之前无法赎回输出。 Irene将能够在1000个区块到达之前赎回输出惩罚Hitesh。 撤销协议是双边的，这意味着在每一轮中，随着通道状态的前进，双方交换新的承诺，为以前的承诺交换撤销密钥，并签署对方的新的承诺交易。当他们接受一个新的状态时，他们通过给予对方必要的撤销密钥来惩罚任何作弊行为，使先前的状态无法使用。 我们来看一个它如何工作的例子。Irene的一位客户希望将2比特币发送给Hitesh的客户之一。为了在通道中传输2比特币，Hitesh和Irene必须推进通道状态以反映新的余额。他们将承诺一个新的状态（状态2号），其中10个比特币被分割，7个比特币给Hitesh，3个比特币给Irene。为了推进通道状况，他们将各自创建新的承诺交易，体现新的通道余额。 和以前一样，这些承诺交易是不对称的，因此每一方的承诺交易都会迫使他们在兑换时等待。至关重要的是，在签署新的承诺交易之前，他们必须首先交换撤销密钥以使先前的承诺失效。在这种特殊情况下，Hitesh的兴趣与通道的真实状态保持一致，因此他没有理由广播先前的状态。然而，对于Irene来说，状态1给她的余额高于状态2.当Irene将她的先前承诺交易（状态1）的撤销密钥给Hitesh时，她也撤销了她通过倒退通道获利的能力。因为有了撤销钥匙，Hitesh可以毫不拖延地赎回先前承诺交易的两个输出。这意味着，如果Irene广播先前的状态，Hitesh可以行使他的权利拿走所有输出。 重要的是，撤销不会自动发生。虽然Hitesh有能力惩罚Irene的作弊行为，但他必须认真观察区块链是否存在作弊迹象。如果他看到先前的承诺交易被广播，他有1000个区块时间采取行动，使用撤销密钥来阻止Irene的作弊行为，并通过取得全部10个比特币来惩罚她。 具有相对时间锁的不对称可撤销承诺（ CSV ） 是实施支付通道的更好方式，也是该技术非常重要的一项创新。通过这种构造，通道可以无限期地保持开放，并且可以拥有数十亿的中间承诺交易。在Lightning Network的原型实现中，承诺状态由48位索引标识，允许任何单个通道有超过281万亿次（2.8×1014）状态转换！ 哈希时间锁合约 Hash Time Lock Contracts (HTLC) 支付通道可以通过特殊类型的智能合约进一步扩展，允许参与者将资金发送到可赎回的密钥上，并有过期时间。此功能称为 Hash Time Lock Contract 或 HTLC ，并用于双向支付通道和路由支付通道。 我们先来解释HTLC的“哈希”部分。要创建HTLC，付款的预期接收人将首先创建一个密钥 R。然后他们计算这个密钥的的哈希值 H： H = Hash(R) 产生的哈希值 H 可以包含在输出的锁定脚本中。知道这个密钥的人可以用它来赎回输出。密钥 R 也被称为散列函数的 原象 preimage 。原象只是用作散列函数输入的数据。 HTLC的第二部分是“时间锁定”。如果密钥未透露，HTLC的付款人可以在一段时间后获得“退款”。这是通过使用 CHECKLOCKTIMEVERIFY 进行绝对时间锁定实现的。 实现了 HTLC 的脚本看起来是这样的： IF # Payment if you have the secret R HASH160 EQUALVERIFY ELSE # Refund after timeout. CHECKLOCKTIMEVERIFY DROP CHECKSIG ENDIF 任何知道密钥 R 的人，当哈希值等于 H 时，可以通过行使 IF 流的第一个子句来赎回该输出。 如果密钥未透露，HTLC声称，在一定数量的区块之后，付款人可以使用 IF 流程中的第二个条款要求退款。 这是HTLC的基本实现。这种类型的HTLC可以由具有密钥 R 的 任何人 兑换。对脚本稍作修改，HTLC可以采取许多不同的形式。例如，在第一个子句中添加一个 CHECKSIG 运算符和一个公钥，将哈希的兑换限制为一个指定的收款人，该收款人还必须知道密钥 R。 路由支付通道（闪电网络） 闪电网络是一个提议端到端连接的双向支付通道路由网络。像这样的网络可以允许任何参与者在无需信任任何中间人的情况下将支付从通道发送到通道。闪电网络 https://lightning.network/lightning-network-paper.pdf [由Joseph Poon和Thadeus Dryja于2015年2月首先描述]，建立在许多其他人提出和阐述的支付通道的概念上。 “闪电网络”是指用于路由支付通道网络的特定设计，现在已经由至少五个不同的开源团队实现。独立实现由一组互操作性标准进行协调：http://bit.ly/2rBHeoL[*Basics of Lightning Technology (BOLT)* paper]。 闪电网络的原型实现已由多个团队发布。目前，这些实现只能在testnet上运行，因为它们使用segwit，而没有在主比特币区块链（mainnet）上激活。 闪电网络是实施路由支付通道的一种可能方式。还有其他几个旨在实现类似目标的设计，例如Teechan和Tumblebit。 基本闪电网络示例 让我们看下它如何工作。 在这个例子中，有五个参与者：Alice，Bob，Carol，Diana和Eric。这五位参与者相互开设了支付通道，两两相连。 Alice 与 Bob，Bob 与 Carol，Carol 与 Diana，Diana 与 Eric。为了简单起见，我们假设每个参与者为每个通道提供2比特币，每个通道的总容量为4比特币。 A series of bidirectional payment channels linked to form a Lightning Network that can route a payment from Alice to Eric 展示了闪电网络中的五位参与者，通过双向支付通道进行关联，这些通道可以连接起来以支持 Alice 支付到 Eric (路由支付通道（闪电网络）). Figure 9. A series of bidirectional payment channels linked to form a Lightning Network that can route a payment from Alice to Eric Alice 想要支付 Eric 1比特币。但是，Alice 没有通过支付通道与 Eric 连接。创建一个支付通道需要一笔资金交易，这笔交易必须交给比特币区块链。Alice 不想开设新的支付通道并承诺更多的资金。有没有间接支付Eric的方法？ Step-by-step payment routing through a Lightning Network 展示了通过连接参与者的支付通道上的一系列 HTLC 承诺，从 Alice 支付到 Eric 的分步过程。 Figure 10. Step-by-step payment routing through a Lightning Network Alice 正在运行一个闪电网络（LN）节点，该节点跟踪她和Bob的支付通道，并且能够发现支付通道之间的路线。Alice 的 LN 节点还可以通过互联网连接到 Eric 的 LN 节点。 Eric 的 LN 节点使用随机数生成器创建一个密钥 R。Eric 的节点并没有向任何人透露这个密钥。Eric 的节点计算密钥 R 的散列 H 并将该散列传送给 Alice 的节点（参见 Step-by-step payment routing through a Lightning Network 步骤1）。 现在，Alice 的 LN 节点构造了 Alice 的 LN 节点和 Eric 的 LN 节点之间的路线。所使用的路由算法将在后面更详细地讨论，但现在让我们假设 Alice 的节点可以找到有效的路由。 然后，Alice 的节点构建一个HTLC，支付给哈希值 H，并有10个区块的超时退款（当前块 + 10），金额为1.003比特币（参见 Step-by-step payment routing through a Lightning Network 步骤2）。额外的0.003将用于补偿参与此支付路线的中间节点。Alice 向 Bob 提供这个 HTLC ，从 Bob 的通道余额中扣除 1.003 比特币并将其交给 HTLC。 HTLC具有以下含义：“如果鲍勃知道密钥，则 Alice 将1.003的通道余额付给Bob，或者如果经过10个块，则退还到 Alice 的余额。” Alice 和 Bob 之间的通道余额现在是由三项输出的承诺交易表示：Bob的2比特币，Alice的0.997比特币，Alice的HTLC的1.003比特币。Alice向HTLC承诺的金额减少了Alice的余额。 Bob现在有一个承诺，如果他能够在接下来的10个区块内获得密钥 R，他可以获得被Alice锁定的1.003。有了这个承诺，Bob的节点在Carol的支付通道上构建了一个HTLC。 Bob的HTLC承诺了9个区块超时的1.002比特币给 H，如果有密钥 R，Carol可以赎回（参见 Step-by-step payment routing through a Lightning Network 步骤3）。Bob知道，如果Carol可以获得他的HTLC，她必须有 R。如果Bob在9个区块时间内得到 R，他可以用它来向Alice索要Alice的HTLC。他还通过在9个区块时间内贡献他的通道余额获得了0.001比特币。如果Carol不能索要他的HTLC，他不能索要Alice的HTLC，那么一切都会恢复到之前的通道余额，没有人会不知所措。Bob和Carol之间的通道余额现在是：Carol的2，Bob的0.998，Bob到HTLC的1.002。 Carol现在有一个承诺，如果她在接下来的9个区块时间内获得 R，她可以索要由Bob锁定的1.002比特币。现在，她可以在她与Diana的通道上做HTLC承诺。她将一个1.001比特币的HTLC提交给哈希 H，8个区块过期时间，如果有密钥 R，Diana可以赎回（参见 Step-by-step payment routing through a Lightning Network 步骤4）。从Carol的角度来看，如果这样做的话，她能获得0.001比特币更好，如果没有，她什么都不会丢失。她到Diana的HTLC只有在 R 被揭示时才是可行的，在这一点上，她可以向Bob索取HTLC。Carol和Diana之间的通道余额现在是：Diana的2，Carol的0.99，Carol对HTLC承诺的1.001。 最后，Diana可以向Eric提供一个HTLC，将7个区块超时时间内支付1比特币给哈希 H（参见 Step-by-step payment routing through a Lightning Network 步骤5）。Diana和Eric之间的通道余额现在是：Eric的2，Diana的1，Diana到HTLC的1。 但是，在这条路线上，Eric 拥有 密钥 R。因此，他可以索要Diana提供的HTLC。他将 R 发送给 Diana 并索要1比特币，将其添加到他的通道余额中（参见 Step-by-step payment routing through a Lightning Network 步骤6）。通道余额现在是：Diana的1，Eric的3。 现在，Diana有密钥 R。因此，她现在可以从Carol那获得HTLC。 Diana将 R 发送给Carol，并将1.001比特币添加到她的通道余额中（参见 Step-by-step payment routing through a Lightning Network 步骤7）。现在，Carol和Diana之间的通道余额是：Carol的0.999，Diana的3.001。Diana参与这条支付路线“赢得”了0.001。 沿着路线返回，密钥 R 允许每个参与者索要HTLC。 Carol向Bob索要1.002，将他们的通道中的余额设置为：Bob的0.998，Carol的3.002（参见 Step-by-step payment routing through a Lightning Network 步骤8）。最后，Bob索要来自Alice的HTLC（参见 Step-by-step payment routing through a Lightning Network 步骤9）。他们的通道余额更新为：Alice的0.997，Bob的3.003。 Alice在没有与Eric开通通道的情况下就向Eric支付了1比特币。支付路径中的任何中间人都不需要互相信任。将他们的资金在通道中用于短期承诺，他们可以赚取一小笔费用，唯一的风险是如果通道关闭或路由支付失败，退款会有小幅延迟。 闪电网络传输和路由 LN节点之间的所有通信都是点对点加密的。另外，节点有一个长期的公钥，http://bit.ly/2r5TACm[用来向彼此授权]. 每当一个节点希望将支付发送给另一个节点时，它必须首先通过连接具有足够容量的支付通道来通过网络构建 路径 path。节点公布路由信息，包括他们已经打开了哪些通道，每个通道有多少容量，以及他们收取的路由支付费用。路由信息可以以各种方式共享，随着闪电网络技术的发展，可能会出现不同的路由协议。一些闪电网络实现使用IRC协议作为节点公布路由信息的便利机制。路由发现的另一个实现使用P2P模型，其中节点将通道公告传播给他们的同伴，采用“泛洪”模式，类似于比特币传播交易的机制。未来的计划包括名为 Flare 的提案，这是一种具有本地节点“邻居”和更远距离信标节点的混合路由模型。 在我们前面的例子中，Alice的节点使用这些路由发现机制之一来查找将她的节点连接到Eric节点的一条或多条路径。一旦Alice的节点构建了一条路径，她将通过网络传播一系列加密和嵌套指令，连接每个相邻的支付通道，初始化该路径。 重要的是，这条路只有Alice的节点才知道。支付路线中的所有其他参与者只能看到相邻的节点。从Carol的角度来看，这看起来像是Bob到Diana的付款。Carol并不知道Bob实际上是在转发Alice支付的一笔款项。她也不知道Diana会向Eric转账。 这是闪电网络的一个重要特征，因为它确保了付款隐私，并且使得应用监视，审查或黑名单非常困难。但是，Alice如何建立这种支付路径，而不向中间节点透露任何东西？ 闪电网络根据称为 Sphinx 的方案实施洋葱路由（onion-routed）协议。此路由协议可确保付款发起人可以通过 Lightning Network 构建和传递路径，以便： 中间节点可以验证和解密路由信息中属于他们的部分并找到下一跳。 除了上一跳和下一跳之外，他们无法了解路径中的任何其他节点。 他们无法识别付款路径的长度，或他们在该路径中的位置。 路径的每个部分都被加密，使得网络层的攻击者无法将来自路径不同部分的数据包相互关联。 与Tor（互联网上的洋葱路由匿名协议）不同，没有可以置于监控之下的“出口节点”。付款不需要传送到比特币区块链；节点只是更新通道余额。 使用这种洋葱路由协议，Alice将路径中的每个元素都封装在一个加密层中，从结尾开始并向后工作。她用Eric的公钥将一条消息加密给Eric。此消息包裹在一封加密给Diana的消息中，将Eric标识为下一个收件人。发给Diana的信息包裹在一封加密给Carol公钥的信息中，并将Diana确定为下一个收件人。给Carol的消息被加密到Bob的密钥。因此，Alice已经构建了这种加密的多层“洋葱”消息。她将此发送给Bob，他只能解密和解包外层。在里面，Bob发现一封给Carol的信，他可以转发给Carol，但不能自己破译。沿着路径，消息被转发，解密，转发等，一直到Eric。每个参与者只知道每跳中的前一个和下一个节点。 路径的每个元素都包含有关必须扩展到下一跳的HTLC信息，正在发送的金额，要包含的费用以及使HTLC过期的CLTV锁定时间（以区块为单位）。随着路由信息的传播，这些节点将HTLC承诺转发到下一跳。 此时，你可能想知道节点为何不知道路径的长度及其在该路径中的位置？毕竟，他们收到一条消息并将其转发到下一跳。根据它是否变短了，他们能够推断出路径大小和位置？为了防止这种情况，路径总是固定为20跳，并填充随机数据。每个节点都会看到下一跳和一个固定长度的加密消息来转发。只有最终收件人看到没有下一跳。对于其他人来说，总是还有20跳。 闪电网络的好处 闪电网络是次层路由技术。它可以应用于任何支持一些基本功能的区块链，例如多重签名交易，时间锁定和基本智能合约。 如果闪电网络位于比特币网络之上，那么比特币网络可以在不牺牲无中介无信任运转原则的情况下，大幅提升容量，隐私，粒度和速度： 隐私 Privacy 闪电网络支付比比特币区块链上的支付私有得多，因为它们不公开。虽然路线中的参与者可以看到通过其通道传播的付款，但他们不知道发件人或收件人。 可互换性 Fungibility 闪电网络使得在比特币上应用监视和黑名单变得更加困难，从而增加了货币的可互换性。 速度 Speed 使用Lightning Network的比特币交易以毫秒为单位进行结算，而不是以分钟为单位，因为在不提交交易给区块的情况下清算HTLC。 粒度 Granularity 闪电网络可以使支付至少与比特币“灰尘”限制一样小，可能甚至更小。一些提案允许subsatoshi（次聪）增量。 容量 Capacity 闪电网络将比特币系统的容量提高了几个数量级。闪电网络路由的每秒支付数量没有实际的上限，因为它仅取决于每个节点的容量和速度。 无信任运作 Trustless Operation 闪电网络在节点之间使用比特币交易，节点之间作为对等运作而无需信任。因此，闪电网络保留了比特币系统的原理，同时显着扩大了其运行参数。 当然，如前所述，闪电网络协议并不是实现路由支付通道的唯一方式。其他提议的系统包括Tumblebit和Teechan。但是，目前闪电网络已经部署在测试网络上。几个不同的团队开发了竞争性的LN实现，并正在朝着一个通用的互操作性标准（称为BOLT）努力。 Lightning Network很可能将成为第一个在生产环境中部署的路由式支付通道网络。 总结 我们只研究了一些可以使用比特币区块链作为信任平台构建的新兴应用。这些应用将比特币的范围扩展到支付范围和金融工具之外，涵盖了信任至关重要的许多其他应用。通过分散信任的基础，比特币区块链成为了一个平台，将在各行各业产生许多革命性的应用。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-01 15:56:47 "}}